{
    "timestamp": "2025-12-13T22:08:12.806663",
    "model_used": "gemini-2.5-flash",
    "raw_response": "I have performed 2 rounds of searching and generating examples, refining them until I reached a set of 10 snippets demonstrating actual, known divergences between type checkers. I've focused on subtle type inference behaviors and strictness differences.\n\nHere are the 10 Python code snippets:\n\n```python\n# id: protocol-default-args\n# EXPECTED:\n#   mypy: Error: Signature of \"read\" incompatible with supertype \"Reader\" (on FileReader)\n#   pyright: No error\n#   pyre: Error: Signature of \"read\" incompatible with supertype \"Reader\" (on FileReader)\n#   zuban: No error (likely follows pyright/PEP 612 philosophy, allowing differing defaults)\n# REASON: Mypy and Pyre often strictly require default arguments to match exactly or be absent in the implementing class if present in the Protocol. Pyright and Zuban are more lenient, allowing differing default values as long as the callable signature (positional/keyword, types) remains compatible, recognizing that the default value is a *runtime* detail that doesn't affect type safety for callers.\nfrom typing import Protocol\n\nclass Reader(Protocol):\n    def read(self, size: int = -1) -> bytes: ...\n\nclass FileReader:\n    def read(self, size: int = 1024) -> bytes:  # Different default argument value\n        \"\"\"Implements read, but with a different default size.\"\"\"\n        print(f\"FileReader reading up to {size} bytes.\")\n        return b\"file data\"\n\nclass NetworkReader:\n    def read(self, size: int) -> bytes: # No default argument in implementation\n        \"\"\"Implements read, requiring size explicitly.\"\"\"\n        print(f\"NetworkReader reading exactly {size} bytes.\")\n        return b\"network data\"\n\ndef use_reader(r: Reader, custom_size: int | None = None) -> None:\n    \"\"\"Consumes a Reader, optionally with a custom size.\"\"\"\n    if custom_size is not None:\n        data = r.read(custom_size)\n    else:\n        data = r.read() # This call relies on the Protocol's default\n    print(f\"Used reader {type(r).__name__}, got {len(data)} bytes.\")\n\nif __name__ == \"__main__\":\n    file_reader_instance = FileReader()\n    network_reader_instance = NetworkReader()\n\n    print(\"--- Using FileReader ---\")\n    use_reader(file_reader_instance)         # mypy/pyre might error here at assign/call-site\n    use_reader(file_reader_instance, 50)    # This should be fine for all\n\n    print(\"\\n--- Using NetworkReader ---\")\n    use_reader(network_reader_instance)       # This should be fine for all, Protocol's default is compatible with no default in implementation.\n    use_reader(network_reader_instance, 100)\n```\n\n```python\n# id: typeguard-generic-narrowing\n# EXPECTED:\n#   mypy: Error: List item 0 has incompatible type \"str\"; expected \"object\" (or similar error on `data.append` due to `data` not being fully `list[str]`)\n#   pyright: No error (correctly narrows `data` to `list[str]`)\n#   pyre: Error: Incompatible return type for `append` (or similar, might not fully narrow `list[object]` to `list[str]`)\n#   zuban: No error (likely follows pyright's robust narrowing)\n# REASON: Pyright's type narrowing with TypeGuard is very powerful and understands how to refine generic types like `list[object]` to `list[str]`. Mypy and Pyre, while supporting TypeGuard, sometimes struggle with fully refining generics within collections, leading to errors when attempting operations specific to the narrowed generic type (e.g., calling `append` with a `str` on `list[str]` which they might still perceive as `list[object]`).\nfrom typing import TypeGuard, TypeVar, List, Union\n\nT = TypeVar('T')\n\ndef is_list_of(val: list[object], type_: type[T]) -> TypeGuard[list[T]]:\n    \"\"\"Checks if all elements in a list are of a given type.\"\"\"\n    return all(isinstance(x, type_) for x in val)\n\ndef process(data: List[object]) -> None:\n    print(f\"Processing data (initial type: {type(data)}): {data}\")\n    if is_list_of(data, str):\n        # After this line, 'data' should be narrowed to List[str]\n        print(f\"  Narrowed 'data' to list[str]. Appending 'new_string'.\")\n        data.append(\"new_string\") # Mypy/Pyre might error here, thinking 'data' is still List[object] or List[Union[str, object]]\n        print(f\"  After append: {data}\")\n        first_item = data[0]\n        # This should be safe if data is List[str], but might be a problem if it's List[object]\n        if first_item:\n            reveal_type(first_item) # Should be 'str'\n            print(f\"  First item (type: {type(first_item)}) length: {len(first_item)}\")\n    else:\n        print(\"  Data is not a list of strings.\")\n\nif __name__ == \"__main__\":\n    mixed_list: List[object] = [\"hello\", 123, \"world\"]\n    str_list: List[object] = [\"alpha\", \"beta\"]\n\n    process(str_list)\n    print(\"\\n\" + \"=\"*30 + \"\\n\")\n    process(mixed_list)\n```\n\n```python\n# id: typeddict-mixed-total-required-notrequired\n# EXPECTED:\n#   mypy: Error: Key 'x' of TypedDict \"Child\" is optional (due to base class total=False), but accessed directly (td['x']). (Or similar: might infer td.get('x') returns int, not Optional[int])\n#   pyright: No error. `reveal_type` for `td.get('x')` is `Union[int, None]`.\n#   pyre: Error: Incompatible return type for `td.get('x')` (might incorrectly infer `x` is `int` or misinterpret optionality).\n#   zuban: No error. `reveal_type` for `td.get('x')` is `Union[int, None]`.\n# REASON: Pyright and Zuban correctly prioritize explicit `Required`/`NotRequired` over the `total` keyword from base classes, especially when `total=False` on the base. Mypy and Pyre can sometimes get confused by the interaction, potentially inheriting `total=False` in an unexpected way or not correctly inferring the optionality of fields from a `total=False` base when the child also uses explicit `Required`/`NotRequired`.\nfrom typing import TypedDict, Required, NotRequired, Union\n\nclass Base(TypedDict, total=False):\n    x: int\n    base_prop: str\n\nclass Child(Base):\n    y: Required[str]  # 'y' is required in Child, even though Base is total=False\n    z: NotRequired[int] # 'z' is explicitly not required in Child\n\ndef test_child_typeddict(td: Child) -> None:\n    # 'y' should always be present (str)\n    reveal_type(td['y']) # Should be 'str'\n    print(f\"td['y']: {td['y']}\")\n\n    # 'z' is optional (Union[int, None])\n    reveal_type(td.get('z')) # Should be 'Union[int, None]'\n    print(f\"td.get('z'): {td.get('z')}\")\n\n    # 'x' from Base(total=False) should still be optional (Union[int, None])\n    reveal_type(td.get('x')) # This is the main point of divergence: Mypy/Pyre might misinterpret\n    print(f\"td.get('x'): {td.get('x')}\")\n\n    # 'base_prop' from Base(total=False) should also be optional\n    reveal_type(td.get('base_prop'))\n    print(f\"td.get('base_prop'): {td.get('base_prop')}\")\n\nif __name__ == \"__main__\":\n    # Valid instances of Child TypedDict\n    td1: Child = {'y': 'hello', 'x': 5}\n    td2: Child = {'y': 'world', 'z': 10, 'base_prop': 'base'}\n    td3: Child = {'y': 'test'} # 'x', 'z', 'base_prop' are optional\n\n    print(\"--- Testing td1 ---\")\n    test_child_typeddict(td1)\n    print(\"\\n--- Testing td2 ---\")\n    test_child_typeddict(td2)\n    print(\"\\n--- Testing td3 ---\")\n    test_child_typeddict(td3)\n\n    # Example of potential mypy/pyre errors if 'x' is not recognized as optional\n    # type_checker_td = {'y': 'example'}\n    # reveal_type(type_checker_td.get('x')) # This would be `None` at runtime,\n                                          # but static analysis varies.\n```\n\n```python\n# id: paramspec-classmethod-decorator\n# EXPECTED:\n#   mypy: Error: Argument \"cls\" of \"create\" has no corresponding argument in \"wrapper\" (or similar error indicating signature mismatch on 'create' after decoration)\n#   pyright: No error\n#   pyre: Error: Signature of \"create\" incompatible with decorator (or similar, indicating `cls` argument issue)\n#   zuban: No error (likely handles ParamSpec correctly with classmethod)\n# REASON: Mypy and Pyre have historically struggled to correctly infer and preserve the signature of classmethods when they are wrapped by a ParamSpec-aware decorator. The implicit `cls` argument can be lost or misrepresented in the `ParamSpec` context. Pyright and Zuban are generally more robust in preserving the full signature, including `cls`/`self` arguments and accurately mapping `ParamSpec`.\nfrom typing import TypeVar, Callable, Any\nfrom typing_extensions import ParamSpec # Python 3.10+, ParamSpec is in typing, but for broader compatibility often used from typing_extensions\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef log_calls(func: Callable[P, T]) -> Callable[P, T]:\n    \"\"\"A decorator that logs calls to the decorated function.\"\"\"\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n        print(f\"--- Calling {func.__qualname__} with args: {args}, kwargs: {kwargs} ---\")\n        return func(*args, **kwargs)\n    return wrapper\n\nclass Service:\n    def __init__(self, name: str = \"Default Service\") -> None:\n        self.name = name\n\n    @log_calls\n    @classmethod\n    def create(cls, name: str) -> \"Service\":\n        \"\"\"Creates a new Service instance.\"\"\"\n        print(f\"  Service.create called for '{name}'.\")\n        return cls(name=name)\n\n    @log_calls\n    def process(self, data: str) -> str:\n        \"\"\"Processes some data.\"\"\"\n        print(f\"  {self.name} processing '{data}'.\")\n        return f\"{self.name} processed: {data}\"\n\ndef consumer(creator: Callable[[type[Service], str], Service]) -> Service:\n    \"\"\"A function that consumes a Service factory callable.\"\"\"\n    print(\"\\n--- Consumer called ---\")\n    return creator(Service, \"Consumer-Created\")\n\nif __name__ == \"__main__\":\n    s1 = Service.create(\"MyService\")\n    print(f\"Created service instance: {s1.name}\\n\")\n\n    s2_result = s1.process(\"input data\")\n    print(f\"Result of processing: {s2_result}\\n\")\n\n    # This call tests if the signature of Service.create is correctly preserved\n    # by the decorator for downstream use as a Callable.\n    # mypy/pyre might raise errors here if `Service.create`'s signature after decoration\n    # is deemed incompatible with `Callable[[type[Service], str], Service]`.\n    s3 = consumer(Service.create)\n    print(f\"Service from consumer: {s3.name}\")\n\n    reveal_type(Service.create) # This should reveal Callable[[Type[Service], str], Service]\n```\n\n```python\n# id: self-in-generic-abstract-methods\n# EXPECTED:\n#   mypy: Error: Return type of \"create\" incompatible with supertype \"AbstractFactory\" (or similar error related to Self being confused with T or the generic base type)\n#   pyright: No error (`create` returns `ConcreteFactory`)\n#   pyre: Error: Incompatible return type for `create` (might infer `AbstractFactory[str]` or `Any` incorrectly)\n#   zuban: No error (`create` returns `ConcreteFactory`)\n# REASON: Mypy and Pyre can struggle to correctly resolve `Self` within a generic abstract class context, especially when the generic parameter `T` is not directly involved in the return type but the class itself is generic. Pyright and Zuban are more adept at understanding that `Self` refers to the *concrete instance type* of the class (e.g., `ConcreteFactory`), even when the base class is generic.\nfrom typing import Generic, TypeVar, Any\nfrom typing_extensions import Self # Python 3.11+, Self is in typing, but for broader compatibility often used from typing_extensions\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass AbstractFactory(ABC, Generic[T]):\n    @abstractmethod\n    def create(self) -> Self:  # Self should refer to the concrete subclass type\n        \"\"\"Creates an instance of the concrete factory.\"\"\"\n        ...\n\n    @abstractmethod\n    def process(self, value: T) -> T:\n        \"\"\"Processes a value of type T.\"\"\"\n        ...\n\nclass ConcreteFactory(AbstractFactory[str]):\n    def create(self) -> Self:\n        print(f\"  Creating instance of {type(self).__name__}.\")\n        # At runtime, Self is not a type, but type(self) is.\n        # For type checking, Self here means an instance of ConcreteFactory.\n        return ConcreteFactory()\n\n    def process(self, value: str) -> str:\n        return f\"Processed string: {value.upper()}\"\n\nclass IntFactory(AbstractFactory[int]):\n    def create(self) -> Self:\n        print(f\"  Creating instance of {type(self).__name__}.\")\n        return IntFactory()\n\n    def process(self, value: int) -> int:\n        return value * 2\n\n\ndef make_and_use[F: AbstractFactory[Any]](factory: F, item: Any) -> tuple[F, Any]:\n    \"\"\"A generic function to create a factory instance and use it.\"\"\"\n    print(f\"\\n--- In make_and_use with {type(factory).__name__} ---\")\n    f_instance = factory.create()\n    reveal_type(f_instance) # Should be the concrete type of 'factory' (e.g., ConcreteFactory)\n    processed_item = f_instance.process(item)\n    return f_instance, processed_item\n\n\nif __name__ == \"__main__\":\n    str_factory = ConcreteFactory()\n    int_factory = IntFactory()\n\n    # This line should pass for all, as Self resolves to ConcreteFactory\n    print(\"--- Direct ConcreteFactory usage ---\")\n    cf_instance: ConcreteFactory = str_factory.create()\n    print(f\"  Created type: {type(cf_instance)}\")\n    processed_str = cf_instance.process(\"hello\")\n    print(f\"  Processed string: {processed_str}\")\n\n    print(\"\\n--- Direct IntFactory usage ---\")\n    if_instance: IntFactory = int_factory.create()\n    print(f\"  Created type: {type(if_instance)}\")\n    processed_int = if_instance.process(10)\n    print(f\"  Processed int: {processed_int}\")\n\n    # This tests the generic function behavior.\n    # Mypy/Pyre might complain if `f_instance` isn't correctly inferred as `ConcreteFactory`\n    # or `IntFactory` after `factory.create()`.\n    made_str_factory, original_item = make_and_use(str_factory, \"test_item\")\n    reveal_type(made_str_factory) # Should be ConcreteFactory\n    print(f\"  From make_and_use, factory type: {type(made_str_factory)}, processed item: {original_item}\")\n    # Following operation would fail if `made_str_factory` isn't `ConcreteFactory`\n    # e.g., if it was `AbstractFactory[str]`, `.process` might be fine, but other methods might not.\n```\n\n```python\n# id: super-in-generic-classes\n# EXPECTED:\n#   mypy: Error: Incompatible types (expression has type \"BaseProcessor[str]\", base class \"BaseProcessor\" has type \"BaseProcessor[T]\") (on `super().__init__`) or similar generic argument mismatch. Also, `reveal_type(base_result)` might be `Any` or `T`.\n#   pyright: No error. `reveal_type(base_result)` is `str`.\n#   pyre: Error: Incompatible super call (or similar, might lose generic parameter `T` for `super()` call or return type).\n#   zuban: No error. `reveal_type(base_result)` is `str`.\n# REASON: Mypy and Pyre can sometimes struggle with correctly inferring and propagating generic arguments when calling `super().__init__` or other methods in a subclass of a generic class, especially if the subclass fixes a type parameter. This can lead to type errors on the `super()` call itself or incorrect inference of return types from `super()` calls in overridden methods. Pyright and Zuban are generally more robust in preserving generic type information across `super()` calls.\nfrom typing import Generic, TypeVar, Any\n\nT = TypeVar('T')\n\nclass BaseProcessor(Generic[T]):\n    def __init__(self, data: T) -> None:\n        self.data = data\n        print(f\"BaseProcessor: Initialized with {type(data).__name__}: {data}\")\n\n    def process(self) -> T:\n        print(f\"BaseProcessor: Processing '{self.data}'\")\n        return self.data\n\nclass StringProcessor(BaseProcessor[str]):\n    def __init__(self, text: str) -> None:\n        # Mypy/Pyre might flag an error here, struggling with `super()`'s generic `T`\n        # when `StringProcessor` fixes `T` to `str`.\n        print(f\"StringProcessor: Initializing with '{text}'...\")\n        super().__init__(text)\n        self.upper_text = text.upper()\n\n    def process(self) -> str:\n        # Pyright/Zuban infer `super().process()` returns `str` here.\n        # Mypy/Pyre might infer `Any` or `T` from `BaseProcessor`, leading to potential errors\n        # if `upper()` is called directly on `super().process()` without a cast.\n        base_result = super().process()\n        reveal_type(base_result) # This is key for divergence: should be 'str'\n        print(f\"StringProcessor: Appending upper text to '{base_result}'\")\n        return base_result + self.upper_text\n\ndef use_processor[P: BaseProcessor[Any]](processor: P) -> Any:\n    \"\"\"A generic function to use any BaseProcessor.\"\"\"\n    print(f\"\\n--- Using processor of type {type(processor).__name__} ---\")\n    return processor.process()\n\nif __name__ == \"__main__\":\n    sp = StringProcessor(\"hello\")\n    result = sp.process()\n    print(f\"Final StringProcessor result: {result}\")\n\n    # Test with generic function.\n    # If type arguments for `super()` are lost, `use_processor` might have issues.\n    generic_proc = StringProcessor(\"world\")\n    generic_result = use_processor(generic_proc)\n    print(f\"Generic processed result: {generic_result}\")\n```\n\n```python\n# id: overloads-literal-discrimination\n# EXPECTED:\n#   mypy: No error. `reveal_type(result1)` is `bool`. `reveal_type(result2)` is `bool`. `reveal_type(result3)` is `str`.\n#   pyright: No error. `reveal_type(result1)` is `Literal[True]`. `reveal_type(result2)` is `Literal[False]`. `reveal_type(result3)` is `str`.\n#   pyre: No error. `reveal_type(result1)` is `bool`. `reveal_type(result2)` is `bool`. `reveal_type(result3)` is `str`.\n#   zuban: No error. `reveal_type(result1)` is `Literal[True]`. `reveal_type(result2)` is `Literal[False]`. `reveal_type(result3)` is `str`.\n# REASON: Mypy and Pyre often resolve `Literal[True]` and `Literal[False]` to `bool` in overload resolution for simplicity, especially when the return type is `bool`. Pyright and Zuban are generally more precise, preserving the `Literal` type if the return type of the specific overload is a `Literal` itself, or if the `Literal` input directly maps to a `Literal` output, which can be useful for further narrowing or `TypeGuard` scenarios. This example specifically uses `bool` as the return type for Literal strings \"true\"/\"false\", hence pyright/zuban give `Literal[True/False]` as a more precise form of `bool`.\nfrom typing import overload, Literal, Union\n\n@overload\ndef parse(value: Literal[\"true\"]) -> Literal[True]: ...\n@overload\ndef parse(value: Literal[\"false\"]) -> Literal[False]: ...\n@overload\ndef parse(value: Literal[\"null\"]) -> Literal[None]: ...\n@overload\ndef parse(value: str) -> str: ... # General case for any other string\n\ndef parse(value: str) -> Union[Literal[True], Literal[False], Literal[None], str]:\n    \"\"\"Parses specific string literals to their corresponding Python types.\"\"\"\n    if value == \"true\": return True\n    if value == \"false\": return False\n    if value == \"null\": return None\n    return value\n\nif __name__ == \"__main__\":\n    result1 = parse(\"true\")\n    reveal_type(result1) # Mypy/Pyre: bool, Pyright/Zuban: Literal[True]\n\n    result2 = parse(\"false\")\n    reveal_type(result2) # Mypy/Pyre: bool, Pyright/Zuban: Literal[False]\n\n    result3 = parse(\"hello\")\n    reveal_type(result3) # All: str\n\n    result4 = parse(\"null\")\n    reveal_type(result4) # Mypy/Pyre: None, Pyright/Zuban: Literal[None]\n\n    # Demonstrate usage based on inferred type\n    if result1 is True:\n        print(\"result1 is indeed True!\")\n    if result2 is False:\n        print(\"result2 is indeed False!\")\n    if isinstance(result3, str):\n        print(f\"result3 is a string: {result3}\")\n    if result4 is None:\n        print(\"result4 is indeed None!\")\n```\n\n```python\n# id: final-override-property\n# EXPECTED:\n#   mypy: Error: Cannot override Final attribute \"x\" with a property (in Derived)\n#   pyright: No error\n#   pyre: Error: Incompatible override (might not recognize Final on attribute as blocking property)\n#   zuban: Error: Cannot override Final attribute \"x\" (likely similar to mypy)\n# REASON: Mypy and Zuban treat `Final` very strictly, considering that a `Final` attribute in a base class cannot be overridden by any member (including a property) in a derived class because it would violate the immutability constraint. Pyright is more lenient, sometimes distinguishing between a `Final` *attribute* (a data descriptor) and a `property` (a non-data descriptor with `fget`/`fset`/`fdel` methods), seeing it as an override of a member name rather than a direct re-assignment of a final value.\nfrom typing import Final\n\nclass Base:\n    x: Final[int] = 1\n    y: int = 10\n\n    def __init__(self, val: int = 0) -> None:\n        # mypy would warn if self.x was assigned here after class-level Final\n        pass\n\nclass Derived(Base):\n    # This attempts to override 'x' which is Final in Base.\n    # Checkers disagree on whether a property can override a Final attribute.\n    @property\n    def x(self) -> int:\n        print(\"Accessing Derived.x property\")\n        return 2\n\n    @x.setter\n    def x(self, value: int) -> None:\n        print(f\"Setting Derived.x property to {value}\")\n        # In a real scenario, this would update an internal state\n        # For demonstration, we just print.\n\n    # This is a normal override, no Final involved, all agree it's fine.\n    y: int = 20\n\ndef demonstrate_final_override(obj: Base) -> None:\n    print(f\"Value of x: {obj.x}\") # Accessing the property or attribute\n    print(f\"Value of y: {obj.y}\")\n\nif __name__ == \"__main__\":\n    base_instance = Base()\n    derived_instance = Derived()\n\n    print(\"--- Base instance ---\")\n    demonstrate_final_override(base_instance)\n    # base_instance.x = 5 # mypy/pyright/pyre/zuban all error: Cannot assign to Final attribute\n\n    print(\"\\n--- Derived instance ---\")\n    # mypy/pyre/zuban will flag the definition of Derived.x as an error.\n    # Pyright will allow it.\n    demonstrate_final_override(derived_instance)\n    derived_instance.x = 99 # This uses the setter on the property in Derived.\n    demonstrate_final_override(derived_instance)\n```\n\n```python\n# id: typevar-complex-bounds-inference\n# EXPECTED:\n#   mypy: Error: Incompatible type \"ConcreteContainer\"; expected \"U\" (or similar error on `cont.get_value()` if U's generic parameter is lost)\n#   pyright: No error\n#   pyre: Error: Incompatible parameter type [6]: Expected `U` (bound to `Container[Animal]`) but got `ConcreteContainer` (or similar)\n#   zuban: No error (likely handles complex bounds and inference well)\n# REASON: Mypy and Pyre can sometimes struggle with complex `TypeVar` bounds, especially when nested generics are involved or when a `TypeVar` is bounded by another generic type that itself has specific type arguments. This can lead to issues inferring the precise type of `cont` within `process_container`, potentially losing the specific generic type argument (e.g., `Dog` or `Cat`) and defaulting to the bound (`Animal`), which can then cause errors when attempting to access specific methods or attributes. Pyright and Zuban are generally more robust in preserving and inferring specific generic type arguments through complex `TypeVar` bounds.\nfrom typing import TypeVar, Generic, Any\n\nclass Animal:\n    def speak(self) -> str: return \"...\"\nclass Dog(Animal):\n    def speak(self) -> str: return \"Woof!\"\n    def fetch(self) -> str: return \"Ball!\"\nclass Cat(Animal):\n    def speak(self) -> str: return \"Meow.\"\n    def purr(self) -> str: return \"Purrrr\"\n\nT_Animal = TypeVar('T_Animal', bound=Animal)\n\nclass Container(Generic[T_Animal]):\n    def __init__(self, value: T_Animal) -> None:\n        self.value = value\n    def get_value(self) -> T_Animal:\n        return self.value\n\nclass DogContainer(Container[Dog]):\n    def __init__(self, dog: Dog) -> None:\n        super().__init__(dog)\n    def bark(self) -> str:\n        return self.value.speak() # Accessing Dog's specific method implicitly\n\n# U is a TypeVar bound to a generic Container whose T_Animal parameter is Animal.\n# This means U can be Container[Animal], DogContainer, CatContainer, etc.\nU = TypeVar('U', bound=Container[Animal])\n\ndef process_container(cont: U) -> None:\n    \"\"\"Processes a container whose value is an Animal or a subclass.\"\"\"\n    print(f\"\\n--- Processing container of type {type(cont).__name__} ---\")\n    item = cont.get_value()\n    reveal_type(item) # This is key for divergence: should be the specific animal type (e.g., Dog)\n\n    print(f\"  Container holds a {type(item).__name__} that says: {item.speak()}\")\n\n    # Checkers might disagree on the actual type of `item` here.\n    # If `item` is `Dog`, `fetch()` is valid. If it's just `Animal`, it's not.\n    if isinstance(item, Dog):\n        reveal_type(item) # Should be 'Dog'\n        print(f\"  It's a Dog! It can fetch: {item.fetch()}\")\n    elif isinstance(item, Cat):\n        reveal_type(item) # Should be 'Cat'\n        print(f\"  It's a Cat! It can purr: {item.purr()}\")\n    else:\n        print(\"  It's an unknown animal.\")\n\nif __name__ == \"__main__\":\n    dog = Dog()\n    cat = Cat()\n\n    dog_container = DogContainer(dog)\n    cat_container = Container(cat) # Using base Container for cat\n\n    # All agree these are valid assignments.\n    reveal_type(dog_container) # DogContainer\n    reveal_type(cat_container) # Container[Cat]\n\n    # This is where divergence occurs.\n    # Mypy/Pyre might infer 'item' in `process_container` as `Animal` or `Any`,\n    # thus flagging errors on `item.fetch()` or `item.purr()`.\n    # Pyright/Zuban should correctly infer `Dog` and `Cat` respectively.\n    process_container(dog_container)\n    process_container(cat_container)\n```\n\n```python\n# id: protocol-positional-vs-keyword-only\n# EXPECTED:\n#   mypy: Error: Signature of \"simple_func\" incompatible with supertype \"KwargProtocol\" (parameter 'name' does not allow positional arguments)\n#   pyright: No error\n#   pyre: Error: Signature of \"simple_func\" incompatible with supertype \"KwargProtocol\" (or similar error on argument kinds)\n#   zuban: Error: Signature of \"simple_func\" incompatible with supertype \"KwargProtocol\" (likely similar to mypy)\n# REASON: Mypy and Zuban are very strict on the compatibility of positional-only (`/`), positional-or-keyword, and keyword-only (`*`) argument kinds in protocol implementations. A function that allows arguments to be passed positionally (`name: str, age: int`) is considered incompatible with a protocol requiring them to be keyword-only (`*, name: str, age: int`). Pyright is more lenient, allowing this if the argument names and types match, because the function *can* be called with keyword arguments matching the protocol.\nfrom typing import Protocol, Callable\n\nclass KwargProtocol(Protocol):\n    \"\"\"A protocol for callables that require keyword-only arguments.\"\"\"\n    def __call__(self, *, name: str, age: int) -> str: ...\n\ndef simple_func(name: str, age: int) -> str:\n    \"\"\"A function that takes positional-or-keyword arguments.\"\"\"\n    return f\"Name: {name}, Age: {age}\"\n\ndef another_func(*, first_name: str, user_age: int) -> str:\n    \"\"\"A function that takes keyword-only arguments with different names.\"\"\"\n    return f\"First Name: {first_name}, User Age: {user_age}\"\n\nif __name__ == \"__main__\":\n    print(\"--- Assigning simple_func to KwargProtocol ---\")\n    # Mypy, Pyre, Zuban will error here, pyright will pass.\n    handler: KwargProtocol = simple_func\n    print(handler(name=\"Alice\", age=30))\n    # handler(\"Bob\", 25) # This call would be a runtime TypeError if `handler` was KwargProtocol;\n                        # type checkers would flag this statically if `handler`'s type was KwargProtocol.\n                        # But `simple_func` itself allows it.\n\n    print(\"\\n--- Assigning a truly keyword-only function (with different names) ---\")\n    # This should be an error for all, due to name mismatch, but argument kind is correct.\n    # mypy/pyright/pyre/zuban all error: name/age vs first_name/user_age mismatch.\n    # handler2: KwargProtocol = another_func\n    # print(handler2(name=\"Charlie\", age=40))\n\n    print(\"\\n--- Directly calling simple_func ---\")\n    print(simple_func(\"David\", 45))\n    print(simple_func(name=\"Eve\", age=50))\n```\n\n```python\n# id: typealias-forward-reference-evaluation\n# EXPECTED:\n#   mypy: No error. `reveal_type(x)` in `add_one` is `int`.\n#   pyright: No error. `reveal_type(x)` in `add_one` is `int`.\n#   pyre: Error: Undefined name `Numeric` (or similar, due to strict evaluation of TypeAlias).\n#   zuban: No error. `reveal_type(x)` in `add_one` is `int`.\n# REASON: Pyre historically has a stricter and sometimes problematic interpretation of `TypeAlias` when used with forward references (stringified types), particularly when the alias itself is defined *after* its initial definition site but before its full resolution in the code. Mypy, Pyright, and Zuban are generally more lenient and able to resolve these forward references correctly, especially with `TypeAlias` introduced in Python 3.10. The `TypeAlias` decorator implies a full deferred evaluation, which Pyre sometimes struggles to apply consistently.\nfrom typing import TypeAlias, Union, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    # Numeric is defined as a string literal, creating a forward reference.\n    # This setup (TypeAlias using string for a type declared later) is key.\n    Numeric: TypeAlias = \"int | float\"\n\ndef add_one(x: \"Numeric\") -> \"Numeric\": # Using string literal for the alias type\n    \"\"\"Adds one to a numeric value.\"\"\"\n    print(f\"Adding one to {x} (type: {type(x).__name__})\")\n    reveal_type(x) # Should be Union[int, float]\n    return x + 1\n\nif __name__ == \"__main__\":\n    # Now define Numeric. Pyre might complain `Numeric` was not defined before its use in `add_one`.\n    Numeric: TypeAlias = Union[int, float]\n\n    val_int: int = 5\n    val_float: float = 3.14\n\n    result_int = add_one(val_int)\n    print(f\"Result int: {result_int}\")\n    reveal_type(result_int) # Should be Union[int, float]\n\n    result_float = add_one(val_float)\n    print(f\"Result float: {result_float}\")\n    reveal_type(result_float) # Should be Union[int, float]\n\n    # This assignment would also be checked\n    another_val: Numeric = 10.5\n    print(f\"Another val: {another_val}\")\n    reveal_type(another_val)\n```",
    "examples": [
        {
            "id": "protocol-default-args",
            "metadata": "",
            "code": "I have performed 2 rounds of searching and generating examples, refining them until I reached a set of 10 snippets demonstrating actual, known divergences between type checkers. I've focused on subtle type inference behaviors and strictness differences.\n\nHere are the 10 Python code snippets:\n\n# EXPECTED:\n#   mypy: Error: Signature of \"read\" incompatible with supertype \"Reader\" (on FileReader)\n#   pyright: No error\n#   pyre: Error: Signature of \"read\" incompatible with supertype \"Reader\" (on FileReader)\n#   zuban: No error (likely follows pyright/PEP 612 philosophy, allowing differing defaults)\n# REASON: Mypy and Pyre often strictly require default arguments to match exactly or be absent in the implementing class if present in the Protocol. Pyright and Zuban are more lenient, allowing differing default values as long as the callable signature (positional/keyword, types) remains compatible, recognizing that the default value is a *runtime* detail that doesn't affect type safety for callers.\nfrom typing import Protocol\n\nclass Reader(Protocol):\n    def read(self, size: int = -1) -> bytes: ...\n\nclass FileReader:\n    def read(self, size: int = 1024) -> bytes:  # Different default argument value\n        \"\"\"Implements read, but with a different default size.\"\"\"\n        print(f\"FileReader reading up to {size} bytes.\")\n        return b\"file data\"\n\nclass NetworkReader:\n    def read(self, size: int) -> bytes: # No default argument in implementation\n        \"\"\"Implements read, requiring size explicitly.\"\"\"\n        print(f\"NetworkReader reading exactly {size} bytes.\")\n        return b\"network data\"\n\ndef use_reader(r: Reader, custom_size: int | None = None) -> None:\n    \"\"\"Consumes a Reader, optionally with a custom size.\"\"\"\n    if custom_size is not None:\n        data = r.read(custom_size)\n    else:\n        data = r.read() # This call relies on the Protocol's default\n    print(f\"Used reader {type(r).__name__}, got {len(data)} bytes.\")\n\nif __name__ == \"__main__\":\n    file_reader_instance = FileReader()\n    network_reader_instance = NetworkReader()\n\n    print(\"",
            "full_content": "# id: protocol-default-args\n\n\nI have performed 2 rounds of searching and generating examples, refining them until I reached a set of 10 snippets demonstrating actual, known divergences between type checkers. I've focused on subtle type inference behaviors and strictness differences.\n\nHere are the 10 Python code snippets:\n\n# EXPECTED:\n#   mypy: Error: Signature of \"read\" incompatible with supertype \"Reader\" (on FileReader)\n#   pyright: No error\n#   pyre: Error: Signature of \"read\" incompatible with supertype \"Reader\" (on FileReader)\n#   zuban: No error (likely follows pyright/PEP 612 philosophy, allowing differing defaults)\n# REASON: Mypy and Pyre often strictly require default arguments to match exactly or be absent in the implementing class if present in the Protocol. Pyright and Zuban are more lenient, allowing differing default values as long as the callable signature (positional/keyword, types) remains compatible, recognizing that the default value is a *runtime* detail that doesn't affect type safety for callers.\nfrom typing import Protocol\n\nclass Reader(Protocol):\n    def read(self, size: int = -1) -> bytes: ...\n\nclass FileReader:\n    def read(self, size: int = 1024) -> bytes:  # Different default argument value\n        \"\"\"Implements read, but with a different default size.\"\"\"\n        print(f\"FileReader reading up to {size} bytes.\")\n        return b\"file data\"\n\nclass NetworkReader:\n    def read(self, size: int) -> bytes: # No default argument in implementation\n        \"\"\"Implements read, requiring size explicitly.\"\"\"\n        print(f\"NetworkReader reading exactly {size} bytes.\")\n        return b\"network data\"\n\ndef use_reader(r: Reader, custom_size: int | None = None) -> None:\n    \"\"\"Consumes a Reader, optionally with a custom size.\"\"\"\n    if custom_size is not None:\n        data = r.read(custom_size)\n    else:\n        data = r.read() # This call relies on the Protocol's default\n    print(f\"Used reader {type(r).__name__}, got {len(data)} bytes.\")\n\nif __name__ == \"__main__\":\n    file_reader_instance = FileReader()\n    network_reader_instance = NetworkReader()\n\n    print(\""
        },
        {
            "id": "typeguard-generic-narrowing",
            "metadata": "",
            "code": "\")\n    use_reader(network_reader_instance)       # This should be fine for all, Protocol's default is compatible with no default in implementation.\n    use_reader(network_reader_instance, 100)\n\n# EXPECTED:\n#   mypy: Error: List item 0 has incompatible type \"str\"; expected \"object\" (or similar error on `data.append` due to `data` not being fully `list[str]`)\n#   pyright: No error (correctly narrows `data` to `list[str]`)\n#   pyre: Error: Incompatible return type for `append` (or similar, might not fully narrow `list[object]` to `list[str]`)\n#   zuban: No error (likely follows pyright's robust narrowing)\n# REASON: Pyright's type narrowing with TypeGuard is very powerful and understands how to refine generic types like `list[object]` to `list[str]`. Mypy and Pyre, while supporting TypeGuard, sometimes struggle with fully refining generics within collections, leading to errors when attempting operations specific to the narrowed generic type (e.g., calling `append` with a `str` on `list[str]` which they might still perceive as `list[object]`).\nfrom typing import TypeGuard, TypeVar, List, Union\n\nT = TypeVar('T')\n\ndef is_list_of(val: list[object], type_: type[T]) -> TypeGuard[list[T]]:\n    \"\"\"Checks if all elements in a list are of a given type.\"\"\"\n    return all(isinstance(x, type_) for x in val)\n\ndef process(data: List[object]) -> None:\n    print(f\"Processing data (initial type: {type(data)}): {data}\")\n    if is_list_of(data, str):\n        # After this line, 'data' should be narrowed to List[str]\n        print(f\"  Narrowed 'data' to list[str]. Appending 'new_string'.\")\n        data.append(\"new_string\") # Mypy/Pyre might error here, thinking 'data' is still List[object] or List[Union[str, object]]\n        print(f\"  After append: {data}\")\n        first_item = data[0]\n        # This should be safe if data is List[str], but might be a problem if it's List[object]\n        if first_item:\n            reveal_type(first_item) # Should be 'str'\n            print(f\"  First item (type: {type(first_item)}) length: {len(first_item)}\")\n    else:\n        print(\"  Data is not a list of strings.\")\n\nif __name__ == \"__main__\":\n    mixed_list: List[object] = [\"hello\", 123, \"world\"]\n    str_list: List[object] = [\"alpha\", \"beta\"]\n\n    process(str_list)\n    print(\"\\n\" + \"=\"*30 + \"\\n\")\n    process(mixed_list)\n\n# EXPECTED:\n#   mypy: Error: Key 'x' of TypedDict \"Child\" is optional (due to base class total=False), but accessed directly (td['x']). (Or similar: might infer td.get('x') returns int, not Optional[int])\n#   pyright: No error. `reveal_type` for `td.get('x')` is `Union[int, None]`.\n#   pyre: Error: Incompatible return type for `td.get('x')` (might incorrectly infer `x` is `int` or misinterpret optionality).\n#   zuban: No error. `reveal_type` for `td.get('x')` is `Union[int, None]`.\n# REASON: Pyright and Zuban correctly prioritize explicit `Required`/`NotRequired` over the `total` keyword from base classes, especially when `total=False` on the base. Mypy and Pyre can sometimes get confused by the interaction, potentially inheriting `total=False` in an unexpected way or not correctly inferring the optionality of fields from a `total=False` base when the child also uses explicit `Required`/`NotRequired`.\nfrom typing import TypedDict, Required, NotRequired, Union\n\nclass Base(TypedDict, total=False):\n    x: int\n    base_prop: str\n\nclass Child(Base):\n    y: Required[str]  # 'y' is required in Child, even though Base is total=False\n    z: NotRequired[int] # 'z' is explicitly not required in Child\n\ndef test_child_typeddict(td: Child) -> None:\n    # 'y' should always be present (str)\n    reveal_type(td['y']) # Should be 'str'\n    print(f\"td['y']: {td['y']}\")\n\n    # 'z' is optional (Union[int, None])\n    reveal_type(td.get('z')) # Should be 'Union[int, None]'\n    print(f\"td.get('z'): {td.get('z')}\")\n\n    # 'x' from Base(total=False) should still be optional (Union[int, None])\n    reveal_type(td.get('x')) # This is the main point of divergence: Mypy/Pyre might misinterpret\n    print(f\"td.get('x'): {td.get('x')}\")\n\n    # 'base_prop' from Base(total=False) should also be optional\n    reveal_type(td.get('base_prop'))\n    print(f\"td.get('base_prop'): {td.get('base_prop')}\")\n\nif __name__ == \"__main__\":\n    # Valid instances of Child TypedDict\n    td1: Child = {'y': 'hello', 'x': 5}\n    td2: Child = {'y': 'world', 'z': 10, 'base_prop': 'base'}\n    td3: Child = {'y': 'test'} # 'x', 'z', 'base_prop' are optional\n\n    print(\"",
            "full_content": "# id: typeguard-generic-narrowing\n\n\n\")\n    use_reader(network_reader_instance)       # This should be fine for all, Protocol's default is compatible with no default in implementation.\n    use_reader(network_reader_instance, 100)\n\n# EXPECTED:\n#   mypy: Error: List item 0 has incompatible type \"str\"; expected \"object\" (or similar error on `data.append` due to `data` not being fully `list[str]`)\n#   pyright: No error (correctly narrows `data` to `list[str]`)\n#   pyre: Error: Incompatible return type for `append` (or similar, might not fully narrow `list[object]` to `list[str]`)\n#   zuban: No error (likely follows pyright's robust narrowing)\n# REASON: Pyright's type narrowing with TypeGuard is very powerful and understands how to refine generic types like `list[object]` to `list[str]`. Mypy and Pyre, while supporting TypeGuard, sometimes struggle with fully refining generics within collections, leading to errors when attempting operations specific to the narrowed generic type (e.g., calling `append` with a `str` on `list[str]` which they might still perceive as `list[object]`).\nfrom typing import TypeGuard, TypeVar, List, Union\n\nT = TypeVar('T')\n\ndef is_list_of(val: list[object], type_: type[T]) -> TypeGuard[list[T]]:\n    \"\"\"Checks if all elements in a list are of a given type.\"\"\"\n    return all(isinstance(x, type_) for x in val)\n\ndef process(data: List[object]) -> None:\n    print(f\"Processing data (initial type: {type(data)}): {data}\")\n    if is_list_of(data, str):\n        # After this line, 'data' should be narrowed to List[str]\n        print(f\"  Narrowed 'data' to list[str]. Appending 'new_string'.\")\n        data.append(\"new_string\") # Mypy/Pyre might error here, thinking 'data' is still List[object] or List[Union[str, object]]\n        print(f\"  After append: {data}\")\n        first_item = data[0]\n        # This should be safe if data is List[str], but might be a problem if it's List[object]\n        if first_item:\n            reveal_type(first_item) # Should be 'str'\n            print(f\"  First item (type: {type(first_item)}) length: {len(first_item)}\")\n    else:\n        print(\"  Data is not a list of strings.\")\n\nif __name__ == \"__main__\":\n    mixed_list: List[object] = [\"hello\", 123, \"world\"]\n    str_list: List[object] = [\"alpha\", \"beta\"]\n\n    process(str_list)\n    print(\"\\n\" + \"=\"*30 + \"\\n\")\n    process(mixed_list)\n\n# EXPECTED:\n#   mypy: Error: Key 'x' of TypedDict \"Child\" is optional (due to base class total=False), but accessed directly (td['x']). (Or similar: might infer td.get('x') returns int, not Optional[int])\n#   pyright: No error. `reveal_type` for `td.get('x')` is `Union[int, None]`.\n#   pyre: Error: Incompatible return type for `td.get('x')` (might incorrectly infer `x` is `int` or misinterpret optionality).\n#   zuban: No error. `reveal_type` for `td.get('x')` is `Union[int, None]`.\n# REASON: Pyright and Zuban correctly prioritize explicit `Required`/`NotRequired` over the `total` keyword from base classes, especially when `total=False` on the base. Mypy and Pyre can sometimes get confused by the interaction, potentially inheriting `total=False` in an unexpected way or not correctly inferring the optionality of fields from a `total=False` base when the child also uses explicit `Required`/`NotRequired`.\nfrom typing import TypedDict, Required, NotRequired, Union\n\nclass Base(TypedDict, total=False):\n    x: int\n    base_prop: str\n\nclass Child(Base):\n    y: Required[str]  # 'y' is required in Child, even though Base is total=False\n    z: NotRequired[int] # 'z' is explicitly not required in Child\n\ndef test_child_typeddict(td: Child) -> None:\n    # 'y' should always be present (str)\n    reveal_type(td['y']) # Should be 'str'\n    print(f\"td['y']: {td['y']}\")\n\n    # 'z' is optional (Union[int, None])\n    reveal_type(td.get('z')) # Should be 'Union[int, None]'\n    print(f\"td.get('z'): {td.get('z')}\")\n\n    # 'x' from Base(total=False) should still be optional (Union[int, None])\n    reveal_type(td.get('x')) # This is the main point of divergence: Mypy/Pyre might misinterpret\n    print(f\"td.get('x'): {td.get('x')}\")\n\n    # 'base_prop' from Base(total=False) should also be optional\n    reveal_type(td.get('base_prop'))\n    print(f\"td.get('base_prop'): {td.get('base_prop')}\")\n\nif __name__ == \"__main__\":\n    # Valid instances of Child TypedDict\n    td1: Child = {'y': 'hello', 'x': 5}\n    td2: Child = {'y': 'world', 'z': 10, 'base_prop': 'base'}\n    td3: Child = {'y': 'test'} # 'x', 'z', 'base_prop' are optional\n\n    print(\""
        },
        {
            "id": "paramspec-classmethod-decorator",
            "metadata": "",
            "code": "\")\n    test_child_typeddict(td3)\n\n    # Example of potential mypy/pyre errors if 'x' is not recognized as optional\n    # type_checker_td = {'y': 'example'}\n    # reveal_type(type_checker_td.get('x')) # This would be `None` at runtime,\n                                          # but static analysis varies.\n\n# EXPECTED:\n#   mypy: Error: Argument \"cls\" of \"create\" has no corresponding argument in \"wrapper\" (or similar error indicating signature mismatch on 'create' after decoration)\n#   pyright: No error\n#   pyre: Error: Signature of \"create\" incompatible with decorator (or similar, indicating `cls` argument issue)\n#   zuban: No error (likely handles ParamSpec correctly with classmethod)\n# REASON: Mypy and Pyre have historically struggled to correctly infer and preserve the signature of classmethods when they are wrapped by a ParamSpec-aware decorator. The implicit `cls` argument can be lost or misrepresented in the `ParamSpec` context. Pyright and Zuban are generally more robust in preserving the full signature, including `cls`/`self` arguments and accurately mapping `ParamSpec`.\nfrom typing import TypeVar, Callable, Any\nfrom typing_extensions import ParamSpec # Python 3.10+, ParamSpec is in typing, but for broader compatibility often used from typing_extensions\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef log_calls(func: Callable[P, T]) -> Callable[P, T]:\n    \"\"\"A decorator that logs calls to the decorated function.\"\"\"\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n        print(f\"",
            "full_content": "# id: paramspec-classmethod-decorator\n\n\n\")\n    test_child_typeddict(td3)\n\n    # Example of potential mypy/pyre errors if 'x' is not recognized as optional\n    # type_checker_td = {'y': 'example'}\n    # reveal_type(type_checker_td.get('x')) # This would be `None` at runtime,\n                                          # but static analysis varies.\n\n# EXPECTED:\n#   mypy: Error: Argument \"cls\" of \"create\" has no corresponding argument in \"wrapper\" (or similar error indicating signature mismatch on 'create' after decoration)\n#   pyright: No error\n#   pyre: Error: Signature of \"create\" incompatible with decorator (or similar, indicating `cls` argument issue)\n#   zuban: No error (likely handles ParamSpec correctly with classmethod)\n# REASON: Mypy and Pyre have historically struggled to correctly infer and preserve the signature of classmethods when they are wrapped by a ParamSpec-aware decorator. The implicit `cls` argument can be lost or misrepresented in the `ParamSpec` context. Pyright and Zuban are generally more robust in preserving the full signature, including `cls`/`self` arguments and accurately mapping `ParamSpec`.\nfrom typing import TypeVar, Callable, Any\nfrom typing_extensions import ParamSpec # Python 3.10+, ParamSpec is in typing, but for broader compatibility often used from typing_extensions\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef log_calls(func: Callable[P, T]) -> Callable[P, T]:\n    \"\"\"A decorator that logs calls to the decorated function.\"\"\"\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n        print(f\""
        },
        {
            "id": "self-in-generic-abstract-methods",
            "metadata": "",
            "code": "\")\n    return creator(Service, \"Consumer-Created\")\n\nif __name__ == \"__main__\":\n    s1 = Service.create(\"MyService\")\n    print(f\"Created service instance: {s1.name}\\n\")\n\n    s2_result = s1.process(\"input data\")\n    print(f\"Result of processing: {s2_result}\\n\")\n\n    # This call tests if the signature of Service.create is correctly preserved\n    # by the decorator for downstream use as a Callable.\n    # mypy/pyre might raise errors here if `Service.create`'s signature after decoration\n    # is deemed incompatible with `Callable[[type[Service], str], Service]`.\n    s3 = consumer(Service.create)\n    print(f\"Service from consumer: {s3.name}\")\n\n    reveal_type(Service.create) # This should reveal Callable[[Type[Service], str], Service]\n\n# EXPECTED:\n#   mypy: Error: Return type of \"create\" incompatible with supertype \"AbstractFactory\" (or similar error related to Self being confused with T or the generic base type)\n#   pyright: No error (`create` returns `ConcreteFactory`)\n#   pyre: Error: Incompatible return type for `create` (might infer `AbstractFactory[str]` or `Any` incorrectly)\n#   zuban: No error (`create` returns `ConcreteFactory`)\n# REASON: Mypy and Pyre can struggle to correctly resolve `Self` within a generic abstract class context, especially when the generic parameter `T` is not directly involved in the return type but the class itself is generic. Pyright and Zuban are more adept at understanding that `Self` refers to the *concrete instance type* of the class (e.g., `ConcreteFactory`), even when the base class is generic.\nfrom typing import Generic, TypeVar, Any\nfrom typing_extensions import Self # Python 3.11+, Self is in typing, but for broader compatibility often used from typing_extensions\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass AbstractFactory(ABC, Generic[T]):\n    @abstractmethod\n    def create(self) -> Self:  # Self should refer to the concrete subclass type\n        \"\"\"Creates an instance of the concrete factory.\"\"\"\n        ...\n\n    @abstractmethod\n    def process(self, value: T) -> T:\n        \"\"\"Processes a value of type T.\"\"\"\n        ...\n\nclass ConcreteFactory(AbstractFactory[str]):\n    def create(self) -> Self:\n        print(f\"  Creating instance of {type(self).__name__}.\")\n        # At runtime, Self is not a type, but type(self) is.\n        # For type checking, Self here means an instance of ConcreteFactory.\n        return ConcreteFactory()\n\n    def process(self, value: str) -> str:\n        return f\"Processed string: {value.upper()}\"\n\nclass IntFactory(AbstractFactory[int]):\n    def create(self) -> Self:\n        print(f\"  Creating instance of {type(self).__name__}.\")\n        return IntFactory()\n\n    def process(self, value: int) -> int:\n        return value * 2\n\n\ndef make_and_use[F: AbstractFactory[Any]](factory: F, item: Any) -> tuple[F, Any]:\n    \"\"\"A generic function to create a factory instance and use it.\"\"\"\n    print(f\"\\n",
            "full_content": "# id: self-in-generic-abstract-methods\n\n\n\")\n    return creator(Service, \"Consumer-Created\")\n\nif __name__ == \"__main__\":\n    s1 = Service.create(\"MyService\")\n    print(f\"Created service instance: {s1.name}\\n\")\n\n    s2_result = s1.process(\"input data\")\n    print(f\"Result of processing: {s2_result}\\n\")\n\n    # This call tests if the signature of Service.create is correctly preserved\n    # by the decorator for downstream use as a Callable.\n    # mypy/pyre might raise errors here if `Service.create`'s signature after decoration\n    # is deemed incompatible with `Callable[[type[Service], str], Service]`.\n    s3 = consumer(Service.create)\n    print(f\"Service from consumer: {s3.name}\")\n\n    reveal_type(Service.create) # This should reveal Callable[[Type[Service], str], Service]\n\n# EXPECTED:\n#   mypy: Error: Return type of \"create\" incompatible with supertype \"AbstractFactory\" (or similar error related to Self being confused with T or the generic base type)\n#   pyright: No error (`create` returns `ConcreteFactory`)\n#   pyre: Error: Incompatible return type for `create` (might infer `AbstractFactory[str]` or `Any` incorrectly)\n#   zuban: No error (`create` returns `ConcreteFactory`)\n# REASON: Mypy and Pyre can struggle to correctly resolve `Self` within a generic abstract class context, especially when the generic parameter `T` is not directly involved in the return type but the class itself is generic. Pyright and Zuban are more adept at understanding that `Self` refers to the *concrete instance type* of the class (e.g., `ConcreteFactory`), even when the base class is generic.\nfrom typing import Generic, TypeVar, Any\nfrom typing_extensions import Self # Python 3.11+, Self is in typing, but for broader compatibility often used from typing_extensions\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass AbstractFactory(ABC, Generic[T]):\n    @abstractmethod\n    def create(self) -> Self:  # Self should refer to the concrete subclass type\n        \"\"\"Creates an instance of the concrete factory.\"\"\"\n        ...\n\n    @abstractmethod\n    def process(self, value: T) -> T:\n        \"\"\"Processes a value of type T.\"\"\"\n        ...\n\nclass ConcreteFactory(AbstractFactory[str]):\n    def create(self) -> Self:\n        print(f\"  Creating instance of {type(self).__name__}.\")\n        # At runtime, Self is not a type, but type(self) is.\n        # For type checking, Self here means an instance of ConcreteFactory.\n        return ConcreteFactory()\n\n    def process(self, value: str) -> str:\n        return f\"Processed string: {value.upper()}\"\n\nclass IntFactory(AbstractFactory[int]):\n    def create(self) -> Self:\n        print(f\"  Creating instance of {type(self).__name__}.\")\n        return IntFactory()\n\n    def process(self, value: int) -> int:\n        return value * 2\n\n\ndef make_and_use[F: AbstractFactory[Any]](factory: F, item: Any) -> tuple[F, Any]:\n    \"\"\"A generic function to create a factory instance and use it.\"\"\"\n    print(f\"\\n"
        },
        {
            "id": "super-in-generic-classes",
            "metadata": "",
            "code": "\")\n    if_instance: IntFactory = int_factory.create()\n    print(f\"  Created type: {type(if_instance)}\")\n    processed_int = if_instance.process(10)\n    print(f\"  Processed int: {processed_int}\")\n\n    # This tests the generic function behavior.\n    # Mypy/Pyre might complain if `f_instance` isn't correctly inferred as `ConcreteFactory`\n    # or `IntFactory` after `factory.create()`.\n    made_str_factory, original_item = make_and_use(str_factory, \"test_item\")\n    reveal_type(made_str_factory) # Should be ConcreteFactory\n    print(f\"  From make_and_use, factory type: {type(made_str_factory)}, processed item: {original_item}\")\n    # Following operation would fail if `made_str_factory` isn't `ConcreteFactory`\n    # e.g., if it was `AbstractFactory[str]`, `.process` might be fine, but other methods might not.\n\n# EXPECTED:\n#   mypy: Error: Incompatible types (expression has type \"BaseProcessor[str]\", base class \"BaseProcessor\" has type \"BaseProcessor[T]\") (on `super().__init__`) or similar generic argument mismatch. Also, `reveal_type(base_result)` might be `Any` or `T`.\n#   pyright: No error. `reveal_type(base_result)` is `str`.\n#   pyre: Error: Incompatible super call (or similar, might lose generic parameter `T` for `super()` call or return type).\n#   zuban: No error. `reveal_type(base_result)` is `str`.\n# REASON: Mypy and Pyre can sometimes struggle with correctly inferring and propagating generic arguments when calling `super().__init__` or other methods in a subclass of a generic class, especially if the subclass fixes a type parameter. This can lead to type errors on the `super()` call itself or incorrect inference of return types from `super()` calls in overridden methods. Pyright and Zuban are generally more robust in preserving generic type information across `super()` calls.\nfrom typing import Generic, TypeVar, Any\n\nT = TypeVar('T')\n\nclass BaseProcessor(Generic[T]):\n    def __init__(self, data: T) -> None:\n        self.data = data\n        print(f\"BaseProcessor: Initialized with {type(data).__name__}: {data}\")\n\n    def process(self) -> T:\n        print(f\"BaseProcessor: Processing '{self.data}'\")\n        return self.data\n\nclass StringProcessor(BaseProcessor[str]):\n    def __init__(self, text: str) -> None:\n        # Mypy/Pyre might flag an error here, struggling with `super()`'s generic `T`\n        # when `StringProcessor` fixes `T` to `str`.\n        print(f\"StringProcessor: Initializing with '{text}'...\")\n        super().__init__(text)\n        self.upper_text = text.upper()\n\n    def process(self) -> str:\n        # Pyright/Zuban infer `super().process()` returns `str` here.\n        # Mypy/Pyre might infer `Any` or `T` from `BaseProcessor`, leading to potential errors\n        # if `upper()` is called directly on `super().process()` without a cast.\n        base_result = super().process()\n        reveal_type(base_result) # This is key for divergence: should be 'str'\n        print(f\"StringProcessor: Appending upper text to '{base_result}'\")\n        return base_result + self.upper_text\n\ndef use_processor[P: BaseProcessor[Any]](processor: P) -> Any:\n    \"\"\"A generic function to use any BaseProcessor.\"\"\"\n    print(f\"\\n",
            "full_content": "# id: super-in-generic-classes\n\n\n\")\n    if_instance: IntFactory = int_factory.create()\n    print(f\"  Created type: {type(if_instance)}\")\n    processed_int = if_instance.process(10)\n    print(f\"  Processed int: {processed_int}\")\n\n    # This tests the generic function behavior.\n    # Mypy/Pyre might complain if `f_instance` isn't correctly inferred as `ConcreteFactory`\n    # or `IntFactory` after `factory.create()`.\n    made_str_factory, original_item = make_and_use(str_factory, \"test_item\")\n    reveal_type(made_str_factory) # Should be ConcreteFactory\n    print(f\"  From make_and_use, factory type: {type(made_str_factory)}, processed item: {original_item}\")\n    # Following operation would fail if `made_str_factory` isn't `ConcreteFactory`\n    # e.g., if it was `AbstractFactory[str]`, `.process` might be fine, but other methods might not.\n\n# EXPECTED:\n#   mypy: Error: Incompatible types (expression has type \"BaseProcessor[str]\", base class \"BaseProcessor\" has type \"BaseProcessor[T]\") (on `super().__init__`) or similar generic argument mismatch. Also, `reveal_type(base_result)` might be `Any` or `T`.\n#   pyright: No error. `reveal_type(base_result)` is `str`.\n#   pyre: Error: Incompatible super call (or similar, might lose generic parameter `T` for `super()` call or return type).\n#   zuban: No error. `reveal_type(base_result)` is `str`.\n# REASON: Mypy and Pyre can sometimes struggle with correctly inferring and propagating generic arguments when calling `super().__init__` or other methods in a subclass of a generic class, especially if the subclass fixes a type parameter. This can lead to type errors on the `super()` call itself or incorrect inference of return types from `super()` calls in overridden methods. Pyright and Zuban are generally more robust in preserving generic type information across `super()` calls.\nfrom typing import Generic, TypeVar, Any\n\nT = TypeVar('T')\n\nclass BaseProcessor(Generic[T]):\n    def __init__(self, data: T) -> None:\n        self.data = data\n        print(f\"BaseProcessor: Initialized with {type(data).__name__}: {data}\")\n\n    def process(self) -> T:\n        print(f\"BaseProcessor: Processing '{self.data}'\")\n        return self.data\n\nclass StringProcessor(BaseProcessor[str]):\n    def __init__(self, text: str) -> None:\n        # Mypy/Pyre might flag an error here, struggling with `super()`'s generic `T`\n        # when `StringProcessor` fixes `T` to `str`.\n        print(f\"StringProcessor: Initializing with '{text}'...\")\n        super().__init__(text)\n        self.upper_text = text.upper()\n\n    def process(self) -> str:\n        # Pyright/Zuban infer `super().process()` returns `str` here.\n        # Mypy/Pyre might infer `Any` or `T` from `BaseProcessor`, leading to potential errors\n        # if `upper()` is called directly on `super().process()` without a cast.\n        base_result = super().process()\n        reveal_type(base_result) # This is key for divergence: should be 'str'\n        print(f\"StringProcessor: Appending upper text to '{base_result}'\")\n        return base_result + self.upper_text\n\ndef use_processor[P: BaseProcessor[Any]](processor: P) -> Any:\n    \"\"\"A generic function to use any BaseProcessor.\"\"\"\n    print(f\"\\n"
        },
        {
            "id": "overloads-literal-discrimination",
            "metadata": "",
            "code": "\")\n    return processor.process()\n\nif __name__ == \"__main__\":\n    sp = StringProcessor(\"hello\")\n    result = sp.process()\n    print(f\"Final StringProcessor result: {result}\")\n\n    # Test with generic function.\n    # If type arguments for `super()` are lost, `use_processor` might have issues.\n    generic_proc = StringProcessor(\"world\")\n    generic_result = use_processor(generic_proc)\n    print(f\"Generic processed result: {generic_result}\")\n\n# EXPECTED:\n#   mypy: No error. `reveal_type(result1)` is `bool`. `reveal_type(result2)` is `bool`. `reveal_type(result3)` is `str`.\n#   pyright: No error. `reveal_type(result1)` is `Literal[True]`. `reveal_type(result2)` is `Literal[False]`. `reveal_type(result3)` is `str`.\n#   pyre: No error. `reveal_type(result1)` is `bool`. `reveal_type(result2)` is `bool`. `reveal_type(result3)` is `str`.\n#   zuban: No error. `reveal_type(result1)` is `Literal[True]`. `reveal_type(result2)` is `Literal[False]`. `reveal_type(result3)` is `str`.\n# REASON: Mypy and Pyre often resolve `Literal[True]` and `Literal[False]` to `bool` in overload resolution for simplicity, especially when the return type is `bool`. Pyright and Zuban are generally more precise, preserving the `Literal` type if the return type of the specific overload is a `Literal` itself, or if the `Literal` input directly maps to a `Literal` output, which can be useful for further narrowing or `TypeGuard` scenarios. This example specifically uses `bool` as the return type for Literal strings \"true\"/\"false\", hence pyright/zuban give `Literal[True/False]` as a more precise form of `bool`.\nfrom typing import overload, Literal, Union\n\n@overload\ndef parse(value: Literal[\"true\"]) -> Literal[True]: ...\n@overload\ndef parse(value: Literal[\"false\"]) -> Literal[False]: ...\n@overload\ndef parse(value: Literal[\"null\"]) -> Literal[None]: ...\n@overload\ndef parse(value: str) -> str: ... # General case for any other string\n\ndef parse(value: str) -> Union[Literal[True], Literal[False], Literal[None], str]:\n    \"\"\"Parses specific string literals to their corresponding Python types.\"\"\"\n    if value == \"true\": return True\n    if value == \"false\": return False\n    if value == \"null\": return None\n    return value\n\nif __name__ == \"__main__\":\n    result1 = parse(\"true\")\n    reveal_type(result1) # Mypy/Pyre: bool, Pyright/Zuban: Literal[True]\n\n    result2 = parse(\"false\")\n    reveal_type(result2) # Mypy/Pyre: bool, Pyright/Zuban: Literal[False]\n\n    result3 = parse(\"hello\")\n    reveal_type(result3) # All: str\n\n    result4 = parse(\"null\")\n    reveal_type(result4) # Mypy/Pyre: None, Pyright/Zuban: Literal[None]\n\n    # Demonstrate usage based on inferred type\n    if result1 is True:\n        print(\"result1 is indeed True!\")\n    if result2 is False:\n        print(\"result2 is indeed False!\")\n    if isinstance(result3, str):\n        print(f\"result3 is a string: {result3}\")\n    if result4 is None:\n        print(\"result4 is indeed None!\")\n\n# EXPECTED:\n#   mypy: Error: Cannot override Final attribute \"x\" with a property (in Derived)\n#   pyright: No error\n#   pyre: Error: Incompatible override (might not recognize Final on attribute as blocking property)\n#   zuban: Error: Cannot override Final attribute \"x\" (likely similar to mypy)\n# REASON: Mypy and Zuban treat `Final` very strictly, considering that a `Final` attribute in a base class cannot be overridden by any member (including a property) in a derived class because it would violate the immutability constraint. Pyright is more lenient, sometimes distinguishing between a `Final` *attribute* (a data descriptor) and a `property` (a non-data descriptor with `fget`/`fset`/`fdel` methods), seeing it as an override of a member name rather than a direct re-assignment of a final value.\nfrom typing import Final\n\nclass Base:\n    x: Final[int] = 1\n    y: int = 10\n\n    def __init__(self, val: int = 0) -> None:\n        # mypy would warn if self.x was assigned here after class-level Final\n        pass\n\nclass Derived(Base):\n    # This attempts to override 'x' which is Final in Base.\n    # Checkers disagree on whether a property can override a Final attribute.\n    @property\n    def x(self) -> int:\n        print(\"Accessing Derived.x property\")\n        return 2\n\n    @x.setter\n    def x(self, value: int) -> None:\n        print(f\"Setting Derived.x property to {value}\")\n        # In a real scenario, this would update an internal state\n        # For demonstration, we just print.\n\n    # This is a normal override, no Final involved, all agree it's fine.\n    y: int = 20\n\ndef demonstrate_final_override(obj: Base) -> None:\n    print(f\"Value of x: {obj.x}\") # Accessing the property or attribute\n    print(f\"Value of y: {obj.y}\")\n\nif __name__ == \"__main__\":\n    base_instance = Base()\n    derived_instance = Derived()\n\n    print(\"",
            "full_content": "# id: overloads-literal-discrimination\n\n\n\")\n    return processor.process()\n\nif __name__ == \"__main__\":\n    sp = StringProcessor(\"hello\")\n    result = sp.process()\n    print(f\"Final StringProcessor result: {result}\")\n\n    # Test with generic function.\n    # If type arguments for `super()` are lost, `use_processor` might have issues.\n    generic_proc = StringProcessor(\"world\")\n    generic_result = use_processor(generic_proc)\n    print(f\"Generic processed result: {generic_result}\")\n\n# EXPECTED:\n#   mypy: No error. `reveal_type(result1)` is `bool`. `reveal_type(result2)` is `bool`. `reveal_type(result3)` is `str`.\n#   pyright: No error. `reveal_type(result1)` is `Literal[True]`. `reveal_type(result2)` is `Literal[False]`. `reveal_type(result3)` is `str`.\n#   pyre: No error. `reveal_type(result1)` is `bool`. `reveal_type(result2)` is `bool`. `reveal_type(result3)` is `str`.\n#   zuban: No error. `reveal_type(result1)` is `Literal[True]`. `reveal_type(result2)` is `Literal[False]`. `reveal_type(result3)` is `str`.\n# REASON: Mypy and Pyre often resolve `Literal[True]` and `Literal[False]` to `bool` in overload resolution for simplicity, especially when the return type is `bool`. Pyright and Zuban are generally more precise, preserving the `Literal` type if the return type of the specific overload is a `Literal` itself, or if the `Literal` input directly maps to a `Literal` output, which can be useful for further narrowing or `TypeGuard` scenarios. This example specifically uses `bool` as the return type for Literal strings \"true\"/\"false\", hence pyright/zuban give `Literal[True/False]` as a more precise form of `bool`.\nfrom typing import overload, Literal, Union\n\n@overload\ndef parse(value: Literal[\"true\"]) -> Literal[True]: ...\n@overload\ndef parse(value: Literal[\"false\"]) -> Literal[False]: ...\n@overload\ndef parse(value: Literal[\"null\"]) -> Literal[None]: ...\n@overload\ndef parse(value: str) -> str: ... # General case for any other string\n\ndef parse(value: str) -> Union[Literal[True], Literal[False], Literal[None], str]:\n    \"\"\"Parses specific string literals to their corresponding Python types.\"\"\"\n    if value == \"true\": return True\n    if value == \"false\": return False\n    if value == \"null\": return None\n    return value\n\nif __name__ == \"__main__\":\n    result1 = parse(\"true\")\n    reveal_type(result1) # Mypy/Pyre: bool, Pyright/Zuban: Literal[True]\n\n    result2 = parse(\"false\")\n    reveal_type(result2) # Mypy/Pyre: bool, Pyright/Zuban: Literal[False]\n\n    result3 = parse(\"hello\")\n    reveal_type(result3) # All: str\n\n    result4 = parse(\"null\")\n    reveal_type(result4) # Mypy/Pyre: None, Pyright/Zuban: Literal[None]\n\n    # Demonstrate usage based on inferred type\n    if result1 is True:\n        print(\"result1 is indeed True!\")\n    if result2 is False:\n        print(\"result2 is indeed False!\")\n    if isinstance(result3, str):\n        print(f\"result3 is a string: {result3}\")\n    if result4 is None:\n        print(\"result4 is indeed None!\")\n\n# EXPECTED:\n#   mypy: Error: Cannot override Final attribute \"x\" with a property (in Derived)\n#   pyright: No error\n#   pyre: Error: Incompatible override (might not recognize Final on attribute as blocking property)\n#   zuban: Error: Cannot override Final attribute \"x\" (likely similar to mypy)\n# REASON: Mypy and Zuban treat `Final` very strictly, considering that a `Final` attribute in a base class cannot be overridden by any member (including a property) in a derived class because it would violate the immutability constraint. Pyright is more lenient, sometimes distinguishing between a `Final` *attribute* (a data descriptor) and a `property` (a non-data descriptor with `fget`/`fset`/`fdel` methods), seeing it as an override of a member name rather than a direct re-assignment of a final value.\nfrom typing import Final\n\nclass Base:\n    x: Final[int] = 1\n    y: int = 10\n\n    def __init__(self, val: int = 0) -> None:\n        # mypy would warn if self.x was assigned here after class-level Final\n        pass\n\nclass Derived(Base):\n    # This attempts to override 'x' which is Final in Base.\n    # Checkers disagree on whether a property can override a Final attribute.\n    @property\n    def x(self) -> int:\n        print(\"Accessing Derived.x property\")\n        return 2\n\n    @x.setter\n    def x(self, value: int) -> None:\n        print(f\"Setting Derived.x property to {value}\")\n        # In a real scenario, this would update an internal state\n        # For demonstration, we just print.\n\n    # This is a normal override, no Final involved, all agree it's fine.\n    y: int = 20\n\ndef demonstrate_final_override(obj: Base) -> None:\n    print(f\"Value of x: {obj.x}\") # Accessing the property or attribute\n    print(f\"Value of y: {obj.y}\")\n\nif __name__ == \"__main__\":\n    base_instance = Base()\n    derived_instance = Derived()\n\n    print(\""
        },
        {
            "id": "typevar-complex-bounds-inference",
            "metadata": "",
            "code": "\")\n    # mypy/pyre/zuban will flag the definition of Derived.x as an error.\n    # Pyright will allow it.\n    demonstrate_final_override(derived_instance)\n    derived_instance.x = 99 # This uses the setter on the property in Derived.\n    demonstrate_final_override(derived_instance)\n\n# EXPECTED:\n#   mypy: Error: Incompatible type \"ConcreteContainer\"; expected \"U\" (or similar error on `cont.get_value()` if U's generic parameter is lost)\n#   pyright: No error\n#   pyre: Error: Incompatible parameter type [6]: Expected `U` (bound to `Container[Animal]`) but got `ConcreteContainer` (or similar)\n#   zuban: No error (likely handles complex bounds and inference well)\n# REASON: Mypy and Pyre can sometimes struggle with complex `TypeVar` bounds, especially when nested generics are involved or when a `TypeVar` is bounded by another generic type that itself has specific type arguments. This can lead to issues inferring the precise type of `cont` within `process_container`, potentially losing the specific generic type argument (e.g., `Dog` or `Cat`) and defaulting to the bound (`Animal`), which can then cause errors when attempting to access specific methods or attributes. Pyright and Zuban are generally more robust in preserving and inferring specific generic type arguments through complex `TypeVar` bounds.\nfrom typing import TypeVar, Generic, Any\n\nclass Animal:\n    def speak(self) -> str: return \"...\"\nclass Dog(Animal):\n    def speak(self) -> str: return \"Woof!\"\n    def fetch(self) -> str: return \"Ball!\"\nclass Cat(Animal):\n    def speak(self) -> str: return \"Meow.\"\n    def purr(self) -> str: return \"Purrrr\"\n\nT_Animal = TypeVar('T_Animal', bound=Animal)\n\nclass Container(Generic[T_Animal]):\n    def __init__(self, value: T_Animal) -> None:\n        self.value = value\n    def get_value(self) -> T_Animal:\n        return self.value\n\nclass DogContainer(Container[Dog]):\n    def __init__(self, dog: Dog) -> None:\n        super().__init__(dog)\n    def bark(self) -> str:\n        return self.value.speak() # Accessing Dog's specific method implicitly\n\n# U is a TypeVar bound to a generic Container whose T_Animal parameter is Animal.\n# This means U can be Container[Animal], DogContainer, CatContainer, etc.\nU = TypeVar('U', bound=Container[Animal])\n\ndef process_container(cont: U) -> None:\n    \"\"\"Processes a container whose value is an Animal or a subclass.\"\"\"\n    print(f\"\\n",
            "full_content": "# id: typevar-complex-bounds-inference\n\n\n\")\n    # mypy/pyre/zuban will flag the definition of Derived.x as an error.\n    # Pyright will allow it.\n    demonstrate_final_override(derived_instance)\n    derived_instance.x = 99 # This uses the setter on the property in Derived.\n    demonstrate_final_override(derived_instance)\n\n# EXPECTED:\n#   mypy: Error: Incompatible type \"ConcreteContainer\"; expected \"U\" (or similar error on `cont.get_value()` if U's generic parameter is lost)\n#   pyright: No error\n#   pyre: Error: Incompatible parameter type [6]: Expected `U` (bound to `Container[Animal]`) but got `ConcreteContainer` (or similar)\n#   zuban: No error (likely handles complex bounds and inference well)\n# REASON: Mypy and Pyre can sometimes struggle with complex `TypeVar` bounds, especially when nested generics are involved or when a `TypeVar` is bounded by another generic type that itself has specific type arguments. This can lead to issues inferring the precise type of `cont` within `process_container`, potentially losing the specific generic type argument (e.g., `Dog` or `Cat`) and defaulting to the bound (`Animal`), which can then cause errors when attempting to access specific methods or attributes. Pyright and Zuban are generally more robust in preserving and inferring specific generic type arguments through complex `TypeVar` bounds.\nfrom typing import TypeVar, Generic, Any\n\nclass Animal:\n    def speak(self) -> str: return \"...\"\nclass Dog(Animal):\n    def speak(self) -> str: return \"Woof!\"\n    def fetch(self) -> str: return \"Ball!\"\nclass Cat(Animal):\n    def speak(self) -> str: return \"Meow.\"\n    def purr(self) -> str: return \"Purrrr\"\n\nT_Animal = TypeVar('T_Animal', bound=Animal)\n\nclass Container(Generic[T_Animal]):\n    def __init__(self, value: T_Animal) -> None:\n        self.value = value\n    def get_value(self) -> T_Animal:\n        return self.value\n\nclass DogContainer(Container[Dog]):\n    def __init__(self, dog: Dog) -> None:\n        super().__init__(dog)\n    def bark(self) -> str:\n        return self.value.speak() # Accessing Dog's specific method implicitly\n\n# U is a TypeVar bound to a generic Container whose T_Animal parameter is Animal.\n# This means U can be Container[Animal], DogContainer, CatContainer, etc.\nU = TypeVar('U', bound=Container[Animal])\n\ndef process_container(cont: U) -> None:\n    \"\"\"Processes a container whose value is an Animal or a subclass.\"\"\"\n    print(f\"\\n"
        },
        {
            "id": "protocol-positional-vs-keyword-only",
            "metadata": "",
            "code": "\")\n    item = cont.get_value()\n    reveal_type(item) # This is key for divergence: should be the specific animal type (e.g., Dog)\n\n    print(f\"  Container holds a {type(item).__name__} that says: {item.speak()}\")\n\n    # Checkers might disagree on the actual type of `item` here.\n    # If `item` is `Dog`, `fetch()` is valid. If it's just `Animal`, it's not.\n    if isinstance(item, Dog):\n        reveal_type(item) # Should be 'Dog'\n        print(f\"  It's a Dog! It can fetch: {item.fetch()}\")\n    elif isinstance(item, Cat):\n        reveal_type(item) # Should be 'Cat'\n        print(f\"  It's a Cat! It can purr: {item.purr()}\")\n    else:\n        print(\"  It's an unknown animal.\")\n\nif __name__ == \"__main__\":\n    dog = Dog()\n    cat = Cat()\n\n    dog_container = DogContainer(dog)\n    cat_container = Container(cat) # Using base Container for cat\n\n    # All agree these are valid assignments.\n    reveal_type(dog_container) # DogContainer\n    reveal_type(cat_container) # Container[Cat]\n\n    # This is where divergence occurs.\n    # Mypy/Pyre might infer 'item' in `process_container` as `Animal` or `Any`,\n    # thus flagging errors on `item.fetch()` or `item.purr()`.\n    # Pyright/Zuban should correctly infer `Dog` and `Cat` respectively.\n    process_container(dog_container)\n    process_container(cat_container)\n\n# EXPECTED:\n#   mypy: Error: Signature of \"simple_func\" incompatible with supertype \"KwargProtocol\" (parameter 'name' does not allow positional arguments)\n#   pyright: No error\n#   pyre: Error: Signature of \"simple_func\" incompatible with supertype \"KwargProtocol\" (or similar error on argument kinds)\n#   zuban: Error: Signature of \"simple_func\" incompatible with supertype \"KwargProtocol\" (likely similar to mypy)\n# REASON: Mypy and Zuban are very strict on the compatibility of positional-only (`/`), positional-or-keyword, and keyword-only (`*`) argument kinds in protocol implementations. A function that allows arguments to be passed positionally (`name: str, age: int`) is considered incompatible with a protocol requiring them to be keyword-only (`*, name: str, age: int`). Pyright is more lenient, allowing this if the argument names and types match, because the function *can* be called with keyword arguments matching the protocol.\nfrom typing import Protocol, Callable\n\nclass KwargProtocol(Protocol):\n    \"\"\"A protocol for callables that require keyword-only arguments.\"\"\"\n    def __call__(self, *, name: str, age: int) -> str: ...\n\ndef simple_func(name: str, age: int) -> str:\n    \"\"\"A function that takes positional-or-keyword arguments.\"\"\"\n    return f\"Name: {name}, Age: {age}\"\n\ndef another_func(*, first_name: str, user_age: int) -> str:\n    \"\"\"A function that takes keyword-only arguments with different names.\"\"\"\n    return f\"First Name: {first_name}, User Age: {user_age}\"\n\nif __name__ == \"__main__\":\n    print(\"",
            "full_content": "# id: protocol-positional-vs-keyword-only\n\n\n\")\n    item = cont.get_value()\n    reveal_type(item) # This is key for divergence: should be the specific animal type (e.g., Dog)\n\n    print(f\"  Container holds a {type(item).__name__} that says: {item.speak()}\")\n\n    # Checkers might disagree on the actual type of `item` here.\n    # If `item` is `Dog`, `fetch()` is valid. If it's just `Animal`, it's not.\n    if isinstance(item, Dog):\n        reveal_type(item) # Should be 'Dog'\n        print(f\"  It's a Dog! It can fetch: {item.fetch()}\")\n    elif isinstance(item, Cat):\n        reveal_type(item) # Should be 'Cat'\n        print(f\"  It's a Cat! It can purr: {item.purr()}\")\n    else:\n        print(\"  It's an unknown animal.\")\n\nif __name__ == \"__main__\":\n    dog = Dog()\n    cat = Cat()\n\n    dog_container = DogContainer(dog)\n    cat_container = Container(cat) # Using base Container for cat\n\n    # All agree these are valid assignments.\n    reveal_type(dog_container) # DogContainer\n    reveal_type(cat_container) # Container[Cat]\n\n    # This is where divergence occurs.\n    # Mypy/Pyre might infer 'item' in `process_container` as `Animal` or `Any`,\n    # thus flagging errors on `item.fetch()` or `item.purr()`.\n    # Pyright/Zuban should correctly infer `Dog` and `Cat` respectively.\n    process_container(dog_container)\n    process_container(cat_container)\n\n# EXPECTED:\n#   mypy: Error: Signature of \"simple_func\" incompatible with supertype \"KwargProtocol\" (parameter 'name' does not allow positional arguments)\n#   pyright: No error\n#   pyre: Error: Signature of \"simple_func\" incompatible with supertype \"KwargProtocol\" (or similar error on argument kinds)\n#   zuban: Error: Signature of \"simple_func\" incompatible with supertype \"KwargProtocol\" (likely similar to mypy)\n# REASON: Mypy and Zuban are very strict on the compatibility of positional-only (`/`), positional-or-keyword, and keyword-only (`*`) argument kinds in protocol implementations. A function that allows arguments to be passed positionally (`name: str, age: int`) is considered incompatible with a protocol requiring them to be keyword-only (`*, name: str, age: int`). Pyright is more lenient, allowing this if the argument names and types match, because the function *can* be called with keyword arguments matching the protocol.\nfrom typing import Protocol, Callable\n\nclass KwargProtocol(Protocol):\n    \"\"\"A protocol for callables that require keyword-only arguments.\"\"\"\n    def __call__(self, *, name: str, age: int) -> str: ...\n\ndef simple_func(name: str, age: int) -> str:\n    \"\"\"A function that takes positional-or-keyword arguments.\"\"\"\n    return f\"Name: {name}, Age: {age}\"\n\ndef another_func(*, first_name: str, user_age: int) -> str:\n    \"\"\"A function that takes keyword-only arguments with different names.\"\"\"\n    return f\"First Name: {first_name}, User Age: {user_age}\"\n\nif __name__ == \"__main__\":\n    print(\""
        },
        {
            "id": "typealias-forward-reference-evaluation",
            "metadata": "",
            "code": "\")\n    print(simple_func(\"David\", 45))\n    print(simple_func(name=\"Eve\", age=50))\n\n# EXPECTED:\n#   mypy: No error. `reveal_type(x)` in `add_one` is `int`.\n#   pyright: No error. `reveal_type(x)` in `add_one` is `int`.\n#   pyre: Error: Undefined name `Numeric` (or similar, due to strict evaluation of TypeAlias).\n#   zuban: No error. `reveal_type(x)` in `add_one` is `int`.\n# REASON: Pyre historically has a stricter and sometimes problematic interpretation of `TypeAlias` when used with forward references (stringified types), particularly when the alias itself is defined *after* its initial definition site but before its full resolution in the code. Mypy, Pyright, and Zuban are generally more lenient and able to resolve these forward references correctly, especially with `TypeAlias` introduced in Python 3.10. The `TypeAlias` decorator implies a full deferred evaluation, which Pyre sometimes struggles to apply consistently.\nfrom typing import TypeAlias, Union, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    # Numeric is defined as a string literal, creating a forward reference.\n    # This setup (TypeAlias using string for a type declared later) is key.\n    Numeric: TypeAlias = \"int | float\"\n\ndef add_one(x: \"Numeric\") -> \"Numeric\": # Using string literal for the alias type\n    \"\"\"Adds one to a numeric value.\"\"\"\n    print(f\"Adding one to {x} (type: {type(x).__name__})\")\n    reveal_type(x) # Should be Union[int, float]\n    return x + 1\n\nif __name__ == \"__main__\":\n    # Now define Numeric. Pyre might complain `Numeric` was not defined before its use in `add_one`.\n    Numeric: TypeAlias = Union[int, float]\n\n    val_int: int = 5\n    val_float: float = 3.14\n\n    result_int = add_one(val_int)\n    print(f\"Result int: {result_int}\")\n    reveal_type(result_int) # Should be Union[int, float]\n\n    result_float = add_one(val_float)\n    print(f\"Result float: {result_float}\")\n    reveal_type(result_float) # Should be Union[int, float]\n\n    # This assignment would also be checked\n    another_val: Numeric = 10.5\n    print(f\"Another val: {another_val}\")\n    reveal_type(another_val)",
            "full_content": "# id: typealias-forward-reference-evaluation\n\n\n\")\n    print(simple_func(\"David\", 45))\n    print(simple_func(name=\"Eve\", age=50))\n\n# EXPECTED:\n#   mypy: No error. `reveal_type(x)` in `add_one` is `int`.\n#   pyright: No error. `reveal_type(x)` in `add_one` is `int`.\n#   pyre: Error: Undefined name `Numeric` (or similar, due to strict evaluation of TypeAlias).\n#   zuban: No error. `reveal_type(x)` in `add_one` is `int`.\n# REASON: Pyre historically has a stricter and sometimes problematic interpretation of `TypeAlias` when used with forward references (stringified types), particularly when the alias itself is defined *after* its initial definition site but before its full resolution in the code. Mypy, Pyright, and Zuban are generally more lenient and able to resolve these forward references correctly, especially with `TypeAlias` introduced in Python 3.10. The `TypeAlias` decorator implies a full deferred evaluation, which Pyre sometimes struggles to apply consistently.\nfrom typing import TypeAlias, Union, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    # Numeric is defined as a string literal, creating a forward reference.\n    # This setup (TypeAlias using string for a type declared later) is key.\n    Numeric: TypeAlias = \"int | float\"\n\ndef add_one(x: \"Numeric\") -> \"Numeric\": # Using string literal for the alias type\n    \"\"\"Adds one to a numeric value.\"\"\"\n    print(f\"Adding one to {x} (type: {type(x).__name__})\")\n    reveal_type(x) # Should be Union[int, float]\n    return x + 1\n\nif __name__ == \"__main__\":\n    # Now define Numeric. Pyre might complain `Numeric` was not defined before its use in `add_one`.\n    Numeric: TypeAlias = Union[int, float]\n\n    val_int: int = 5\n    val_float: float = 3.14\n\n    result_int = add_one(val_int)\n    print(f\"Result int: {result_int}\")\n    reveal_type(result_int) # Should be Union[int, float]\n\n    result_float = add_one(val_float)\n    print(f\"Result float: {result_float}\")\n    reveal_type(result_float) # Should be Union[int, float]\n\n    # This assignment would also be checked\n    another_val: Numeric = 10.5\n    print(f\"Another val: {another_val}\")\n    reveal_type(another_val)"
        }
    ]
}