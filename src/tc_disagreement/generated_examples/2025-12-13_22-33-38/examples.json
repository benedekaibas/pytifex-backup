{
    "timestamp": "2025-12-13T22:33:38.328199",
    "model_used": "gemini-2.5-flash",
    "raw_response": "I have performed one round of generating and refining the 10 Python code snippets. Each snippet is designed to demonstrate a known divergence between mypy, pyright, pyre, and zuban type checkers, adhering to all critical requirements.\n\nHere are the 10 snippets:\n\n---\n\n# id: protocol-default-args-mismatch\n# EXPECTED:\n#   mypy: No error\n#   pyright: Error (Default arguments must match)\n#   pyre: No error\n#   zuban: Error (Default arguments must match)\n# REASON: Mypy and Pyre treat default argument differences in protocol implementations as compatible as long as the signature is otherwise assignable. Pyright and Zuban enforce stricter compatibility, requiring default argument values to match.\nfrom typing import Protocol\n\nclass EventHandler(Protocol):\n    def handle(self, event_name: str, priority: int = 0) -> bool: ...\n\nclass LowPriorityHandler:\n    def handle(self, event_name: str, priority: int = 1) -> bool: # Different default\n        print(f\"Handling '{event_name}' with priority {priority}\")\n        return True\n\ndef process_event(handler: EventHandler, name: str) -> None:\n    handler.handle(name)\n\nif __name__ == \"__main__\":\n    low_handler = LowPriorityHandler()\n    process_event(low_handler, \"user_login\") # Type checkers disagree on default arg compatibility\n\n---\n\n# id: typeguard-generic-narrowing\n# EXPECTED:\n#   mypy: Error (List item type not compatible)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy is more conservative with TypeGuard narrowing, especially when the narrowed type is itself generic. It might not fully infer the generic parameter `T` within the list, leading to an error when modifying the list with a specific type. Pyright, Pyre, and Zuban generally handle this specific generic narrowing more robustly.\nfrom typing import TypeGuard, TypeVar, Any\n\nT = TypeVar('T')\n\ndef is_list_of(val: list[Any], type_: type[T]) -> TypeGuard[list[T]]:\n    \"\"\"Narrows a list of Any to a list of T if all elements are of type_.\"\"\"\n    return all(isinstance(x, type_) for x in val)\n\ndef process_data(items: list[Any]) -> None:\n    if is_list_of(items, int):\n        # After narrowing, 'items' should be list[int]\n        items.append(123)  # Mypy might complain here\n        reveal_type(items)\n    else:\n        items.append(\"fallback\")\n\nif __name__ == \"__main__\":\n    mixed_list: list[Any] = [1, \"hello\", 3.0]\n    process_data(mixed_list)\n\n    int_list: list[Any] = [1, 2, 3]\n    process_data(int_list)\n\n---\n\n# id: typeddict-mixed-total\n# EXPECTED:\n#   mypy: Error (TypedDict \"NetworkConfig\" has no key 'port') or (Item \"port\" might not be present)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy is stricter about direct access (`td['key']`) to NotRequired keys in TypedDicts, even when the key is explicitly marked NotRequired. It requires a prior check (`'key' in td`) or use of `.get()`. Pyright, Pyre, and Zuban often infer the type of `td['key']` as `T | None` for NotRequired keys, allowing direct access without an explicit check.\nfrom typing import TypedDict, Union, Any\nfrom typing_extensions import Required, NotRequired\n\nclass ConnectionBase(TypedDict, total=True): # All keys required by default\n    host: str\n\nclass NetworkConfig(ConnectionBase):\n    port: NotRequired[int] # Explicitly optional\n    protocol: Required[str] # Explicitly required, overriding total=False if it were there\n\ndef check_config(td: NetworkConfig) -> None:\n    reveal_type(td.get('host'))    # str for all\n    reveal_type(td.get('port'))    # int | None for all\n    reveal_type(td['protocol'])    # str for all\n    \n    # This is the point of divergence for direct access to NotRequired keys\n    p = td['port'] # Mypy typically errors here. Others infer int | None.\n    reveal_type(p)\n\nif __name__ == \"__main__\":\n    config1: NetworkConfig = {'host': 'localhost', 'protocol': 'https'}\n    check_config(config1)\n\n    config2: NetworkConfig = {'host': '127.0.0.1', 'port': 8080, 'protocol': 'http'}\n    check_config(config2)\n\n---\n\n# id: paramspec-classmethod-staticmethod\n# EXPECTED:\n#   mypy: Error (Signature mismatch/Argument 1 to \"create_instance\" has incompatible type \"Type[MyUtility]\"; expected \"Type[MyUtility]\" / \"generate_uuid\" has incompatible type)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy has historically struggled with preserving the correct signature (including the implicit `cls` or `self` argument) when applying a `ParamSpec`-based decorator to `classmethod` or `staticmethod`. It might lose the `cls` argument's type, leading to a signature mismatch. Pyright, Pyre, and Zuban are generally better at handling this.\nfrom typing import TypeVar, Callable\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nR = TypeVar('R')\n\ndef log_args_decorator(func: Callable[P, R]) -> Callable[P, R]:\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n        print(f\"Calling {func.__name__} with args: {args}, kwargs: {kwargs}\")\n        return func(*args, **kwargs)\n    return wrapper\n\nclass MyUtility:\n    @log_args_decorator\n    @classmethod\n    def create_instance(cls, name: str, id: int) -> \"MyUtility\":\n        print(f\"Creating MyUtility instance: {name} (ID: {id})\")\n        return cls()\n\n    @log_args_decorator\n    @staticmethod\n    def generate_uuid(prefix: str = \"\") -> str:\n        import uuid\n        return f\"{prefix}-{uuid.uuid4()}\"\n\nif __name__ == \"__main__\":\n    instance = MyUtility.create_instance(\"test_item\", 123) # Mypy often flags 'cls' parameter issue\n    reveal_type(MyUtility.create_instance)\n\n    uuid_val = MyUtility.generate_uuid(\"prefix\")\n    reveal_type(MyUtility.generate_uuid)\n\n---\n\n# id: self-in-generics-abstract\n# EXPECTED:\n#   mypy: Error (Return type Self incompatible with 'StringAppender')\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy can have difficulty correctly inferring `Self` as the precise concrete type of the *implementing* class when `Self` is used within a generic abstract base class, especially if the generic type parameter `T` is also involved. It might resolve `Self` to the generic base class or another type, causing a mismatch. Pyright, Pyre, and Zuban usually handle `Self` in this context correctly.\nfrom typing import Generic, TypeVar, Any\nfrom typing_extensions import Self\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass AbstractBuilder(ABC, Generic[T]):\n    \"\"\"Abstract builder that returns Self for chaining.\"\"\"\n    @abstractmethod\n    def add_item(self, item: T) -> Self:\n        ...\n\n    @abstractmethod\n    def build(self) -> Any:\n        ...\n\nclass StringAppender(AbstractBuilder[str]):\n    _parts: list[str]\n\n    def __init__(self) -> None:\n        self._parts = []\n\n    def add_item(self, item: str) -> Self: # Checkers disagree on Self return type here\n        self._parts.append(item)\n        return self\n\n    def build(self) -> str:\n        return \"\".join(self._parts)\n\nif __name__ == \"__main__\":\n    builder = StringAppender().add_item(\"Hello\").add_item(\" World\")\n    result = builder.build()\n    reveal_type(builder)\n    reveal_type(result)\n\n---\n\n# id: newtype-list-covariance\n# EXPECTED:\n#   mypy: Error (List item type incompatible)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy strictly enforces NewType as distinct types, even when they wrap a covariant type like list. It treats `list[NewType]` as completely separate from `list[BaseType]`, even for passing arguments. Pyright, Pyre, and Zuban can sometimes allow passing a `list[BaseType]` where `list[NewType]` is expected, as long as the base type is compatible, demonstrating a less strict approach to NewType covariance/contravariance with collections.\nfrom typing import NewType, Union\n\nCustomerId = NewType('CustomerId', int)\nProductId = NewType('ProductId', int)\n\ndef get_customer_orders(customer_ids: list[CustomerId]) -> list[str]:\n    \"\"\"Simulates fetching orders for a list of customer IDs.\"\"\"\n    return [f\"Order for customer {cid}\" for cid in customer_ids]\n\ndef process_product_data(product_ids: list[ProductId]) -> None:\n    print(f\"Processing products: {product_ids}\")\n\nif __name__ == \"__main__\":\n    actual_customer_ids: list[CustomerId] = [CustomerId(101), CustomerId(102)]\n    orders = get_customer_orders(actual_customer_ids) # OK for all\n\n    # The divergence point: passing a list of the *base* type where NewType is expected\n    raw_customer_ids: list[int] = [201, 202, 203]\n    # Mypy typically flags this as an error. Pyright/Pyre/Zuban often allow it.\n    orders_raw = get_customer_orders(raw_customer_ids) # Checkers disagree here\n    reveal_type(orders_raw)\n\n    raw_product_ids: list[int] = [10, 20]\n    process_product_data(raw_product_ids) # Similar divergence point\n\n---\n\n# id: overload-literal-discrimination\n# EXPECTED for `debug_val` and `retries_val`:\n#   mypy: Union[bool, int, str] (less precise discrimination, often falls back to the broadest common type)\n#   pyright: bool (for \"debug_mode\"), int (for \"max_retries\")\n#   pyre: bool (for \"debug_mode\"), int (for \"max_retries\")\n#   zuban: bool (for \"debug_mode\"), int (for \"max_retries\")\n# REASON: Mypy is sometimes less aggressive at discriminating `Literal` types within overloads. When a literal string is passed, it might default to the more general `str` overload or combine the results, leading to a wider `Union` type, whereas Pyright, Pyre, and Zuban are often more precise in selecting the specific literal overload and returning its exact type.\nfrom typing import overload, Literal, Union\n\n@overload\ndef get_config_value(key: Literal[\"debug_mode\"]) -> bool: ...\n@overload\ndef get_config_value(key: Literal[\"max_retries\"]) -> int: ...\n@overload\ndef get_config_value(key: str) -> str: ... # Catch-all for other strings\n\ndef get_config_value(key: str) -> Union[bool, int, str]:\n    if key == \"debug_mode\":\n        return True\n    if key == \"max_retries\":\n        return 5\n    return \"default_string_value\"\n\nif __name__ == \"__main__\":\n    debug_val = get_config_value(\"debug_mode\") # Checkers disagree on inferred type\n    reveal_type(debug_val)\n\n    retries_val = get_config_value(\"max_retries\") # Checkers disagree on inferred type\n    reveal_type(retries_val)\n\n    other_val = get_config_value(\"feature_x_enabled\") # Should be str for all\n    reveal_type(other_val)\n\n---\n\n# id: final-override-property\n# EXPECTED:\n#   mypy: Error (Cannot override Final attribute \"API_KEY\" with a property)\n#   pyright: Error (Cannot override Final attribute \"API_KEY\" with a property)\n#   pyre: No error\n#   zuban: Error (Cannot override Final attribute \"API_KEY\" with a property)\n# REASON: Pyre treats a property as a method, not a direct attribute, and might not consider it a direct override of a `Final` class variable in the same way mypy, pyright, and zuban do. The latter checkers interpret `Final` as preventing *any* redefinition of that name in subclasses, whether by another class variable or a property.\nfrom typing import Final\n\nclass BaseSettings:\n    API_KEY: Final[str] = \"initial_api_key\"\n    TIMEOUT: Final[int] = 30\n\nclass ProdSettings(BaseSettings):\n    # Checkers disagree on whether this is a valid override of a Final class variable\n    @property\n    def API_KEY(self) -> str:\n        return \"production_api_key_secure\"\n\n    # If uncommented, this would likely be flagged by all for directly overriding Final\n    # TIMEOUT: Final[int] = 60\n\nif __name__ == \"__main__\":\n    prod_config = ProdSettings()\n    print(f\"Prod API Key: {prod_config.API_KEY}\")\n    reveal_type(prod_config.API_KEY)\n    print(f\"Base Timeout: {prod_config.TIMEOUT}\")\n\n---\n\n# id: double-bound-typevar-generics\n# EXPECTED:\n#   mypy: Error (Argument type \"Notifier[User]\" incompatible with TypeVar \"T_Notifier\" bound \"Notifier[Event]\")\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy can be overly strict when checking compatibility of a generic instance against a `TypeVar` that is bound to another generic type, especially if the inner generic also has a bound. It might not correctly infer that `Notifier[User]` is compatible with `T_Notifier` which is bound to `Notifier[Event]`, despite `User` being a subtype of `Event`. This is because `Notifier` is invariant by default. Pyright, Pyre, and Zuban generally handle this specific subtyping relationship correctly, inferring compatibility.\nfrom typing import TypeVar, Generic, Any\n\nclass Event: ...\nclass User(Event): ...\nclass SystemLog(Event): ...\n\nT = TypeVar('T', bound=Event)\n\nclass Notifier(Generic[T]): # Invariant by default\n    def notify(self, item: T) -> None:\n        print(f\"Notifying about: {type(item).__name__}\")\n\n# T_Notifier is bound to a generic type that itself uses a TypeVar\nT_Notifier = TypeVar('T_Notifier', bound=\"Notifier[Event]\") # Use string for forward ref of Notifier[Event] if in global scope\n\ndef dispatch_event_notification(notifier: T_Notifier, event: Event) -> None:\n    \"\"\"Dispatches an event using a generic notifier.\"\"\"\n    notifier.notify(event)\n\nif __name__ == \"__main__\":\n    user_notifier: Notifier[User] = Notifier()\n    user = User()\n    user_notifier.notify(user) # OK\n\n    # Divergence point: passing Notifier[User] where T_Notifier bound to Notifier[Event] is expected\n    # Mypy often complains here, as it upholds invariance strictly.\n    dispatch_event_notification(user_notifier, user) # Checkers disagree here\n    reveal_type(user_notifier)\n\n    system_notifier: Notifier[SystemLog] = Notifier()\n    system_log = SystemLog()\n    dispatch_event_notification(system_notifier, system_log)\n\n---\n\n# id: protocol-call-positional-keyword\n# EXPECTED:\n#   mypy: Error (Argument mismatch: Protocol expects keyword-only, function has positional-or-keyword)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy can be strict about the exact call signature, especially when a protocol specifies keyword-only arguments for `__call__` (via `*`), but an implementing function uses positional-or-keyword arguments. It might consider the signatures incompatible. Pyright, Pyre, and Zuban are often more lenient, seeing a function that *can* accept keyword arguments as compatible with a protocol requiring them.\nfrom typing import Protocol, Any\n\nclass DataSerializer(Protocol):\n    \"\"\"A protocol for functions that serialize data with specific keyword args.\"\"\"\n    def __call__(self, *, data: dict[str, Any], format: str = \"json\") -> bytes: ...\n\ndef serialize_to_bytes(data: dict[str, Any], format: str = \"json\") -> bytes:\n    \"\"\"A concrete serialization function with positional-or-keyword args.\"\"\"\n    if format == \"json\":\n        import json\n        return json.dumps(data).encode('utf-8')\n    elif format == \"yaml\": # Simplified for example\n        return str(data).encode('utf-8')\n    else:\n        raise ValueError(\"Unsupported format\")\n\nif __name__ == \"__main__\":\n    # Divergence point: assigning a function with positional-or-keyword args to a Protocol requiring keyword-only\n    serializer: DataSerializer = serialize_to_bytes # Checkers disagree here\n    reveal_type(serializer)\n\n    result = serializer(data={\"name\": \"Alice\"}, format=\"json\") # This call itself would be valid at runtime\n    reveal_type(result)\n\n    result_direct = serialize_to_bytes(data={\"id\": 123}, format=\"yaml\")\n    reveal_type(result_direct)\n\n---",
    "examples": [
        {
            "id": "protocol-default-args-mismatch",
            "metadata": "# EXPECTED:\n#   mypy: No error\n#   pyright: Error (Default arguments must match)\n#   pyre: No error\n#   zuban: Error (Default arguments must match)\n# REASON: Mypy and Pyre treat default argument differences in protocol implementations as compatible as long as the signature is otherwise assignable. Pyright and Zuban enforce stricter compatibility, requiring default argument values to match.",
            "code": "from typing import Protocol\n\nclass EventHandler(Protocol):\n    def handle(self, event_name: str, priority: int = 0) -> bool: ...\n\nclass LowPriorityHandler:\n    def handle(self, event_name: str, priority: int = 1) -> bool: # Different default\n        print(f\"Handling '{event_name}' with priority {priority}\")\n        return True\n\ndef process_event(handler: EventHandler, name: str) -> None:\n    handler.handle(name)\n\nif __name__ == \"__main__\":\n    low_handler = LowPriorityHandler()\n    process_event(low_handler, \"user_login\") # Type checkers disagree on default arg compatibility",
            "full_content": "# id: protocol-default-args-mismatch\n# EXPECTED:\n#   mypy: No error\n#   pyright: Error (Default arguments must match)\n#   pyre: No error\n#   zuban: Error (Default arguments must match)\n# REASON: Mypy and Pyre treat default argument differences in protocol implementations as compatible as long as the signature is otherwise assignable. Pyright and Zuban enforce stricter compatibility, requiring default argument values to match.\n\nfrom typing import Protocol\n\nclass EventHandler(Protocol):\n    def handle(self, event_name: str, priority: int = 0) -> bool: ...\n\nclass LowPriorityHandler:\n    def handle(self, event_name: str, priority: int = 1) -> bool: # Different default\n        print(f\"Handling '{event_name}' with priority {priority}\")\n        return True\n\ndef process_event(handler: EventHandler, name: str) -> None:\n    handler.handle(name)\n\nif __name__ == \"__main__\":\n    low_handler = LowPriorityHandler()\n    process_event(low_handler, \"user_login\") # Type checkers disagree on default arg compatibility"
        },
        {
            "id": "typeguard-generic-narrowing",
            "metadata": "# EXPECTED:\n#   mypy: Error (List item type not compatible)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy is more conservative with TypeGuard narrowing, especially when the narrowed type is itself generic. It might not fully infer the generic parameter `T` within the list, leading to an error when modifying the list with a specific type. Pyright, Pyre, and Zuban generally handle this specific generic narrowing more robustly.",
            "code": "from typing import TypeGuard, TypeVar, Any\n\nT = TypeVar('T')\n\ndef is_list_of(val: list[Any], type_: type[T]) -> TypeGuard[list[T]]:\n    \"\"\"Narrows a list of Any to a list of T if all elements are of type_.\"\"\"\n    return all(isinstance(x, type_) for x in val)\n\ndef process_data(items: list[Any]) -> None:\n    if is_list_of(items, int):\n        # After narrowing, 'items' should be list[int]\n        items.append(123)  # Mypy might complain here\n        reveal_type(items)\n    else:\n        items.append(\"fallback\")\n\nif __name__ == \"__main__\":\n    mixed_list: list[Any] = [1, \"hello\", 3.0]\n    process_data(mixed_list)\n\n    int_list: list[Any] = [1, 2, 3]\n    process_data(int_list)",
            "full_content": "# id: typeguard-generic-narrowing\n# EXPECTED:\n#   mypy: Error (List item type not compatible)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy is more conservative with TypeGuard narrowing, especially when the narrowed type is itself generic. It might not fully infer the generic parameter `T` within the list, leading to an error when modifying the list with a specific type. Pyright, Pyre, and Zuban generally handle this specific generic narrowing more robustly.\n\nfrom typing import TypeGuard, TypeVar, Any\n\nT = TypeVar('T')\n\ndef is_list_of(val: list[Any], type_: type[T]) -> TypeGuard[list[T]]:\n    \"\"\"Narrows a list of Any to a list of T if all elements are of type_.\"\"\"\n    return all(isinstance(x, type_) for x in val)\n\ndef process_data(items: list[Any]) -> None:\n    if is_list_of(items, int):\n        # After narrowing, 'items' should be list[int]\n        items.append(123)  # Mypy might complain here\n        reveal_type(items)\n    else:\n        items.append(\"fallback\")\n\nif __name__ == \"__main__\":\n    mixed_list: list[Any] = [1, \"hello\", 3.0]\n    process_data(mixed_list)\n\n    int_list: list[Any] = [1, 2, 3]\n    process_data(int_list)"
        },
        {
            "id": "typeddict-mixed-total",
            "metadata": "# EXPECTED:\n#   mypy: Error (TypedDict \"NetworkConfig\" has no key 'port') or (Item \"port\" might not be present)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy is stricter about direct access (`td['key']`) to NotRequired keys in TypedDicts, even when the key is explicitly marked NotRequired. It requires a prior check (`'key' in td`) or use of `.get()`. Pyright, Pyre, and Zuban often infer the type of `td['key']` as `T | None` for NotRequired keys, allowing direct access without an explicit check.",
            "code": "from typing import TypedDict, Union, Any\nfrom typing_extensions import Required, NotRequired\n\nclass ConnectionBase(TypedDict, total=True): # All keys required by default\n    host: str\n\nclass NetworkConfig(ConnectionBase):\n    port: NotRequired[int] # Explicitly optional\n    protocol: Required[str] # Explicitly required, overriding total=False if it were there\n\ndef check_config(td: NetworkConfig) -> None:\n    reveal_type(td.get('host'))    # str for all\n    reveal_type(td.get('port'))    # int | None for all\n    reveal_type(td['protocol'])    # str for all\n    \n    # This is the point of divergence for direct access to NotRequired keys\n    p = td['port'] # Mypy typically errors here. Others infer int | None.\n    reveal_type(p)\n\nif __name__ == \"__main__\":\n    config1: NetworkConfig = {'host': 'localhost', 'protocol': 'https'}\n    check_config(config1)\n\n    config2: NetworkConfig = {'host': '127.0.0.1', 'port': 8080, 'protocol': 'http'}\n    check_config(config2)",
            "full_content": "# id: typeddict-mixed-total\n# EXPECTED:\n#   mypy: Error (TypedDict \"NetworkConfig\" has no key 'port') or (Item \"port\" might not be present)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy is stricter about direct access (`td['key']`) to NotRequired keys in TypedDicts, even when the key is explicitly marked NotRequired. It requires a prior check (`'key' in td`) or use of `.get()`. Pyright, Pyre, and Zuban often infer the type of `td['key']` as `T | None` for NotRequired keys, allowing direct access without an explicit check.\n\nfrom typing import TypedDict, Union, Any\nfrom typing_extensions import Required, NotRequired\n\nclass ConnectionBase(TypedDict, total=True): # All keys required by default\n    host: str\n\nclass NetworkConfig(ConnectionBase):\n    port: NotRequired[int] # Explicitly optional\n    protocol: Required[str] # Explicitly required, overriding total=False if it were there\n\ndef check_config(td: NetworkConfig) -> None:\n    reveal_type(td.get('host'))    # str for all\n    reveal_type(td.get('port'))    # int | None for all\n    reveal_type(td['protocol'])    # str for all\n    \n    # This is the point of divergence for direct access to NotRequired keys\n    p = td['port'] # Mypy typically errors here. Others infer int | None.\n    reveal_type(p)\n\nif __name__ == \"__main__\":\n    config1: NetworkConfig = {'host': 'localhost', 'protocol': 'https'}\n    check_config(config1)\n\n    config2: NetworkConfig = {'host': '127.0.0.1', 'port': 8080, 'protocol': 'http'}\n    check_config(config2)"
        },
        {
            "id": "paramspec-classmethod-staticmethod",
            "metadata": "# EXPECTED:\n#   mypy: Error (Signature mismatch/Argument 1 to \"create_instance\" has incompatible type \"Type[MyUtility]\"; expected \"Type[MyUtility]\" / \"generate_uuid\" has incompatible type)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy has historically struggled with preserving the correct signature (including the implicit `cls` or `self` argument) when applying a `ParamSpec`-based decorator to `classmethod` or `staticmethod`. It might lose the `cls` argument's type, leading to a signature mismatch. Pyright, Pyre, and Zuban are generally better at handling this.",
            "code": "from typing import TypeVar, Callable\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nR = TypeVar('R')\n\ndef log_args_decorator(func: Callable[P, R]) -> Callable[P, R]:\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n        print(f\"Calling {func.__name__} with args: {args}, kwargs: {kwargs}\")\n        return func(*args, **kwargs)\n    return wrapper\n\nclass MyUtility:\n    @log_args_decorator\n    @classmethod\n    def create_instance(cls, name: str, id: int) -> \"MyUtility\":\n        print(f\"Creating MyUtility instance: {name} (ID: {id})\")\n        return cls()\n\n    @log_args_decorator\n    @staticmethod\n    def generate_uuid(prefix: str = \"\") -> str:\n        import uuid\n        return f\"{prefix}-{uuid.uuid4()}\"\n\nif __name__ == \"__main__\":\n    instance = MyUtility.create_instance(\"test_item\", 123) # Mypy often flags 'cls' parameter issue\n    reveal_type(MyUtility.create_instance)\n\n    uuid_val = MyUtility.generate_uuid(\"prefix\")\n    reveal_type(MyUtility.generate_uuid)",
            "full_content": "# id: paramspec-classmethod-staticmethod\n# EXPECTED:\n#   mypy: Error (Signature mismatch/Argument 1 to \"create_instance\" has incompatible type \"Type[MyUtility]\"; expected \"Type[MyUtility]\" / \"generate_uuid\" has incompatible type)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy has historically struggled with preserving the correct signature (including the implicit `cls` or `self` argument) when applying a `ParamSpec`-based decorator to `classmethod` or `staticmethod`. It might lose the `cls` argument's type, leading to a signature mismatch. Pyright, Pyre, and Zuban are generally better at handling this.\n\nfrom typing import TypeVar, Callable\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nR = TypeVar('R')\n\ndef log_args_decorator(func: Callable[P, R]) -> Callable[P, R]:\n    def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n        print(f\"Calling {func.__name__} with args: {args}, kwargs: {kwargs}\")\n        return func(*args, **kwargs)\n    return wrapper\n\nclass MyUtility:\n    @log_args_decorator\n    @classmethod\n    def create_instance(cls, name: str, id: int) -> \"MyUtility\":\n        print(f\"Creating MyUtility instance: {name} (ID: {id})\")\n        return cls()\n\n    @log_args_decorator\n    @staticmethod\n    def generate_uuid(prefix: str = \"\") -> str:\n        import uuid\n        return f\"{prefix}-{uuid.uuid4()}\"\n\nif __name__ == \"__main__\":\n    instance = MyUtility.create_instance(\"test_item\", 123) # Mypy often flags 'cls' parameter issue\n    reveal_type(MyUtility.create_instance)\n\n    uuid_val = MyUtility.generate_uuid(\"prefix\")\n    reveal_type(MyUtility.generate_uuid)"
        },
        {
            "id": "self-in-generics-abstract",
            "metadata": "# EXPECTED:\n#   mypy: Error (Return type Self incompatible with 'StringAppender')\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy can have difficulty correctly inferring `Self` as the precise concrete type of the *implementing* class when `Self` is used within a generic abstract base class, especially if the generic type parameter `T` is also involved. It might resolve `Self` to the generic base class or another type, causing a mismatch. Pyright, Pyre, and Zuban usually handle `Self` in this context correctly.",
            "code": "from typing import Generic, TypeVar, Any\nfrom typing_extensions import Self\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass AbstractBuilder(ABC, Generic[T]):\n    \"\"\"Abstract builder that returns Self for chaining.\"\"\"\n    @abstractmethod\n    def add_item(self, item: T) -> Self:\n        ...\n\n    @abstractmethod\n    def build(self) -> Any:\n        ...\n\nclass StringAppender(AbstractBuilder[str]):\n    _parts: list[str]\n\n    def __init__(self) -> None:\n        self._parts = []\n\n    def add_item(self, item: str) -> Self: # Checkers disagree on Self return type here\n        self._parts.append(item)\n        return self\n\n    def build(self) -> str:\n        return \"\".join(self._parts)\n\nif __name__ == \"__main__\":\n    builder = StringAppender().add_item(\"Hello\").add_item(\" World\")\n    result = builder.build()\n    reveal_type(builder)\n    reveal_type(result)",
            "full_content": "# id: self-in-generics-abstract\n# EXPECTED:\n#   mypy: Error (Return type Self incompatible with 'StringAppender')\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy can have difficulty correctly inferring `Self` as the precise concrete type of the *implementing* class when `Self` is used within a generic abstract base class, especially if the generic type parameter `T` is also involved. It might resolve `Self` to the generic base class or another type, causing a mismatch. Pyright, Pyre, and Zuban usually handle `Self` in this context correctly.\n\nfrom typing import Generic, TypeVar, Any\nfrom typing_extensions import Self\nfrom abc import ABC, abstractmethod\n\nT = TypeVar('T')\n\nclass AbstractBuilder(ABC, Generic[T]):\n    \"\"\"Abstract builder that returns Self for chaining.\"\"\"\n    @abstractmethod\n    def add_item(self, item: T) -> Self:\n        ...\n\n    @abstractmethod\n    def build(self) -> Any:\n        ...\n\nclass StringAppender(AbstractBuilder[str]):\n    _parts: list[str]\n\n    def __init__(self) -> None:\n        self._parts = []\n\n    def add_item(self, item: str) -> Self: # Checkers disagree on Self return type here\n        self._parts.append(item)\n        return self\n\n    def build(self) -> str:\n        return \"\".join(self._parts)\n\nif __name__ == \"__main__\":\n    builder = StringAppender().add_item(\"Hello\").add_item(\" World\")\n    result = builder.build()\n    reveal_type(builder)\n    reveal_type(result)"
        },
        {
            "id": "newtype-list-covariance",
            "metadata": "# EXPECTED:\n#   mypy: Error (List item type incompatible)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy strictly enforces NewType as distinct types, even when they wrap a covariant type like list. It treats `list[NewType]` as completely separate from `list[BaseType]`, even for passing arguments. Pyright, Pyre, and Zuban can sometimes allow passing a `list[BaseType]` where `list[NewType]` is expected, as long as the base type is compatible, demonstrating a less strict approach to NewType covariance/contravariance with collections.",
            "code": "from typing import NewType, Union\n\nCustomerId = NewType('CustomerId', int)\nProductId = NewType('ProductId', int)\n\ndef get_customer_orders(customer_ids: list[CustomerId]) -> list[str]:\n    \"\"\"Simulates fetching orders for a list of customer IDs.\"\"\"\n    return [f\"Order for customer {cid}\" for cid in customer_ids]\n\ndef process_product_data(product_ids: list[ProductId]) -> None:\n    print(f\"Processing products: {product_ids}\")\n\nif __name__ == \"__main__\":\n    actual_customer_ids: list[CustomerId] = [CustomerId(101), CustomerId(102)]\n    orders = get_customer_orders(actual_customer_ids) # OK for all\n\n    # The divergence point: passing a list of the *base* type where NewType is expected\n    raw_customer_ids: list[int] = [201, 202, 203]\n    # Mypy typically flags this as an error. Pyright/Pyre/Zuban often allow it.\n    orders_raw = get_customer_orders(raw_customer_ids) # Checkers disagree here\n    reveal_type(orders_raw)\n\n    raw_product_ids: list[int] = [10, 20]\n    process_product_data(raw_product_ids) # Similar divergence point",
            "full_content": "# id: newtype-list-covariance\n# EXPECTED:\n#   mypy: Error (List item type incompatible)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy strictly enforces NewType as distinct types, even when they wrap a covariant type like list. It treats `list[NewType]` as completely separate from `list[BaseType]`, even for passing arguments. Pyright, Pyre, and Zuban can sometimes allow passing a `list[BaseType]` where `list[NewType]` is expected, as long as the base type is compatible, demonstrating a less strict approach to NewType covariance/contravariance with collections.\n\nfrom typing import NewType, Union\n\nCustomerId = NewType('CustomerId', int)\nProductId = NewType('ProductId', int)\n\ndef get_customer_orders(customer_ids: list[CustomerId]) -> list[str]:\n    \"\"\"Simulates fetching orders for a list of customer IDs.\"\"\"\n    return [f\"Order for customer {cid}\" for cid in customer_ids]\n\ndef process_product_data(product_ids: list[ProductId]) -> None:\n    print(f\"Processing products: {product_ids}\")\n\nif __name__ == \"__main__\":\n    actual_customer_ids: list[CustomerId] = [CustomerId(101), CustomerId(102)]\n    orders = get_customer_orders(actual_customer_ids) # OK for all\n\n    # The divergence point: passing a list of the *base* type where NewType is expected\n    raw_customer_ids: list[int] = [201, 202, 203]\n    # Mypy typically flags this as an error. Pyright/Pyre/Zuban often allow it.\n    orders_raw = get_customer_orders(raw_customer_ids) # Checkers disagree here\n    reveal_type(orders_raw)\n\n    raw_product_ids: list[int] = [10, 20]\n    process_product_data(raw_product_ids) # Similar divergence point"
        },
        {
            "id": "overload-literal-discrimination",
            "metadata": "# EXPECTED for `debug_val` and `retries_val`:\n#   mypy: Union[bool, int, str] (less precise discrimination, often falls back to the broadest common type)\n#   pyright: bool (for \"debug_mode\"), int (for \"max_retries\")\n#   pyre: bool (for \"debug_mode\"), int (for \"max_retries\")\n#   zuban: bool (for \"debug_mode\"), int (for \"max_retries\")\n# REASON: Mypy is sometimes less aggressive at discriminating `Literal` types within overloads. When a literal string is passed, it might default to the more general `str` overload or combine the results, leading to a wider `Union` type, whereas Pyright, Pyre, and Zuban are often more precise in selecting the specific literal overload and returning its exact type.",
            "code": "from typing import overload, Literal, Union\n\n@overload\ndef get_config_value(key: Literal[\"debug_mode\"]) -> bool: ...\n@overload\ndef get_config_value(key: Literal[\"max_retries\"]) -> int: ...\n@overload\ndef get_config_value(key: str) -> str: ... # Catch-all for other strings\n\ndef get_config_value(key: str) -> Union[bool, int, str]:\n    if key == \"debug_mode\":\n        return True\n    if key == \"max_retries\":\n        return 5\n    return \"default_string_value\"\n\nif __name__ == \"__main__\":\n    debug_val = get_config_value(\"debug_mode\") # Checkers disagree on inferred type\n    reveal_type(debug_val)\n\n    retries_val = get_config_value(\"max_retries\") # Checkers disagree on inferred type\n    reveal_type(retries_val)\n\n    other_val = get_config_value(\"feature_x_enabled\") # Should be str for all\n    reveal_type(other_val)",
            "full_content": "# id: overload-literal-discrimination\n# EXPECTED for `debug_val` and `retries_val`:\n#   mypy: Union[bool, int, str] (less precise discrimination, often falls back to the broadest common type)\n#   pyright: bool (for \"debug_mode\"), int (for \"max_retries\")\n#   pyre: bool (for \"debug_mode\"), int (for \"max_retries\")\n#   zuban: bool (for \"debug_mode\"), int (for \"max_retries\")\n# REASON: Mypy is sometimes less aggressive at discriminating `Literal` types within overloads. When a literal string is passed, it might default to the more general `str` overload or combine the results, leading to a wider `Union` type, whereas Pyright, Pyre, and Zuban are often more precise in selecting the specific literal overload and returning its exact type.\n\nfrom typing import overload, Literal, Union\n\n@overload\ndef get_config_value(key: Literal[\"debug_mode\"]) -> bool: ...\n@overload\ndef get_config_value(key: Literal[\"max_retries\"]) -> int: ...\n@overload\ndef get_config_value(key: str) -> str: ... # Catch-all for other strings\n\ndef get_config_value(key: str) -> Union[bool, int, str]:\n    if key == \"debug_mode\":\n        return True\n    if key == \"max_retries\":\n        return 5\n    return \"default_string_value\"\n\nif __name__ == \"__main__\":\n    debug_val = get_config_value(\"debug_mode\") # Checkers disagree on inferred type\n    reveal_type(debug_val)\n\n    retries_val = get_config_value(\"max_retries\") # Checkers disagree on inferred type\n    reveal_type(retries_val)\n\n    other_val = get_config_value(\"feature_x_enabled\") # Should be str for all\n    reveal_type(other_val)"
        },
        {
            "id": "final-override-property",
            "metadata": "# EXPECTED:\n#   mypy: Error (Cannot override Final attribute \"API_KEY\" with a property)\n#   pyright: Error (Cannot override Final attribute \"API_KEY\" with a property)\n#   pyre: No error\n#   zuban: Error (Cannot override Final attribute \"API_KEY\" with a property)\n# REASON: Pyre treats a property as a method, not a direct attribute, and might not consider it a direct override of a `Final` class variable in the same way mypy, pyright, and zuban do. The latter checkers interpret `Final` as preventing *any* redefinition of that name in subclasses, whether by another class variable or a property.",
            "code": "from typing import Final\n\nclass BaseSettings:\n    API_KEY: Final[str] = \"initial_api_key\"\n    TIMEOUT: Final[int] = 30\n\nclass ProdSettings(BaseSettings):\n    # Checkers disagree on whether this is a valid override of a Final class variable\n    @property\n    def API_KEY(self) -> str:\n        return \"production_api_key_secure\"\n\n    # If uncommented, this would likely be flagged by all for directly overriding Final\n    # TIMEOUT: Final[int] = 60\n\nif __name__ == \"__main__\":\n    prod_config = ProdSettings()\n    print(f\"Prod API Key: {prod_config.API_KEY}\")\n    reveal_type(prod_config.API_KEY)\n    print(f\"Base Timeout: {prod_config.TIMEOUT}\")",
            "full_content": "# id: final-override-property\n# EXPECTED:\n#   mypy: Error (Cannot override Final attribute \"API_KEY\" with a property)\n#   pyright: Error (Cannot override Final attribute \"API_KEY\" with a property)\n#   pyre: No error\n#   zuban: Error (Cannot override Final attribute \"API_KEY\" with a property)\n# REASON: Pyre treats a property as a method, not a direct attribute, and might not consider it a direct override of a `Final` class variable in the same way mypy, pyright, and zuban do. The latter checkers interpret `Final` as preventing *any* redefinition of that name in subclasses, whether by another class variable or a property.\n\nfrom typing import Final\n\nclass BaseSettings:\n    API_KEY: Final[str] = \"initial_api_key\"\n    TIMEOUT: Final[int] = 30\n\nclass ProdSettings(BaseSettings):\n    # Checkers disagree on whether this is a valid override of a Final class variable\n    @property\n    def API_KEY(self) -> str:\n        return \"production_api_key_secure\"\n\n    # If uncommented, this would likely be flagged by all for directly overriding Final\n    # TIMEOUT: Final[int] = 60\n\nif __name__ == \"__main__\":\n    prod_config = ProdSettings()\n    print(f\"Prod API Key: {prod_config.API_KEY}\")\n    reveal_type(prod_config.API_KEY)\n    print(f\"Base Timeout: {prod_config.TIMEOUT}\")"
        },
        {
            "id": "double-bound-typevar-generics",
            "metadata": "# EXPECTED:\n#   mypy: Error (Argument type \"Notifier[User]\" incompatible with TypeVar \"T_Notifier\" bound \"Notifier[Event]\")\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy can be overly strict when checking compatibility of a generic instance against a `TypeVar` that is bound to another generic type, especially if the inner generic also has a bound. It might not correctly infer that `Notifier[User]` is compatible with `T_Notifier` which is bound to `Notifier[Event]`, despite `User` being a subtype of `Event`. This is because `Notifier` is invariant by default. Pyright, Pyre, and Zuban generally handle this specific subtyping relationship correctly, inferring compatibility.",
            "code": "from typing import TypeVar, Generic, Any\n\nclass Event: ...\nclass User(Event): ...\nclass SystemLog(Event): ...\n\nT = TypeVar('T', bound=Event)\n\nclass Notifier(Generic[T]): # Invariant by default\n    def notify(self, item: T) -> None:\n        print(f\"Notifying about: {type(item).__name__}\")\n\n# T_Notifier is bound to a generic type that itself uses a TypeVar\nT_Notifier = TypeVar('T_Notifier', bound=\"Notifier[Event]\") # Use string for forward ref of Notifier[Event] if in global scope\n\ndef dispatch_event_notification(notifier: T_Notifier, event: Event) -> None:\n    \"\"\"Dispatches an event using a generic notifier.\"\"\"\n    notifier.notify(event)\n\nif __name__ == \"__main__\":\n    user_notifier: Notifier[User] = Notifier()\n    user = User()\n    user_notifier.notify(user) # OK\n\n    # Divergence point: passing Notifier[User] where T_Notifier bound to Notifier[Event] is expected\n    # Mypy often complains here, as it upholds invariance strictly.\n    dispatch_event_notification(user_notifier, user) # Checkers disagree here\n    reveal_type(user_notifier)\n\n    system_notifier: Notifier[SystemLog] = Notifier()\n    system_log = SystemLog()\n    dispatch_event_notification(system_notifier, system_log)",
            "full_content": "# id: double-bound-typevar-generics\n# EXPECTED:\n#   mypy: Error (Argument type \"Notifier[User]\" incompatible with TypeVar \"T_Notifier\" bound \"Notifier[Event]\")\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy can be overly strict when checking compatibility of a generic instance against a `TypeVar` that is bound to another generic type, especially if the inner generic also has a bound. It might not correctly infer that `Notifier[User]` is compatible with `T_Notifier` which is bound to `Notifier[Event]`, despite `User` being a subtype of `Event`. This is because `Notifier` is invariant by default. Pyright, Pyre, and Zuban generally handle this specific subtyping relationship correctly, inferring compatibility.\n\nfrom typing import TypeVar, Generic, Any\n\nclass Event: ...\nclass User(Event): ...\nclass SystemLog(Event): ...\n\nT = TypeVar('T', bound=Event)\n\nclass Notifier(Generic[T]): # Invariant by default\n    def notify(self, item: T) -> None:\n        print(f\"Notifying about: {type(item).__name__}\")\n\n# T_Notifier is bound to a generic type that itself uses a TypeVar\nT_Notifier = TypeVar('T_Notifier', bound=\"Notifier[Event]\") # Use string for forward ref of Notifier[Event] if in global scope\n\ndef dispatch_event_notification(notifier: T_Notifier, event: Event) -> None:\n    \"\"\"Dispatches an event using a generic notifier.\"\"\"\n    notifier.notify(event)\n\nif __name__ == \"__main__\":\n    user_notifier: Notifier[User] = Notifier()\n    user = User()\n    user_notifier.notify(user) # OK\n\n    # Divergence point: passing Notifier[User] where T_Notifier bound to Notifier[Event] is expected\n    # Mypy often complains here, as it upholds invariance strictly.\n    dispatch_event_notification(user_notifier, user) # Checkers disagree here\n    reveal_type(user_notifier)\n\n    system_notifier: Notifier[SystemLog] = Notifier()\n    system_log = SystemLog()\n    dispatch_event_notification(system_notifier, system_log)"
        },
        {
            "id": "protocol-call-positional-keyword",
            "metadata": "# EXPECTED:\n#   mypy: Error (Argument mismatch: Protocol expects keyword-only, function has positional-or-keyword)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy can be strict about the exact call signature, especially when a protocol specifies keyword-only arguments for `__call__` (via `*`), but an implementing function uses positional-or-keyword arguments. It might consider the signatures incompatible. Pyright, Pyre, and Zuban are often more lenient, seeing a function that *can* accept keyword arguments as compatible with a protocol requiring them.",
            "code": "from typing import Protocol, Any\n\nclass DataSerializer(Protocol):\n    \"\"\"A protocol for functions that serialize data with specific keyword args.\"\"\"\n    def __call__(self, *, data: dict[str, Any], format: str = \"json\") -> bytes: ...\n\ndef serialize_to_bytes(data: dict[str, Any], format: str = \"json\") -> bytes:\n    \"\"\"A concrete serialization function with positional-or-keyword args.\"\"\"\n    if format == \"json\":\n        import json\n        return json.dumps(data).encode('utf-8')\n    elif format == \"yaml\": # Simplified for example\n        return str(data).encode('utf-8')\n    else:\n        raise ValueError(\"Unsupported format\")\n\nif __name__ == \"__main__\":\n    # Divergence point: assigning a function with positional-or-keyword args to a Protocol requiring keyword-only\n    serializer: DataSerializer = serialize_to_bytes # Checkers disagree here\n    reveal_type(serializer)\n\n    result = serializer(data={\"name\": \"Alice\"}, format=\"json\") # This call itself would be valid at runtime\n    reveal_type(result)\n\n    result_direct = serialize_to_bytes(data={\"id\": 123}, format=\"yaml\")\n    reveal_type(result_direct)",
            "full_content": "# id: protocol-call-positional-keyword\n# EXPECTED:\n#   mypy: Error (Argument mismatch: Protocol expects keyword-only, function has positional-or-keyword)\n#   pyright: No error\n#   pyre: No error\n#   zuban: No error\n# REASON: Mypy can be strict about the exact call signature, especially when a protocol specifies keyword-only arguments for `__call__` (via `*`), but an implementing function uses positional-or-keyword arguments. It might consider the signatures incompatible. Pyright, Pyre, and Zuban are often more lenient, seeing a function that *can* accept keyword arguments as compatible with a protocol requiring them.\n\nfrom typing import Protocol, Any\n\nclass DataSerializer(Protocol):\n    \"\"\"A protocol for functions that serialize data with specific keyword args.\"\"\"\n    def __call__(self, *, data: dict[str, Any], format: str = \"json\") -> bytes: ...\n\ndef serialize_to_bytes(data: dict[str, Any], format: str = \"json\") -> bytes:\n    \"\"\"A concrete serialization function with positional-or-keyword args.\"\"\"\n    if format == \"json\":\n        import json\n        return json.dumps(data).encode('utf-8')\n    elif format == \"yaml\": # Simplified for example\n        return str(data).encode('utf-8')\n    else:\n        raise ValueError(\"Unsupported format\")\n\nif __name__ == \"__main__\":\n    # Divergence point: assigning a function with positional-or-keyword args to a Protocol requiring keyword-only\n    serializer: DataSerializer = serialize_to_bytes # Checkers disagree here\n    reveal_type(serializer)\n\n    result = serializer(data={\"name\": \"Alice\"}, format=\"json\") # This call itself would be valid at runtime\n    reveal_type(result)\n\n    result_direct = serialize_to_bytes(data={\"id\": 123}, format=\"yaml\")\n    reveal_type(result_direct)"
        }
    ]
}