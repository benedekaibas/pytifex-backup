{
    "timestamp": "2026-01-13_20-13-14",
    "checkers_used": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
    ],
    "results": [
        {
            "filename": "final-property-override.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13: error: Unterminated string literal (detected at line 13)  [syntax]\nFound 1 error in 1 file (errors prevented further checking)",
                "pyrefly": "ERROR Parse error: Expected an expression [parse-error]\n --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:1\n  |\n9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n  | ^^\n  |\nERROR Could not find name `Self` [unknown-name]\n --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:3\n  |\n9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n  |   ^^^^\n  |\nERROR Could not find name `correction` [unknown-name]\n --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:8\n  |\n9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n  |        ^^^^^^^^^^\n  |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:19\n  |\n9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n  |                   ^^^^^\n  |\nERROR Could not find name `Round` [unknown-name]\n --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:19\n  |\n9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n  |                   ^^^^^\n  |\n  Did you mean `round`?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:25\n  |\n9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n  |                         ^\n  |\nERROR Parse error: Got unexpected token ` [parse-error]\n --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:42\n  |\n9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n  |                                          ^\n  |\nERROR Could not find name `Final` [unknown-name]\n --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:43\n  |\n9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n  |                                           ^^^^^\n  |\nERROR Parse error: Got unexpected token ` [parse-error]\n --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:48\n  |\n9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n  |                                                ^\n  |\nERROR Could not find name `example` [unknown-name]\n --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:50\n  |\n9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n  |                                                  ^^^^^^^\n  |\nERROR Parse error: Expected an identifier [parse-error]\n --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:58\n  |\n9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n  |                                                          ^^\n  |\nERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:60\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                                                            ^\n10 |\n   |\nERROR Could not find name `The` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:1\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   | ^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:5\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |     ^\n   |\nERROR Could not find name `Final` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:6\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |      ^^^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:11\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |           ^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:18\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                  ^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:27\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                           ^\n   |\nERROR Could not find name `override` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:29\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                             ^^^^^^^^\n   |\nERROR Could not find name `consistently` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:41\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                         ^^^^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:54\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                      ^^^^^^^\n   |\nERROR Could not find name `flagged` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:54\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                      ^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:65\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                 ^^^^\n   |\nERROR Could not find name `need` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:65\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                 ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:70\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                      ^\n   |\nERROR Could not find name `a` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:70\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                      ^\n   |\nERROR Could not find name `real` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:73\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                         ^^^^\n   |\nERROR `divergence` is uninitialized [unbound-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:79\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                               ^^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:90\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                          ^^^^^\n   |\nERROR Could not find name `point` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:90\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                          ^^^^^\n   |\n  Did you mean `print`?\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:96\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                                ^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:100\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                                    ^\n   |\nERROR Could not find name `Final` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:101\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                                     ^^^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:106\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                                          ^\n   |\nERROR Parse error: Expected a statement [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:107\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                                           ^\n   |\nERROR Parse error: Expected a statement [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:108\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                                            ^\n12 |\n   |\nERROR Could not find name `A` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:1\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   | ^\n   |\n  Did you mean ``?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:3\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   |   ^^^^^\n   |\nERROR Could not find name `known` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:3\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   |   ^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:9\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   |         ^^^^^^^^^^\n   |\nERROR `divergence` is uninitialized [unbound-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:9\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   |         ^^^^^^^^^^\n   |\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:20\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   |                    ^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:24\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   |                        ^\n   |\nERROR Could not find name `Final` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:25\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   |                         ^^^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:30\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   |                              ^\n   |\nERROR Parse error: Expected a statement [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:32\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   |                                ^^\n   |\nERROR Could not find name `when` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:35\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   |                                   ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:40\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   |                                        ^^\n   |\nERROR Could not find name `it` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:40\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`...\n   |                                        ^^\n   |\n  Did you mean `int`?\nERROR Parse error: missing closing quote in string literal [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:42\n   |\n13 | ... it's applied to class variables in abstract base classes, or its interaction with `__slots__`. Or, when a `Final` variable is reassigned *in the same scope* but under different control flow.\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:1\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   | ^^\n   |\nERROR Could not find name `New` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:3\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |   ^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:7\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |       ^^^^\n   |\nERROR Could not find name `idea` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:7\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |       ^^^^\n   |\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:12\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |            ^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:16\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                ^\n   |\nERROR Could not find name `Final` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:17\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                 ^^^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:22\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                      ^\n   |\nERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:35\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                   ^^\n   |\nERROR binary operation `**` cannot be used in annotations [invalid-annotation]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:35\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                   ^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:38\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                      ^\n   |\nERROR Could not find name `Final` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:39\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                       ^^^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:44\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                            ^\n   |\nERROR Parse error: Expected `:`, found `in` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:61\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                             ^^\n   |\nERROR Could not find name `a` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:64\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                ^\n   |\n  Did you mean ``?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:66\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                  ^^^^\n   |\nERROR Could not find name `base` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:66\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                  ^^^^\n   |\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:71\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                       ^^^^^\n   |\nERROR Parse error: Expected an identifier [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:76\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                            ^\n   |\nERROR Could not find name `accessed` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:78\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                              ^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:87\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                       ^^^\n   |\nERROR Could not find name `via` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:87\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                       ^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:91\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                           ^\n   |\nERROR Could not find name `a` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:91\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                           ^\n   |\n  Did you mean ``?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:93\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                             ^^^^^^^^\n   |\nERROR Could not find name `subclass` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:93\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                             ^^^^^^^^\n   |\n  Did you mean `issubclass`?\nERROR Parse error: Expected an identifier [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:102\n   |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                                      ^\n   |\n\n[STDERR]\n INFO 77 errors",
                "zuban": "generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15: error: Invalid syntax  [syntax]\nFound 4 errors in 1 file (checked 1 source file)",
                "ty": "error[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:1\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   | ^^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\n\nerror[unresolved-reference]: Name `Self` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:3\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |   ^^^^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `correction` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:8\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |        ^^^^^^^^^^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:19\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                   ^^^^^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\n\nerror[unresolved-reference]: Name `Round` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:19\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                   ^^^^^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:25\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                         ^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\n\nerror[invalid-type-form]: Invalid binary operator `-` in type annotation\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:28\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                            ^^^^^^^^^^^^^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\ninfo: See the following page for a reference on valid type expressions:\ninfo: https://typing.python.org/en/latest/spec/annotations.html#type-and-annotation-expressions\ninfo: rule `invalid-type-form` is enabled by default\n\nerror[unresolved-reference]: Name `Re` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:28\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                            ^^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `evaluating` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:31\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                               ^^^^^^^^^^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:42\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                                          ^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\n\nerror[unresolved-reference]: Name `Final` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:43\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                                           ^^^^^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:48\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                                                ^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\n\nerror[unresolved-reference]: Name `example` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:50\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                                                  ^^^^^^^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:58\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                                                          ^^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\n\nerror[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:9:60\n   |\n 7 | # REASON: `Final` marks an attribute as immutable after initialization. Overriding a `Final` instance variable with a `property` in a \u2026\n 8 |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n   |                                                            ^\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |\n\nerror[unresolved-reference]: Name `The` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:1\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   | ^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:5\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |     ^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[unresolved-reference]: Name `Final` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:6\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |      ^^^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:11\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |           ^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:18\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                  ^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:27\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                           ^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[unresolved-reference]: Name `override` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:29\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                             ^^^^^^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `consistently` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:41\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                         ^^^^^^^^^^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:54\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                      ^^^^^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[unresolved-reference]: Name `flagged` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:54\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                      ^^^^^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:65\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                 ^^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[unresolved-reference]: Name `need` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:65\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                 ^^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:70\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                      ^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[unresolved-reference]: Name `a` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:70\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                      ^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `real` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:73\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                         ^^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `divergence` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:79\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                               ^^^^^^^^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:90\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                          ^^^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[unresolved-reference]: Name `point` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:90\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                          ^^^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:96\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                                ^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:100\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                                    ^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[unresolved-reference]: Name `Final` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:101\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                                     ^^^^^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:106\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                                          ^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[invalid-syntax]: Expected a statement\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:107\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                                           ^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[invalid-syntax]: Expected a statement\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:11:108\n   |\n 9 | **Self-correction Round 3: Re-evaluating `Final` example.**\n10 |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n   |                                                                                                            ^\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |\n\nerror[unresolved-reference]: Name `A` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:1\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   | ^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:3\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |   ^^^^^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\n\nerror[unresolved-reference]: Name `known` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:3\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |   ^^^^^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:9\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |         ^^^^^^^^^^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\n\nerror[unresolved-reference]: Name `divergence` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:9\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |         ^^^^^^^^^^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:20\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |                    ^^^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:24\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |                        ^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\n\nerror[unresolved-reference]: Name `Final` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:25\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |                         ^^^^^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:30\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |                              ^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\n\nerror[invalid-syntax]: Expected a statement\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:32\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |                                ^^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\n\nerror[unresolved-reference]: Name `when` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:35\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |                                   ^^^^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:40\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |                                        ^^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\n\nerror[unresolved-reference]: Name `it` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:40\n   |\n11 | The `Final` with `property` override is consistently flagged. I need a *real* divergence point for `Final`.\n12 |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n   |                                        ^^\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: missing closing quote in string literal\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:13:42\n   |\n11 | \u2026 is consistently flagged. I need a *real* divergence point for `Final`.\n12 | \u2026\n13 | \u2026en it's applied to class variables in abstract base classes, or its interaction with `__slots__`. Or, when a `Final` variable is reassigned *in the same scope* but under different control flow.\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n14 | \u2026\n15 | \u2026 `Final` class variable in a base class, accessed via a subclass.\n   |\n\nerror[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:1\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   | ^^\n   |\n\nerror[unresolved-reference]: Name `New` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:3\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |   ^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:7\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |       ^^^^\n   |\n\nerror[unresolved-reference]: Name `idea` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:7\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |       ^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:12\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |            ^^^\n   |\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:16\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                ^\n   |\n\nerror[unresolved-reference]: Name `Final` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:17\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                 ^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:22\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                      ^\n   |\n\nerror[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:35\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                   ^^\n   |\n\nerror[invalid-type-form]: Invalid binary operator `**` in type annotation\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:35\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                   ^^\n   |\ninfo: See the following page for a reference on valid type expressions:\ninfo: https://typing.python.org/en/latest/spec/annotations.html#type-and-annotation-expressions\ninfo: rule `invalid-type-form` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:38\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                      ^\n   |\n\nerror[unresolved-reference]: Name `Final` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:39\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                       ^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:44\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                            ^\n   |\n\nerror[invalid-syntax]: Expected `:`, found `in`\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:61\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                             ^^\n   |\n\nerror[unresolved-reference]: Name `a` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:64\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                ^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:66\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                  ^^^^\n   |\n\nerror[unresolved-reference]: Name `base` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:66\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                  ^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:71\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                       ^^^^^\n   |\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:76\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                            ^\n   |\n\nerror[unresolved-reference]: Name `accessed` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:78\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                              ^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:87\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                       ^^^\n   |\n\nerror[unresolved-reference]: Name `via` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:87\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                       ^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:91\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                           ^\n   |\n\nerror[unresolved-reference]: Name `a` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:91\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                           ^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:93\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                             ^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `subclass` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:93\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                             ^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/final-property-override.py:15:102\n   |\n13 | A known divergence for `Final` is when it's applied to class variables in abstract base classes, or its interaction with `__slots__`. \u2026\n14 |\n15 | **New idea for `Final` divergence:** `Final` class variable in a base class, accessed via a subclass.\n   |                                                                                                      ^\n   |\n\nFound 80 diagnostics"
            }
        },
        {
            "filename": "double-bound-typevar-resolution.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/double-bound-typevar-resolution.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_20-13-14/source_files/double-bound-typevar-resolution.py:48: error: Value of type variable \"U\" of \"process_container\" cannot be \"DogContainer\"  [type-var]\ngenerated_examples/2026-01-13_20-13-14/source_files/double-bound-typevar-resolution.py:52: error: Value of type variable \"U\" of \"process_container\" cannot be \"Container[Cat]\"  [type-var]\nFound 2 errors in 1 file (checked 1 source file)",
                "pyrefly": "ERROR `DogContainer` is not assignable to upper bound `Container[Animal]` of type variable `U` [bad-specialization]\n  --> generated_examples/2026-01-13_20-13-14/source_files/double-bound-typevar-resolution.py:48:22\n   |\n48 |     process_container(dog_box) # Expecting this to be type-safe\n   |                      ^^^^^^^^^\n   |\nERROR `Container[Cat]` is not assignable to upper bound `Container[Animal]` of type variable `U` [bad-specialization]\n  --> generated_examples/2026-01-13_20-13-14/source_files/double-bound-typevar-resolution.py:52:22\n   |\n52 |     process_container(cat_box) # Should also be fine\n   |                      ^^^^^^^^^\n   |\n\n[STDERR]\n INFO 2 errors",
                "zuban": "generated_examples/2026-01-13_20-13-14/source_files/double-bound-typevar-resolution.py:48: error: Value of type variable \"U\" of \"process_container\" cannot be \"DogContainer\"  [type-var]\ngenerated_examples/2026-01-13_20-13-14/source_files/double-bound-typevar-resolution.py:52: error: Value of type variable \"U\" of \"process_container\" cannot be \"Container[Cat]\"  [type-var]\nFound 2 errors in 1 file (checked 1 source file)",
                "ty": "error[invalid-argument-type]: Argument to function `process_container` is incorrect\n  --> generated_examples/2026-01-13_20-13-14/source_files/double-bound-typevar-resolution.py:48:23\n   |\n47 |     # The divergence occurs here. Is DogContainer[Dog] assignable to U (bound=Container[Animal])?\n48 |     process_container(dog_box) # Expecting this to be type-safe\n   |                       ^^^^^^^ Argument type `DogContainer` does not satisfy upper bound `Container[Animal]` of type variable `U`\n49 |     \n50 |     cat_obj = Cat()\n   |\ninfo: Type variable defined here\n  --> generated_examples/2026-01-13_20-13-14/source_files/double-bound-typevar-resolution.py:34:1\n   |\n33 | # U is a TypeVar that is bound to a Container whose item type is at least an Animal\n34 | U = TypeVar('U', bound=Container[Animal])\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n35 |\n36 | def process_container(cont: U) -> None:\n   |\ninfo: rule `invalid-argument-type` is enabled by default\n\nerror[invalid-argument-type]: Argument to function `process_container` is incorrect\n  --> generated_examples/2026-01-13_20-13-14/source_files/double-bound-typevar-resolution.py:52:23\n   |\n50 |     cat_obj = Cat()\n51 |     cat_box = Container(cat_obj) # Container[Cat]\n52 |     process_container(cat_box) # Should also be fine\n   |                       ^^^^^^^ Argument type `Container[Cat]` does not satisfy upper bound `Container[Animal]` of type variable `U`\n   |\ninfo: Type variable defined here\n  --> generated_examples/2026-01-13_20-13-14/source_files/double-bound-typevar-resolution.py:34:1\n   |\n33 | # U is a TypeVar that is bound to a Container whose item type is at least an Animal\n34 | U = TypeVar('U', bound=Container[Animal])\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n35 |\n36 | def process_container(cont: U) -> None:\n   |\ninfo: rule `invalid-argument-type` is enabled by default\n\nFound 2 diagnostics"
            }
        },
        {
            "filename": "protocol-call-keyword-only-vs-positional.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44: error: Invalid syntax  [syntax]\nFound 1 error in 1 file (errors prevented further checking)",
                "pyrefly": "ERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:1\n   |\n44 | **Summary of Rounds:**\n   | ^^\n   |\nERROR Could not find name `Summary` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:3\n   |\n44 | **Summary of Rounds:**\n   |   ^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:11\n   |\n44 | **Summary of Rounds:**\n   |           ^^\n   |\nERROR Could not find name `of` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:11\n   |\n44 | **Summary of Rounds:**\n   |           ^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:14\n   |\n44 | **Summary of Rounds:**\n   |              ^^^^^^\n   |\nERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:21\n   |\n44 | **Summary of Rounds:**\n   |                     ^^\n   |\nERROR binary operation `**` cannot be used in annotations [invalid-annotation]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:21\n   |\n44 | **Summary of Rounds:**\n   |                     ^^\n   |\nERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:23\n   |\n44 | **Summary of Rounds:**\n   |                       ^\n45 |\n   |\nERROR Could not find name `I` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:1\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n   | ^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:3\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n   |   ^^^^^^^^^\n   |\nERROR Could not find name `completed` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:3\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n   |   ^^^^^^^^^\n   |\n  Did you mean `complex`?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:17\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                 ^^^^^^\n   |\nERROR Could not find name `rounds` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:17\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                 ^^^^^^\n   |\n  Did you mean `round`?\nERROR Could not find name `of` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:26\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                          ^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:29\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                             ^^^^^^^^^^\n   |\nERROR Could not find name `generation` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:29\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                             ^^^^^^^^^^\n   |\nERROR Could not find name `internal` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:44\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                                            ^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:53\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                                                     ^^^^^^^^^^^^\n   |\nERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:66\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                                                                  ^\n47 | 1.  Initial generation based on the categories.\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:5\n   |\n47 | 1.  Initial generation based on the categories.\n   |     ^^^^^^^\n   |\nERROR Could not find name `Initial` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:5\n   |\n47 | 1.  Initial generation based on the categories.\n   |     ^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:13\n   |\n47 | 1.  Initial generation based on the categories.\n   |             ^^^^^^^^^^\n   |\nERROR Could not find name `generation` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:13\n   |\n47 | 1.  Initial generation based on the categories.\n   |             ^^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:24\n   |\n47 | 1.  Initial generation based on the categories.\n   |                        ^^^^^\n   |\nERROR Could not find name `based` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:24\n   |\n47 | 1.  Initial generation based on the categories.\n   |                        ^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:30\n   |\n47 | 1.  Initial generation based on the categories.\n   |                              ^^\n   |\nERROR Could not find name `on` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:30\n   |\n47 | 1.  Initial generation based on the categories.\n   |                              ^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:33\n   |\n47 | 1.  Initial generation based on the categories.\n   |                                 ^^^\n   |\nERROR Could not find name `the` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:33\n   |\n47 | 1.  Initial generation based on the categories.\n   |                                 ^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:37\n   |\n47 | 1.  Initial generation based on the categories.\n   |                                     ^^^^^^^^^^\n   |\nERROR Could not find name `categories` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:37\n   |\n47 | 1.  Initial generation based on the categories.\n   |                                     ^^^^^^^^^^\n   |\nERROR Parse error: Expected an identifier [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:48\n   |\n47 | 1.  Initial generation based on the categories.\n   |                                                ^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:5\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |     ^^^^\n   |\nERROR Could not find name `Self` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:5\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |     ^^^^\n   |\nERROR Could not find name `correction` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:10\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |          ^^^^^^^^^^\n   |\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:21\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                     ^^^\n   |\nERROR Expected a callable, got `Literal['Protocol with default arguments']` [not-callable]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:25\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nERROR Could not find name `the` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:60\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                            ^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:64\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                ^^^^^^^\n   |\nERROR Could not find name `initial` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:64\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                ^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:72\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                        ^^^^^^^\n   |\nERROR Could not find name `example` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:72\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                        ^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:80\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                ^^^\n   |\nERROR Could not find name `was` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:80\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                ^^^\n   |\nERROR Parse error: Expected `,`, found `not` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:84\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                    ^^^\n   |\nERROR Could not find name `a` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:88\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                        ^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:90\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                          ^^^^^^^^^^\n   |\nERROR Could not find name `divergence` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:90\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                          ^^^^^^^^^^\n   |\nERROR Parse error: Expected an identifier [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:102\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                                      ^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\nERROR Parse error: Expected an indented block after `for` statement [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:1\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   | ^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:5\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |     ^^^^\n   |\nERROR Could not find name `Self` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:5\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |     ^^^^\n   |\nERROR Could not find name `correction` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:10\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |          ^^^^^^^^^^\n   |\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:21\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                     ^^^\n   |\nERROR Expected a callable, got `Literal['NewType and List covariance']` [not-callable]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:25\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nERROR Could not find name `the` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:56\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                        ^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:60\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                            ^^^^^^^\n   |\nERROR Could not find name `initial` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:60\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                            ^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:68\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                    ^^^^^^^\n   |\nERROR Could not find name `example` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:68\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                    ^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:76\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                            ^^^\n   |\nERROR Could not find name `was` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:76\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                            ^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:80\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                ^^^^^^^^^^^^\n   |\nERROR Could not find name `consistently` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:80\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                ^^^^^^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:93\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                             ^^\n   |\nERROR Could not find name `an` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:93\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                             ^^\n   |\n  Did you mean `any`?\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:96\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                ^^^^^\n   |\nERROR Could not find name `error` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:96\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                ^^^^^\n   |\nERROR Could not find name `a` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:107\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                           ^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:109\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                             ^^^^^^^^^^\n   |\nERROR Could not find name `divergence` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:109\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                             ^^^^^^^^^^\n   |\nERROR Parse error: Expected an identifier [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:121\n   |\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                                         ^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\nERROR Parse error: Expected an indented block after `for` statement [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:1\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   | ^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:5\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |     ^^^^\n   |\nERROR Could not find name `Self` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:5\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |     ^^^^\n   |\nERROR Could not find name `correction` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:10\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |          ^^^^^^^^^^\n   |\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:21\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                     ^^^\n   |\nERROR Expected a callable, got `Literal['Final with property override']` [not-callable]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:25\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nERROR Could not find name `the` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:57\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                         ^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:61\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                             ^^^^^^^\n   |\nERROR Could not find name `initial` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:61\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                             ^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:69\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                     ^^^^^^^\n   |\nERROR Could not find name `example` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:69\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                     ^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:77\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                             ^^^\n   |\nERROR Could not find name `was` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:77\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                             ^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:81\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                 ^^^^^^^^^^^^\n   |\nERROR Could not find name `consistently` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:81\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                 ^^^^^^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:94\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                              ^^\n   |\nERROR Could not find name `an` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:94\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                              ^^\n   |\n  Did you mean `any`?\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:97\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                 ^^^^^\n   |\nERROR Could not find name `error` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:97\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                 ^^^^^\n   |\nERROR Could not find name `a` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:108\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                            ^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:110\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                              ^^^^^^^^^^\n   |\nERROR Could not find name `divergence` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:110\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                              ^^^^^^^^^^\n   |\nERROR Parse error: Expected an identifier [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:122\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                                          ^\n51 |\n   |\nERROR Parse error: Expected an indented block after `for` statement [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:1\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   | ^^^^\n   |\nERROR Could not find name `This` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:1\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   | ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:6\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |      ^^^^^^^^^\n   |\nERROR Could not find name `iterative` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:6\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |      ^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:16\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                ^^^^^^^\n   |\nERROR Could not find name `process` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:16\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                ^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:24\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                        ^^^^^^\n   |\nERROR Could not find name `helped` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:24\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                        ^^^^^^\n   |\n  Did you mean `help`?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:31\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                               ^^^^^^\n   |\nERROR Could not find name `refine` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:31\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                               ^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:38\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                      ^^^\n   |\nERROR Could not find name `the` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:38\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                      ^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:42\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                          ^^^^^^^^\n   |\nERROR Could not find name `examples` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:42\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                          ^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:51\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                   ^^\n   |\nERROR Could not find name `to` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:51\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                   ^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:54\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                      ^^^^^\n   |\nERROR Could not find name `truly` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:54\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                      ^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:60\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                            ^^^^^^\n   |\nERROR Could not find name `target` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:60\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                            ^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:67\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                   ^^^^^\n   |\nERROR Could not find name `known` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:67\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                   ^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:73\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                         ^^^^^\n   |\nERROR Could not find name `areas` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:73\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                         ^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:79\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                               ^^\n   |\nERROR Could not find name `of` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:79\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                               ^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:82\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                  ^^^^^^^^^^\n   |\nERROR Could not find name `divergence` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:82\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                  ^^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:93\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                             ^^^^^\n   |\nERROR Could not find name `among` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:93\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                             ^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:99\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                                   ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:104\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                                        ^^^^^^^^\n   |\nERROR Could not find name `checkers` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:104\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                                        ^^^^^^^^\n   |\nERROR Parse error: Expected an identifier [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:113\n   |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                                                 ^\n   |\n\n[STDERR]\n INFO 129 errors",
                "zuban": "generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52: error: Invalid syntax  [syntax]\nFound 7 errors in 1 file (checked 1 source file)",
                "ty": "error[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:1\n   |\n44 | **Summary of Rounds:**\n   | ^^\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |\n\nerror[unresolved-reference]: Name `Summary` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:3\n   |\n44 | **Summary of Rounds:**\n   |   ^^^^^^^\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:11\n   |\n44 | **Summary of Rounds:**\n   |           ^^\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |\n\nerror[unresolved-reference]: Name `of` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:11\n   |\n44 | **Summary of Rounds:**\n   |           ^^\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:14\n   |\n44 | **Summary of Rounds:**\n   |              ^^^^^^\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |\n\nerror[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:21\n   |\n44 | **Summary of Rounds:**\n   |                     ^^\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |\n\nerror[invalid-type-form]: Invalid binary operator `**` in type annotation\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:21\n   |\n44 | **Summary of Rounds:**\n   |                     ^^\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |\ninfo: See the following page for a reference on valid type expressions:\ninfo: https://typing.python.org/en/latest/spec/annotations.html#type-and-annotation-expressions\ninfo: rule `invalid-type-form` is enabled by default\n\nerror[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:44:23\n   |\n44 | **Summary of Rounds:**\n   |                       ^\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |\n\nerror[unresolved-reference]: Name `I` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:1\n   |\n44 | **Summary of Rounds:**\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   | ^\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:3\n   |\n44 | **Summary of Rounds:**\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |   ^^^^^^^^^\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |\n\nerror[unresolved-reference]: Name `completed` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:3\n   |\n44 | **Summary of Rounds:**\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |   ^^^^^^^^^\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:17\n   |\n44 | **Summary of Rounds:**\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                 ^^^^^^\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |\n\nerror[unresolved-reference]: Name `rounds` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:17\n   |\n44 | **Summary of Rounds:**\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                 ^^^^^^\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `of` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:26\n   |\n44 | **Summary of Rounds:**\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                          ^^\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:29\n   |\n44 | **Summary of Rounds:**\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                             ^^^^^^^^^^\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |\n\nerror[unresolved-reference]: Name `generation` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:29\n   |\n44 | **Summary of Rounds:**\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                             ^^^^^^^^^^\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `internal` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:44\n   |\n44 | **Summary of Rounds:**\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                                            ^^^^^^^^\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:53\n   |\n44 | **Summary of Rounds:**\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                                                     ^^^^^^^^^^^^\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |\n\nerror[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:46:66\n   |\n44 | **Summary of Rounds:**\n45 |\n46 | I completed **3 rounds** of generation and internal verification:\n   |                                                                  ^\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:5\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |     ^^^^^^^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `Initial` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:5\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |     ^^^^^^^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:13\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |             ^^^^^^^^^^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `generation` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:13\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |             ^^^^^^^^^^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:24\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |                        ^^^^^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `based` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:24\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |                        ^^^^^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:30\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |                              ^^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `on` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:30\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |                              ^^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:33\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |                                 ^^^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `the` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:33\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |                                 ^^^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:37\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |                                     ^^^^^^^^^^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `categories` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:37\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |                                     ^^^^^^^^^^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:47:48\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n   |                                                ^\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:5\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |     ^^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `Self` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:5\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |     ^^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `correction` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:10\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |          ^^^^^^^^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:21\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                     ^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[call-non-callable]: Object of type `Literal[\"Protocol with default arguments\"]` is not callable\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:25\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `call-non-callable` is enabled by default\n\nerror[unresolved-reference]: Name `the` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:60\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                            ^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:64\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                ^^^^^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `initial` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:64\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                ^^^^^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:72\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                        ^^^^^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `example` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:72\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                        ^^^^^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:80\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                ^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `was` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:80\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                ^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found `not`\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:84\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                    ^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `a` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:88\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                        ^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:90\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                          ^^^^^^^^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `divergence` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:90\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                          ^^^^^^^^^^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:48:102\n   |\n46 | I completed **3 rounds** of generation and internal verification:\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n   |                                                                                                      ^\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[invalid-syntax]: Expected an indented block after `for` statement\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:1\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   | ^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:5\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |     ^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `Self` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:5\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |     ^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `correction` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:10\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |          ^^^^^^^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:21\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                     ^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[call-non-callable]: Object of type `Literal[\"NewType and List covariance\"]` is not callable\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:25\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `call-non-callable` is enabled by default\n\nerror[unresolved-reference]: Name `the` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:56\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                        ^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:60\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                            ^^^^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `initial` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:60\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                            ^^^^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:68\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                    ^^^^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `example` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:68\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                    ^^^^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:76\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                            ^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `was` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:76\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                            ^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:80\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                ^^^^^^^^^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `consistently` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:80\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                ^^^^^^^^^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:93\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                             ^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `an` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:93\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                             ^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:96\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                ^^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `error` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:96\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                ^^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `a` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:107\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                           ^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:109\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                             ^^^^^^^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[unresolved-reference]: Name `divergence` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:109\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                             ^^^^^^^^^^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:49:121\n   |\n47 | 1.  Initial generation based on the categories.\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                                         ^\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |\n\nerror[invalid-syntax]: Expected an indented block after `for` statement\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:1\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   | ^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:5\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |     ^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\n\nerror[unresolved-reference]: Name `Self` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:5\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |     ^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `correction` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:10\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |          ^^^^^^^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:21\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                     ^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\n\nerror[call-non-callable]: Object of type `Literal[\"Final with property override\"]` is not callable\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:25\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\ninfo: rule `call-non-callable` is enabled by default\n\nerror[unresolved-reference]: Name `the` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:57\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                         ^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:61\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                             ^^^^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\n\nerror[unresolved-reference]: Name `initial` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:61\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                             ^^^^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:69\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                     ^^^^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\n\nerror[unresolved-reference]: Name `example` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:69\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                     ^^^^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:77\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                             ^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\n\nerror[unresolved-reference]: Name `was` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:77\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                             ^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:81\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                 ^^^^^^^^^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\n\nerror[unresolved-reference]: Name `consistently` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:81\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                 ^^^^^^^^^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:94\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                              ^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\n\nerror[unresolved-reference]: Name `an` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:94\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                              ^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:97\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                 ^^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\n\nerror[unresolved-reference]: Name `error` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:97\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                 ^^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `a` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:108\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                            ^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:110\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                              ^^^^^^^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\n\nerror[unresolved-reference]: Name `divergence` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:110\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                              ^^^^^^^^^^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:50:122\n   |\n48 | 2.  Self-correction for \"Protocol with default arguments\" (the initial example was not a divergence).\n49 | 3.  Self-correction for \"NewType and List covariance\" (the initial example was consistently an error, not a divergence).\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n   |                                                                                                                          ^\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |\n\nerror[invalid-syntax]: Expected an indented block after `for` statement\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:1\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   | ^^^^\n   |\n\nerror[unresolved-reference]: Name `This` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:1\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   | ^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:6\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |      ^^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `iterative` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:6\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |      ^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:16\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                ^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `process` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:16\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                ^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:24\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                        ^^^^^^\n   |\n\nerror[unresolved-reference]: Name `helped` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:24\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                        ^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:31\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                               ^^^^^^\n   |\n\nerror[unresolved-reference]: Name `refine` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:31\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                               ^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:38\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                      ^^^\n   |\n\nerror[unresolved-reference]: Name `the` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:38\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                      ^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:42\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                          ^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `examples` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:42\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                          ^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:51\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                   ^^\n   |\n\nerror[unresolved-reference]: Name `to` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:51\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                   ^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:54\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                      ^^^^^\n   |\n\nerror[unresolved-reference]: Name `truly` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:54\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                      ^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:60\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                            ^^^^^^\n   |\n\nerror[unresolved-reference]: Name `target` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:60\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                            ^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:67\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                   ^^^^^\n   |\n\nerror[unresolved-reference]: Name `known` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:67\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                   ^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:73\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                         ^^^^^\n   |\n\nerror[unresolved-reference]: Name `areas` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:73\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                         ^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:79\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                               ^^\n   |\n\nerror[unresolved-reference]: Name `of` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:79\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                               ^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:82\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                  ^^^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `divergence` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:82\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                  ^^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:93\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                             ^^^^^\n   |\n\nerror[unresolved-reference]: Name `among` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:93\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                             ^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:99\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                                   ^^^^\n   |\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:104\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                                        ^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `checkers` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:104\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                                        ^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-call-keyword-only-vs-positional.py:52:113\n   |\n50 | 4.  Self-correction for \"Final with property override\" (the initial example was consistently an error, not a divergence).\n51 |\n52 | This iterative process helped refine the examples to truly target known areas of divergence among type checkers.\n   |                                                                                                                 ^\n   |\n\nFound 129 diagnostics"
            }
        },
        {
            "filename": "newtype-base-type-attribute-access.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/newtype-base-type-attribute-access.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_20-13-14/source_files/newtype-base-type-attribute-access.py:30: note: Revealed type is \"def () -> tuple[builtins.int, builtins.int]\"\nSuccess: no issues found in 1 source file",
                "pyrefly": "ERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-base-type-attribute-access.py:30:5\n   |\n30 |     reveal_type(my_coord.as_integer_ratio) # This will show disagreement\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: BoundMethod[Coordinate, (self: Coordinate) -> tuple[int, int]] [reveal-type]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-base-type-attribute-access.py:30:16\n   |\n30 |     reveal_type(my_coord.as_integer_ratio) # This will show disagreement\n   |                ---------------------------\n   |\n\n[STDERR]\n INFO 1 error",
                "zuban": "generated_examples/2026-01-13_20-13-14/source_files/newtype-base-type-attribute-access.py:30: note: Revealed type is \"def () -> builtins.tuple[builtins.int, builtins.int]\"\nSuccess: no issues found in 1 source file",
                "ty": "error[invalid-newtype]: invalid base for `typing.NewType`\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-base-type-attribute-access.py:12:36\n   |\n11 | # Coordinate is a NewType based on float\n12 | Coordinate = NewType('Coordinate', float)\n   |                                    ^^^^^ type `int | float`\n13 |\n14 | def process_coordinate(coord: Coordinate) -> float:\n   |\ninfo: The base of a `NewType` must be a class type or another `NewType`.\ninfo: rule `invalid-newtype` is enabled by default\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-base-type-attribute-access.py:30:5\n   |\n28 |     # Another example: calling a method\n29 |     precision = my_coord.as_integer_ratio() # This is also a float method\n30 |     reveal_type(my_coord.as_integer_ratio) # This will show disagreement\n   |     ^^^^^^^^^^^\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-base-type-attribute-access.py:30:17\n   |\n28 |     # Another example: calling a method\n29 |     precision = my_coord.as_integer_ratio() # This is also a float method\n30 |     reveal_type(my_coord.as_integer_ratio) # This will show disagreement\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ `Any`\n   |\n\nFound 3 diagnostics"
            }
        },
        {
            "filename": "protocol-default-arg-absence.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: error: Missing positional argument \"message\" in call to \"process_data\"  [call-arg]\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: error: Argument 1 to \"process_data\" has incompatible type \"LocalWriter\"; expected \"Writer\"  [arg-type]\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: note: Following member(s) of \"LocalWriter\" have conflicts:\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: note:     Expected:\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: note:         def write(self, data: str, *, encoding: str = ...) -> int\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: note:     Got:\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: note:         def write(self, data: str, *, encoding: str) -> int\nFound 2 errors in 1 file (checked 1 source file)",
                "pyrefly": "ERROR Missing argument `message` in function `process_data` [missing-argument]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24:17\n   |\n24 |     process_data(local_writer) # Divergence point here\n   |                 ^^^^^^^^^^^^^^\n   |\nERROR Argument `LocalWriter` is not assignable to parameter `w` with type `Writer` in function `process_data` [bad-argument-type]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24:18\n   |\n24 |     process_data(local_writer) # Divergence point here\n   |                  ^^^^^^^^^^^^\n   |\n  `LocalWriter.write` has type `BoundMethod[LocalWriter, (self: LocalWriter, data: str, *, encoding: str) -> int]`, which is not assignable to `BoundMethod[LocalWriter, (self: LocalWriter, data: str, *, encoding: str = 'utf-8') -> int]`, the type of `Writer.write`\n\n[STDERR]\n INFO 2 errors",
                "zuban": "generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: error: Missing positional argument \"message\" in call to \"process_data\"  [call-arg]\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: error: Argument 1 to \"process_data\" has incompatible type \"LocalWriter\"; expected \"Writer\"  [arg-type]\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: note: Following member(s) of \"LocalWriter\" have conflicts:\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: note:     Expected:\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: note:         def write(self, data: str, *, encoding: str = ...) -> int\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: note:     Got:\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24: note:         def write(self, data: str, *, encoding: str) -> int\nFound 2 errors in 1 file (checked 1 source file)",
                "ty": "error[missing-argument]: No argument provided for required parameter `message` of function `process_data`\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24:5\n   |\n22 | if __name__ == \"__main__\":\n23 |     local_writer = LocalWriter()\n24 |     process_data(local_writer) # Divergence point here\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\ninfo: Parameter declared here\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:18:29\n   |\n16 |         return len(data.encode(encoding))\n17 |\n18 | def process_data(w: Writer, message: str) -> None:\n   |                             ^^^^^^^^^^^^\n19 |     w.write(message) # This call requires 'encoding' to be optional\n20 |     w.write(message, encoding=\"latin-1\")\n   |\ninfo: rule `missing-argument` is enabled by default\n\nerror[invalid-argument-type]: Argument to function `process_data` is incorrect\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:24:18\n   |\n22 | if __name__ == \"__main__\":\n23 |     local_writer = LocalWriter()\n24 |     process_data(local_writer) # Divergence point here\n   |                  ^^^^^^^^^^^^ Expected `Writer`, found `LocalWriter`\n   |\ninfo: Function defined here\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-absence.py:18:5\n   |\n16 |         return len(data.encode(encoding))\n17 |\n18 | def process_data(w: Writer, message: str) -> None:\n   |     ^^^^^^^^^^^^ --------- Parameter declared here\n19 |     w.write(message) # This call requires 'encoding' to be optional\n20 |     w.write(message, encoding=\"latin-1\")\n   |\ninfo: rule `invalid-argument-type` is enabled by default\n\nFound 2 diagnostics"
            }
        },
        {
            "filename": "final-class-var-subclass-access.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/final-class-var-subclass-access.py",
            "outputs": {
                "mypy": "Success: no issues found in 1 source file",
                "pyrefly": "[STDERR]\n INFO 0 errors",
                "zuban": "Success: no issues found in 1 source file",
                "ty": "All checks passed!"
            }
        },
        {
            "filename": "newtype-list-covariance.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11: error: Unterminated string literal (detected at line 11)  [syntax]\nFound 1 error in 1 file (errors prevented further checking)",
                "pyrefly": "ERROR Parse error: Expected an expression [parse-error]\n --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:1\n  |\n9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n  | ^^\n  |\nERROR Could not find name `Self` [unknown-name]\n --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:3\n  |\n9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n  |   ^^^^\n  |\nERROR Could not find name `correction` [unknown-name]\n --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:8\n  |\n9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n  |        ^^^^^^^^^^\n  |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:19\n  |\n9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n  |                   ^^^^^\n  |\nERROR Could not find name `Round` [unknown-name]\n --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:19\n  |\n9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n  |                   ^^^^^\n  |\n  Did you mean `round`?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:25\n  |\n9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n  |                         ^\n  |\nERROR Parse error: Got unexpected token ` [parse-error]\n --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:42\n  |\n9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n  |                                          ^\n  |\nERROR Could not find name `NewType` [unknown-name]\n --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:43\n  |\n9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n  |                                           ^^^^^^^\n  |\nERROR Parse error: Got unexpected token ` [parse-error]\n --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:50\n  |\n9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n  |                                                  ^\n  |\nERROR Could not find name `example` [unknown-name]\n --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:52\n  |\n9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n  |                                                    ^^^^^^^\n  |\nERROR Parse error: Expected an identifier [parse-error]\n --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:60\n  |\n9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n  |                                                            ^^\n  |\nERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:62\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                                                              ^\n10 |\n   |\nERROR Could not find name `The` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:1\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   | ^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:5\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |     ^\n   |\nERROR Could not find name `NewType` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:6\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |      ^^^^^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:13\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |             ^\n   |\nERROR Parse error: Expected a statement [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:15\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |               ^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:19\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                   ^\n   |\nERROR Could not find name `List` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:20\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                    ^^^^\n   |\n  Did you mean `list`?\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:24\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                        ^\n   |\nERROR Could not find name `invariance` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:26\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                          ^^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:37\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                     ^^^^^^^\n   |\nERROR Could not find name `example` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:37\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                     ^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:45\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                             ^^^^^^^^^\n   |\nERROR Could not find name `correctly` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:45\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                             ^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:55\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                       ^^^^^^\n   |\nERROR Could not find name `points` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:55\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                       ^^^^^^\n   |\n  Did you mean `print`?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:62\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                              ^^^\n   |\nERROR Could not find name `out` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:62\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                              ^^^\n   |\n  Did you mean `oct`?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:66\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                                  ^^^^\n   |\nERROR Could not find name `that` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:66\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                                  ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:71\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                                       ^^\n   |\nERROR Could not find name `it` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:71\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                                       ^^\n   |\n  Did you mean `int`?\nERROR Could not find name `should` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:75\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                                           ^^^^^^\n   |\nERROR Could not find name `error` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:83\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                                                   ^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:89\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                                                         ^^^^^^^^^^\n   |\nERROR Could not find name `everywhere` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:89\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                                                         ^^^^^^^^^^\n   |\nERROR Could not find name `it` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:105\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point....\n   |                                                                                                         ^^\n   |\n  Did you mean `int`?\nERROR Parse error: missing closing quote in string literal [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:107\n   |\n11 | ... error everywhere. So, it's not a divergence point. I need a different example for `NewType` divergence.\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nERROR Could not find name `A` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:1\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   | ^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:3\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |   ^^^^^^\n   |\nERROR Could not find name `common` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:3\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |   ^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:10\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |          ^^^^^^\n   |\nERROR Could not find name `subtle` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:10\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |          ^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:17\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                 ^^^^^^^^^^\n   |\nERROR `divergence` is uninitialized [unbound-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:17\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                 ^^^^^^^^^^\n   |\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:28\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                            ^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:32\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                ^\n   |\nERROR Could not find name `NewType` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:33\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                 ^^^^^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:40\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                        ^\n   |\nERROR Parse error: Expected a statement [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:42\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                          ^^\n   |\nERROR Could not find name `around` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:45\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                             ^^^^^^\n   |\n  Did you mean `round`?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:52\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                    ^^^\n   |\nERROR Could not find name `its` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:52\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                    ^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:56\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                        ^^^^^^^^^^^\n   |\nERROR Could not find name `interaction` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:56\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                        ^^^^^^^^^^^\n   |\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:68\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                    ^^^^\n   |\nERROR Could not find name `structural` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:73\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                         ^^^^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:84\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                    ^^^^^^^^^\n   |\nERROR Could not find name `subtyping` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:84\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                    ^^^^^^^^^\n   |\nERROR Could not find name `methods` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:97\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                                 ^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:105\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                                         ^^\n   |\nERROR Could not find name `of` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:105\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                                         ^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:108\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                                            ^^^\n   |\nERROR Could not find name `the` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:108\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                                            ^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:112\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                                                ^^^^\n   |\nERROR Could not find name `base` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:112\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                                                ^^^^\n   |\nERROR Parse error: Expected `,`, found `type` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:117\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                                                     ^^^^\n   |\nERROR Cannot use `type[type]` as a context manager [bad-context-manager]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:117\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                                                     ^^^^\n   |\n  Class `type` has no class attribute `__enter__`\n  Did you mean `__new__`?\nERROR Cannot use `type[type]` as a context manager [bad-context-manager]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:117\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                                                     ^^^^\n   |\n  Class `type` has no class attribute `__exit__`\n  Did you mean `__init__`?\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:122\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                                                          ^^^^\n   |\nERROR Could not find name `when` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:122\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when access...\n   |                                                                                                                          ^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:127\n   |\n13 | ... with structural subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                ^^^^^^^^\n   |\nERROR Could not find name `accessed` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:127\n   |\n13 | ... with structural subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                ^^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:136\n   |\n13 | ...structural subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                   ^^^\n   |\nERROR Could not find name `via` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:136\n   |\n13 | ...structural subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                   ^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:140\n   |\n13 | ...uctural subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                    ^\n   |\nERROR Could not find name `NewType` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:141\n   |\n13 | ...ral subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                 ^^^^^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:148\n   |\n13 | ...subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                    ^\n   |\nERROR Could not find name `variable` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:150\n   |\n13 | ...ing or methods of the base type when accessed via `NewType` variable.\n   |                                                                ^^^^^^^^\n   |\nERROR Parse error: Expected an identifier [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:159\n   |\n13 | ...r methods of the base type when accessed via `NewType` variable.\n   |                                                                    ^\n14 | ...\n   |\nERROR Parse error: Expected an indented block after `with` statement [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:1\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   | ^^\n   |\nERROR Could not find name `New` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:3\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |   ^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:7\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |       ^^^^\n   |\nERROR Could not find name `idea` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:7\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |       ^^^^\n   |\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:12\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |            ^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:16\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                ^\n   |\nERROR Could not find name `NewType` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:17\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                 ^^^^^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:24\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                        ^\n   |\nERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:37\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                     ^^\n   |\nERROR binary operation `**` cannot be used in annotations [invalid-annotation]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:37\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                     ^^^^^^^^^^^^\n   |\nERROR Could not find name `Accessing` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:40\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                        ^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:50\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                  ^^^^^^^^^^\n   |\nERROR Could not find name `attributes` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:50\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                  ^^^^^^^^^^\n   |\nERROR Could not find name `methods` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:64\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                ^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:72\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                        ^^\n   |\nERROR Could not find name `of` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:72\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                        ^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:75\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                           ^^^\n   |\nERROR Could not find name `the` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:75\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                           ^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:79\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                               ^^^^\n   |\nERROR Could not find name `base` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:79\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                               ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:84\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                    ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:89\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                         ^^\n   |\nERROR Could not find name `on` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:89\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                         ^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:92\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                            ^\n   |\nERROR Could not find name `a` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:92\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                            ^\n   |\n  Did you mean ``?\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:94\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                              ^\n   |\nERROR Could not find name `NewType` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:95\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                               ^^^^^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:102\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                                      ^\n   |\nERROR Could not find name `instance` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:104\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                                        ^^^^^^^^\n   |\n  Did you mean `isinstance`?\nERROR Parse error: Expected an identifier [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:113\n   |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                                                 ^\n   |\n\n[STDERR]\n INFO 111 errors",
                "zuban": "generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15: error: Invalid syntax  [syntax]\nFound 4 errors in 1 file (checked 1 source file)",
                "ty": "error[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:1\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   | ^^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\n\nerror[unresolved-reference]: Name `Self` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:3\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |   ^^^^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `correction` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:8\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |        ^^^^^^^^^^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:19\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                   ^^^^^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\n\nerror[unresolved-reference]: Name `Round` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:19\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                   ^^^^^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:25\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                         ^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\n\nerror[invalid-type-form]: Invalid binary operator `-` in type annotation\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:28\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                            ^^^^^^^^^^^^^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\ninfo: See the following page for a reference on valid type expressions:\ninfo: https://typing.python.org/en/latest/spec/annotations.html#type-and-annotation-expressions\ninfo: rule `invalid-type-form` is enabled by default\n\nerror[unresolved-reference]: Name `Re` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:28\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                            ^^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `evaluating` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:31\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                               ^^^^^^^^^^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:42\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                                          ^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\n\nerror[unresolved-reference]: Name `NewType` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:43\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                                           ^^^^^^^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:50\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                                                  ^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\n\nerror[unresolved-reference]: Name `example` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:52\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                                                    ^^^^^^^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:60\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                                                            ^^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\n\nerror[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:9:62\n   |\n 7 | # REASON: `NewType` creates a distinct nominal type, even though it's a runtime alias. `List` is invariant in Python's typing. Therefo\u2026\n 8 |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n   |                                                              ^\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |\n\nerror[unresolved-reference]: Name `The` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:1\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   | ^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:5\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |     ^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\n\nerror[unresolved-reference]: Name `NewType` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:6\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |      ^^^^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:13\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |             ^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\n\nerror[invalid-syntax]: Expected a statement\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:15\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |               ^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:19\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                   ^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\n\nerror[unresolved-reference]: Name `List` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:20\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                    ^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:24\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                        ^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\n\nerror[unresolved-reference]: Name `invariance` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:26\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                          ^^^^^^^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:37\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                     ^^^^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\n\nerror[unresolved-reference]: Name `example` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:37\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                     ^^^^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:45\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                             ^^^^^^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\n\nerror[unresolved-reference]: Name `correctly` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:45\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                             ^^^^^^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:55\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                       ^^^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\n\nerror[unresolved-reference]: Name `points` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:55\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                       ^^^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:62\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                              ^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\n\nerror[unresolved-reference]: Name `out` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:62\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                              ^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:66\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                                  ^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\n\nerror[unresolved-reference]: Name `that` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:66\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                                  ^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:71\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                                       ^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\n\nerror[unresolved-reference]: Name `it` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:71\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                                       ^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `should` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:75\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                                           ^^^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `error` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:83\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                                                   ^^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:89\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                                                         ^^^^^^^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\n\nerror[unresolved-reference]: Name `everywhere` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:89\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                                                         ^^^^^^^^^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `it` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:105\n   |\n 9 | **Self-correction Round 2: Re-evaluating `NewType` example.**\n10 |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n   |                                                                                                         ^^\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: missing closing quote in string literal\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:11:107\n   |\n 9 | \u2026\n10 | \u2026\n11 | \u2026d* error everywhere. So, it's not a divergence point. I need a different example for `NewType` divergence.\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n12 | \u2026\n13 | \u2026ral subtyping or methods of the base type when accessed via `NewType` variable.\n   |\n\nerror[unresolved-reference]: Name `A` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:1\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   | ^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:3\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |   ^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `common` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:3\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |   ^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:10\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |          ^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `subtle` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:10\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |          ^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:17\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                 ^^^^^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `divergence` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:17\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                 ^^^^^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:28\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                            ^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:32\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                ^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `NewType` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:33\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                 ^^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:40\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                        ^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[invalid-syntax]: Expected a statement\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:42\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                          ^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `around` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:45\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                             ^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:52\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                    ^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `its` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:52\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                    ^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:56\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                        ^^^^^^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `interaction` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:56\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                        ^^^^^^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:68\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                    ^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `structural` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:73\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                         ^^^^^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:84\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                    ^^^^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `subtyping` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:84\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                    ^^^^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `methods` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:97\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                                 ^^^^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:105\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                                         ^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `of` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:105\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                                         ^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:108\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                                            ^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `the` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:108\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                                            ^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:112\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                                                ^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `base` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:112\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                                                ^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found `type`\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:117\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                                                     ^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[invalid-context-manager]: Object of type `<class 'type'>` cannot be used with `with` because it does not implement `__enter__` and `__exit__`\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:117\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                                                     ^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `invalid-context-manager` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:122\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                                                          ^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `when` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:122\n   |\n11 | The `NewType` and `List` invariance example correctly points out that it *should* error everywhere. So, it's not a divergence point. I\u2026\n12 |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n   |                                                                                                                          ^^^^\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:127\n   |\n11 | \u2026 that it *should* error everywhere. So, it's not a divergence point. I need a different example for `NewType` divergence.\n12 | \u2026\n13 | \u2026on with structural subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                ^^^^^^^^\n14 | \u2026\n15 | \u2026ethods of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `accessed` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:127\n   |\n11 | \u2026 that it *should* error everywhere. So, it's not a divergence point. I need a different example for `NewType` divergence.\n12 | \u2026\n13 | \u2026on with structural subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                ^^^^^^^^\n14 | \u2026\n15 | \u2026ethods of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:136\n   |\n11 | \u2026it *should* error everywhere. So, it's not a divergence point. I need a different example for `NewType` divergence.\n12 | \u2026\n13 | \u2026h structural subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                   ^^^\n14 | \u2026\n15 | \u2026 of the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `via` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:136\n   |\n11 | \u2026it *should* error everywhere. So, it's not a divergence point. I need a different example for `NewType` divergence.\n12 | \u2026\n13 | \u2026h structural subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                   ^^^\n14 | \u2026\n15 | \u2026 of the base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:140\n   |\n11 | \u2026*should* error everywhere. So, it's not a divergence point. I need a different example for `NewType` divergence.\n12 | \u2026\n13 | \u2026tructural subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                    ^\n14 | \u2026\n15 | \u2026 the base type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `NewType` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:141\n   |\n11 | \u2026uld* error everywhere. So, it's not a divergence point. I need a different example for `NewType` divergence.\n12 | \u2026\n13 | \u2026tural subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                 ^^^^^^^\n14 | \u2026\n15 | \u2026 base type on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:148\n   |\n11 | \u2026 error everywhere. So, it's not a divergence point. I need a different example for `NewType` divergence.\n12 | \u2026\n13 | \u2026l subtyping or methods of the base type when accessed via `NewType` variable.\n   |                                                                    ^\n14 | \u2026\n15 | \u2026e type on a `NewType` instance.\n   |\n\nerror[unresolved-reference]: Name `variable` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:150\n   |\n11 | \u2026 everywhere. So, it's not a divergence point. I need a different example for `NewType` divergence.\n12 | \u2026\n13 | \u2026yping or methods of the base type when accessed via `NewType` variable.\n   |                                                                ^^^^^^^^\n14 | \u2026\n15 | \u2026 on a `NewType` instance.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:13:159\n   |\n11 | \u2026ywhere. So, it's not a divergence point. I need a different example for `NewType` divergence.\n12 | \u2026\n13 | \u2026 or methods of the base type when accessed via `NewType` variable.\n   |                                                                    ^\n14 | \u2026\n15 | \u2026 `NewType` instance.\n   |\n\nerror[invalid-syntax]: Expected an indented block after `with` statement\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:1\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   | ^^\n   |\n\nerror[unresolved-reference]: Name `New` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:3\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |   ^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:7\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |       ^^^^\n   |\n\nerror[unresolved-reference]: Name `idea` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:7\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |       ^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:12\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |            ^^^\n   |\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:16\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                ^\n   |\n\nerror[unresolved-reference]: Name `NewType` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:17\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                 ^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:24\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                        ^\n   |\n\nerror[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:37\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                     ^^\n   |\n\nerror[invalid-type-form]: Invalid binary operator `**` in type annotation\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:37\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                     ^^^^^^^^^^^^\n   |\ninfo: See the following page for a reference on valid type expressions:\ninfo: https://typing.python.org/en/latest/spec/annotations.html#type-and-annotation-expressions\ninfo: rule `invalid-type-form` is enabled by default\n\nerror[unresolved-reference]: Name `Accessing` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:40\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                        ^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:50\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                  ^^^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `attributes` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:50\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                  ^^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `methods` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:64\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                ^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:72\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                        ^^\n   |\n\nerror[unresolved-reference]: Name `of` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:72\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                        ^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:75\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                           ^^^\n   |\n\nerror[unresolved-reference]: Name `the` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:75\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                           ^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:79\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                               ^^^^\n   |\n\nerror[unresolved-reference]: Name `base` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:79\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                               ^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:84\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                    ^^^^\n   |\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:89\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                         ^^\n   |\n\nerror[unresolved-reference]: Name `on` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:89\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                         ^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:92\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                            ^\n   |\n\nerror[unresolved-reference]: Name `a` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:92\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                            ^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:94\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                              ^\n   |\n\nerror[unresolved-reference]: Name `NewType` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:95\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                               ^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:102\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                                      ^\n   |\n\nerror[unresolved-reference]: Name `instance` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:104\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                                        ^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/newtype-list-covariance.py:15:113\n   |\n13 | A common subtle divergence for `NewType` is around its interaction with structural subtyping or methods of the base type when accessed\u2026\n14 |\n15 | **New idea for `NewType` divergence:** Accessing attributes or methods of the base type on a `NewType` instance.\n   |                                                                                                                 ^\n   |\n\nFound 113 diagnostics"
            }
        },
        {
            "filename": "overload-literal-discrimination.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:12: error: Overloaded function signatures 1 and 3 overlap with incompatible return types  [overload-overlap]\ngenerated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:14: error: Overloaded function signatures 2 and 3 overlap with incompatible return types  [overload-overlap]\ngenerated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:30: note: Revealed type is \"builtins.bool\"\ngenerated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:31: note: Revealed type is \"builtins.bool\"\ngenerated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:32: note: Revealed type is \"builtins.str\"\nFound 2 errors in 1 file (checked 1 source file)",
                "pyrefly": "ERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:30:5\n   |\n30 |     reveal_type(result1) # Divergence point\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: bool [reveal-type]\n  --> generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:30:16\n   |\n30 |     reveal_type(result1) # Divergence point\n   |                ---------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:31:5\n   |\n31 |     reveal_type(result2) # Divergence point\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: bool [reveal-type]\n  --> generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:31:16\n   |\n31 |     reveal_type(result2) # Divergence point\n   |                ---------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:32:5\n   |\n32 |     reveal_type(result3) # Should be str everywhere\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: str [reveal-type]\n  --> generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:32:16\n   |\n32 |     reveal_type(result3) # Should be str everywhere\n   |                ---------\n   |\n\n[STDERR]\n INFO 3 errors",
                "zuban": "generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:30: note: Revealed type is \"builtins.bool\"\ngenerated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:31: note: Revealed type is \"builtins.bool\"\ngenerated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:32: note: Revealed type is \"builtins.str\"\nSuccess: no issues found in 1 source file",
                "ty": "warning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:30:5\n   |\n28 |     result3 = parse_value(\"other_string\")\n29 |\n30 |     reveal_type(result1) # Divergence point\n   |     ^^^^^^^^^^^\n31 |     reveal_type(result2) # Divergence point\n32 |     reveal_type(result3) # Should be str everywhere\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:30:17\n   |\n28 |     result3 = parse_value(\"other_string\")\n29 |\n30 |     reveal_type(result1) # Divergence point\n   |                 ^^^^^^^ `bool`\n31 |     reveal_type(result2) # Divergence point\n32 |     reveal_type(result3) # Should be str everywhere\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:31:5\n   |\n30 |     reveal_type(result1) # Divergence point\n31 |     reveal_type(result2) # Divergence point\n   |     ^^^^^^^^^^^\n32 |     reveal_type(result3) # Should be str everywhere\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:31:17\n   |\n30 |     reveal_type(result1) # Divergence point\n31 |     reveal_type(result2) # Divergence point\n   |                 ^^^^^^^ `bool`\n32 |     reveal_type(result3) # Should be str everywhere\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:32:5\n   |\n30 |     reveal_type(result1) # Divergence point\n31 |     reveal_type(result2) # Divergence point\n32 |     reveal_type(result3) # Should be str everywhere\n   |     ^^^^^^^^^^^\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2026-01-13_20-13-14/source_files/overload-literal-discrimination.py:32:17\n   |\n30 |     reveal_type(result1) # Divergence point\n31 |     reveal_type(result2) # Divergence point\n32 |     reveal_type(result3) # Should be str everywhere\n   |                 ^^^^^^^ `str`\n   |\n\nFound 6 diagnostics"
            }
        },
        {
            "filename": "typeguard-generic-list-narrowing.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/typeguard-generic-list-narrowing.py",
            "outputs": {
                "mypy": "Success: no issues found in 1 source file",
                "pyrefly": "[STDERR]\n INFO 0 errors",
                "zuban": "Success: no issues found in 1 source file",
                "ty": "All checks passed!"
            }
        },
        {
            "filename": "typeddict-required-notrequired-total-false.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:43: error: Missing key \"additional\" for TypedDict \"DetailedConfig\"  [typeddict-item]\ngenerated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:50: note: Revealed type is \"builtins.int | None\"\ngenerated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:51: note: Revealed type is \"builtins.bool | None\"\nFound 1 error in 1 file (checked 1 source file)",
                "pyrefly": "ERROR Missing required key `additional` for TypedDict `DetailedConfig` [bad-typed-dict-key]\n  --> generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:43:31\n   |\n43 |     config1: DetailedConfig = {'y': 'required_y', 'z': True, 'common_prop': 'base'}\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:50:5\n   |\n50 |     reveal_type(config3.get('x')) # Type checker will show its interpretation here\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: int | None [reveal-type]\n  --> generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:50:16\n   |\n50 |     reveal_type(config3.get('x')) # Type checker will show its interpretation here\n   |                ------------------\n   |\nERROR `reveal_type` must be imported from `typing` for runtime usage [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:51:5\n   |\n51 |     reveal_type(config1.get('z'))\n   |     ^^^^^^^^^^^\n   |\n INFO revealed type: bool | None [reveal-type]\n  --> generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:51:16\n   |\n51 |     reveal_type(config1.get('z'))\n   |                ------------------\n   |\n\n[STDERR]\n INFO 3 errors",
                "zuban": "generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:43: error: Missing key \"additional\" for TypedDict \"DetailedConfig\"  [typeddict-item]\ngenerated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:50: note: Revealed type is \"builtins.int | None\"\ngenerated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:51: note: Revealed type is \"builtins.bool | None\"\nFound 1 errors in 1 file (checked 1 source file)",
                "ty": "error[missing-typed-dict-key]: Missing required key 'additional' in TypedDict `DetailedConfig` constructor\n  --> generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:43:31\n   |\n42 | if __name__ == \"__main__\":\n43 |     config1: DetailedConfig = {'y': 'required_y', 'z': True, 'common_prop': 'base'}\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n44 |     # config2: DetailedConfig = {'y': 'required_y'} # Should error for missing 'additional' and 'common_prop' implicitly\n45 |     config3: DetailedConfig = {'y': 'another', 'x': 100, 'additional': 'info', 'common_prop': 'more'}\n   |\ninfo: rule `missing-typed-dict-key` is enabled by default\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:50:5\n   |\n48 |     # The divergence is subtle about `Optional[int]` vs `Union[int, None]` or even `Any` in older versions.\n49 |     # The primary divergence is in how explicitly `None` is included in the type if the key is optional.\n50 |     reveal_type(config3.get('x')) # Type checker will show its interpretation here\n   |     ^^^^^^^^^^^\n51 |     reveal_type(config1.get('z'))\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:50:17\n   |\n48 |     # The divergence is subtle about `Optional[int]` vs `Union[int, None]` or even `Any` in older versions.\n49 |     # The primary divergence is in how explicitly `None` is included in the type if the key is optional.\n50 |     reveal_type(config3.get('x')) # Type checker will show its interpretation here\n   |                 ^^^^^^^^^^^^^^^^ `int | None`\n51 |     reveal_type(config1.get('z'))\n   |\n\nwarning[undefined-reveal]: `reveal_type` used without importing it\n  --> generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:51:5\n   |\n49 |     # The primary divergence is in how explicitly `None` is included in the type if the key is optional.\n50 |     reveal_type(config3.get('x')) # Type checker will show its interpretation here\n51 |     reveal_type(config1.get('z'))\n   |     ^^^^^^^^^^^\n   |\ninfo: This is allowed for debugging convenience but will fail at runtime\ninfo: rule `undefined-reveal` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> generated_examples/2026-01-13_20-13-14/source_files/typeddict-required-notrequired-total-false.py:51:17\n   |\n49 |     # The primary divergence is in how explicitly `None` is included in the type if the key is optional.\n50 |     reveal_type(config3.get('x')) # Type checker will show its interpretation here\n51 |     reveal_type(config1.get('z'))\n   |                 ^^^^^^^^^^^^^^^^ `bool | None`\n   |\n\nFound 5 diagnostics"
            }
        },
        {
            "filename": "paramspec-decorator-classmethod.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/paramspec-decorator-classmethod.py",
            "outputs": {
                "mypy": "Success: no issues found in 1 source file",
                "pyrefly": "[STDERR]\n INFO 0 errors",
                "zuban": "Success: no issues found in 1 source file",
                "ty": "error[unresolved-attribute]: Object of type `(**P@log_calls) -> T@log_calls` has no attribute `__qualname__`\n  --> generated_examples/2026-01-13_20-13-14/source_files/paramspec-decorator-classmethod.py:18:26\n   |\n16 |     \"\"\"A simple decorator that logs calls, preserving the original signature.\"\"\"\n17 |     def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n18 |         print(f\"Calling {func.__qualname__} with args={args}, kwargs={kwargs}\")\n   |                          ^^^^^^^^^^^^^^^^^\n19 |         return func(*args, **kwargs)\n20 |     return wrapper\n   |\ninfo: rule `unresolved-attribute` is enabled by default\n\nerror[missing-argument]: No argument provided for required parameter `name`\n  --> generated_examples/2026-01-13_20-13-14/source_files/paramspec-decorator-classmethod.py:43:10\n   |\n41 |     # The divergence occurs here: does `create`'s signature, including `cls`,\n42 |     # correctly pass through the decorator?\n43 |     s1 = Service.create(\"AuthService\")\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n44 |     s2 = Service.create(name=\"UserService\")\n45 |     print(s1.describe())\n   |\ninfo: Union variant `(cls, name: str) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, name: str) -> Unknown) | ((cls, name: Divergent) -> Unknown)`\ninfo: rule `missing-argument` is enabled by default\n\nerror[missing-argument]: No argument provided for required parameter `name`\n  --> generated_examples/2026-01-13_20-13-14/source_files/paramspec-decorator-classmethod.py:43:10\n   |\n41 |     # The divergence occurs here: does `create`'s signature, including `cls`,\n42 |     # correctly pass through the decorator?\n43 |     s1 = Service.create(\"AuthService\")\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n44 |     s2 = Service.create(name=\"UserService\")\n45 |     print(s1.describe())\n   |\ninfo: Union variant `(cls, name: Divergent) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, name: str) -> Unknown) | ((cls, name: Divergent) -> Unknown)`\ninfo: rule `missing-argument` is enabled by default\n\nerror[invalid-argument-type]: Argument is incorrect\n  --> generated_examples/2026-01-13_20-13-14/source_files/paramspec-decorator-classmethod.py:43:25\n   |\n41 |     # The divergence occurs here: does `create`'s signature, including `cls`,\n42 |     # correctly pass through the decorator?\n43 |     s1 = Service.create(\"AuthService\")\n   |                         ^^^^^^^^^^^^^ Expected `Self@create`, found `Literal[\"AuthService\"]`\n44 |     s2 = Service.create(name=\"UserService\")\n45 |     print(s1.describe())\n   |\ninfo: Union variant `(cls, name: Divergent) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, name: str) -> Unknown) | ((cls, name: Divergent) -> Unknown)`\ninfo: rule `invalid-argument-type` is enabled by default\n\nerror[missing-argument]: No argument provided for required parameter `cls`\n  --> generated_examples/2026-01-13_20-13-14/source_files/paramspec-decorator-classmethod.py:44:10\n   |\n42 |     # correctly pass through the decorator?\n43 |     s1 = Service.create(\"AuthService\")\n44 |     s2 = Service.create(name=\"UserService\")\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n45 |     print(s1.describe())\n   |\ninfo: Union variant `(cls, name: str) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, name: str) -> Unknown) | ((cls, name: Divergent) -> Unknown)`\ninfo: rule `missing-argument` is enabled by default\n\nerror[missing-argument]: No argument provided for required parameter `cls`\n  --> generated_examples/2026-01-13_20-13-14/source_files/paramspec-decorator-classmethod.py:44:10\n   |\n42 |     # correctly pass through the decorator?\n43 |     s1 = Service.create(\"AuthService\")\n44 |     s2 = Service.create(name=\"UserService\")\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n45 |     print(s1.describe())\n   |\ninfo: Union variant `(cls, name: Divergent) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, name: str) -> Unknown) | ((cls, name: Divergent) -> Unknown)`\ninfo: rule `missing-argument` is enabled by default\n\nFound 6 diagnostics"
            }
        },
        {
            "filename": "self-in-generics-abstract-method.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/self-in-generics-abstract-method.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_20-13-14/source_files/self-in-generics-abstract-method.py:38: error: Self type is only allowed in annotations within class definition  [misc]\nFound 1 error in 1 file (checked 1 source file)",
                "pyrefly": "ERROR Returned type `AbstractFactory[Any]` is not assignable to declared return type `Self` [bad-return]\n  --> generated_examples/2026-01-13_20-13-14/source_files/self-in-generics-abstract-method.py:40:12\n   |\n40 |     return factory.create()\n   |            ^^^^^^^^^^^^^^^^\n   |\nERROR `Self` is not assignable to `IntFactory` [bad-assignment]\n  --> generated_examples/2026-01-13_20-13-14/source_files/self-in-generics-abstract-method.py:49:27\n   |\n49 |     result2: IntFactory = use_factory(int_factory_instance) # And this\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n\n[STDERR]\n INFO 2 errors",
                "zuban": "generated_examples/2026-01-13_20-13-14/source_files/self-in-generics-abstract-method.py:38: error: Self type is only allowed in annotations within class definition  [misc]\nFound 1 error in 1 file (checked 1 source file)",
                "ty": "error[invalid-type-form]: Variable of type `<special form 'typing.Self'>` is not allowed in a type expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/self-in-generics-abstract-method.py:38:51\n   |\n36 |         return self\n37 |\n38 | def use_factory(factory: AbstractFactory[Any]) -> Self:\n   |                                                   ^^^^\n39 |     \"\"\"Consumes an abstract factory and returns a factory instance.\"\"\"\n40 |     return factory.create()\n   |\ninfo: rule `invalid-type-form` is enabled by default\n\nFound 1 diagnostic"
            }
        },
        {
            "filename": "protocol-default-arg-compatibility.py",
            "filepath": "generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26: error: Invalid syntax  [syntax]\nFound 1 error in 1 file (errors prevented further checking)",
                "pyrefly": "ERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:1\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   | ^^\n   |\nERROR Could not find name `Self` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:3\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |   ^^^^\n   |\nERROR Could not find name `correction` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:8\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |        ^^^^^^^^^^\n   |\nERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:19\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                   ^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:26\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                          ^^^^^\n   |\nERROR Could not find name `above` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:26\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                          ^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:32\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                                ^^^^^^^\n   |\nERROR Could not find name `example` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:32\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                                ^^^^^^^\n   |\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:40\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                                        ^^^\n   |\nERROR Parse error: Invalid assignment target [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:44\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\nERROR Could not find name `a` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:81\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                                                                                 ^\n   |\nERROR Parse error: Expected `in`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:83\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                                                                                   ^^^^^^^\n   |\nERROR Could not find name `classic` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:83\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                                                                                   ^^^^^^^\n   |\nERROR Could not find name `misconception` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:92\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                                                                                            ^^^^^^^^^^^^^\n   |\nERROR Could not find name `about` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:107\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                                                                                                           ^^^^^\n   |\nERROR Parse error: Expected `:`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:113\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                                                                                                                 ^^^^^^^^^^\n   |\nERROR Could not find name `divergence` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:113\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted...\n   |                                                                                                                 ^^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:128\n   |\n26 | ... arguments\" is a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge o...\n   |                                                                  ^^^^^\n   |\nERROR Could not find name `noted` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:128\n   |\n26 | ... arguments\" is a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge o...\n   |                                                                  ^^^^^\n   |\n  Did you mean `sorted`?\nERROR Could not find name `the` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:137\n   |\n26 | ...ts\" is a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on differ...\n   |                                                                   ^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:141\n   |\n26 | ... is a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different...\n   |                                                                    ^\n   |\nERROR Could not find name `REASON` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:142\n   |\n26 | ...a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different def...\n   |                                                                 ^^^^^^\n   |\nERROR Parse error: Got unexpected token ` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:148\n   |\n26 | ...lassic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different defaul...\n   |                                                                    ^\n   |\nERROR Parse error: Expected a statement [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:149\n   |\n26 | ...assic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default...\n   |                                                                    ^\n   |\nERROR Could not find name `most` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:151\n   |\n26 | ...c *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *va...\n   |                                                                  ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:156\n   |\n26 | ...conception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* ...\n   |                                                                 ^^^^^^\n   |\nERROR Could not find name `modern` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:156\n   |\n26 | ...conception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* ...\n   |                                                                 ^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:163\n   |\n26 | ...tion* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for th...\n   |                                                                  ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:168\n   |\n26 | ...bout divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same ...\n   |                                                                ^^^^^^^^\n   |\nERROR Could not find name `checkers` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:168\n   |\n26 | ...bout divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same ...\n   |                                                                ^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:177\n   |\n26 | ...ivergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same option...\n   |                                                                   ^^\n   |\nERROR Could not find name `do` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:177\n   |\n26 | ...ivergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same option...\n   |                                                                   ^^\n   |\nERROR Parse error: Boolean 'not' expression cannot be used here [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:181\n   |\n26 | .... As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parame...\n   |                                                              ^^^^^^^^^^^^\n   |\nERROR TODO: __bool__ attribute base undefined for type: *Unknown (trying to access __bool__) [internal-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:181\n   |\n26 | .... As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parame...\n   |                                                              ^^^^^^^^^^^^\n   |\nERROR Parse error: Starred expression cannot be used here [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:184\n   |\n26 | ... As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional paramet...\n   |                                                                ^^^^^^^^^\n   |\nERROR Could not find name `diverge` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:186\n   |\n26 | ...As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional paramete...\n   |                                                                 ^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:194\n   |\n26 | ...ed in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter. The...\n   |                                                                   ^^\n   |\nERROR Could not find name `on` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:194\n   |\n26 | ...ed in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter. The...\n   |                                                                   ^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:197\n   |\n26 | ...the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter. They typi...\n   |                                                                ^^^^^^^^^\n   |\nERROR Could not find name `different` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:197\n   |\n26 | ...the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter. They typi...\n   |                                                                ^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:207\n   |\n26 | ...ON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter. They typically onl...\n   |                                                                 ^^^^^^^\n   |\nERROR Could not find name `default` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:207\n   |\n26 | ...ON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter. They typically onl...\n   |                                                                 ^^^^^^^\n   |\nERROR Could not find name `values` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:216\n   |\n26 | ... modern type checkers do *not* diverge on different default *values* for the same optional parameter. They typically only care ab...\n   |                                                                 ^^^^^^\n   |\nERROR Parse error: Expected an identifier, but found a keyword `for` that cannot be used here [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:224\n   |\n26 | ...n type checkers do *not* diverge on different default *values* for the same optional parameter. They typically only care about wh...\n   |                                                                   ^^^\n   |\nERROR Could not find name `for` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:224\n   |\n26 | ...n type checkers do *not* diverge on different default *values* for the same optional parameter. They typically only care about wh...\n   |                                                                   ^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:228\n   |\n26 | ...pe checkers do *not* diverge on different default *values* for the same optional parameter. They typically only care about whethe...\n   |                                                                   ^^^\n   |\nERROR Could not find name `the` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:228\n   |\n26 | ...pe checkers do *not* diverge on different default *values* for the same optional parameter. They typically only care about whethe...\n   |                                                                   ^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:232\n   |\n26 | ...eckers do *not* diverge on different default *values* for the same optional parameter. They typically only care about whether an ...\n   |                                                                  ^^^^\n   |\nERROR Could not find name `same` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:232\n   |\n26 | ...eckers do *not* diverge on different default *values* for the same optional parameter. They typically only care about whether an ...\n   |                                                                  ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:237\n   |\n26 | ...do *not* diverge on different default *values* for the same optional parameter. They typically only care about whether an argumen...\n   |                                                                ^^^^^^^^\n   |\nERROR Could not find name `optional` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:237\n   |\n26 | ...do *not* diverge on different default *values* for the same optional parameter. They typically only care about whether an argumen...\n   |                                                                ^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:246\n   |\n26 | ...diverge on different default *values* for the same optional parameter. They typically only care about whether an argument is pres...\n   |                                                                ^^^^^^^^^\n   |\nERROR Could not find name `parameter` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:246\n   |\n26 | ...diverge on different default *values* for the same optional parameter. They typically only care about whether an argument is pres...\n   |                                                                ^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:262\n   |\n26 | ...rent default *values* for the same optional parameter. They typically only care about whether an argument is present, its type, a...\n   |                                                                ^^^^^^^^^\n   |\nERROR Could not find name `typically` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:262\n   |\n26 | ...rent default *values* for the same optional parameter. They typically only care about whether an argument is present, its type, a...\n   |                                                                ^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:272\n   |\n26 | ...ault *values* for the same optional parameter. They typically only care about whether an argument is present, its type, and its o...\n   |                                                                  ^^^^\n   |\nERROR Could not find name `only` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:272\n   |\n26 | ...ault *values* for the same optional parameter. They typically only care about whether an argument is present, its type, and its o...\n   |                                                                  ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:277\n   |\n26 | ...*values* for the same optional parameter. They typically only care about whether an argument is present, its type, and its option...\n   |                                                                  ^^^^\n   |\nERROR Could not find name `care` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:277\n   |\n26 | ...*values* for the same optional parameter. They typically only care about whether an argument is present, its type, and its option...\n   |                                                                  ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:282\n   |\n26 | ...es* for the same optional parameter. They typically only care about whether an argument is present, its type, and its optionality...\n   |                                                                  ^^^^^\n   |\nERROR Could not find name `about` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:282\n   |\n26 | ...es* for the same optional parameter. They typically only care about whether an argument is present, its type, and its optionality...\n   |                                                                  ^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:288\n   |\n26 | ... the same optional parameter. They typically only care about whether an argument is present, its type, and its optionality. I nee...\n   |                                                                 ^^^^^^^\n   |\nERROR Could not find name `whether` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:288\n   |\n26 | ... the same optional parameter. They typically only care about whether an argument is present, its type, and its optionality. I nee...\n   |                                                                 ^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:296\n   |\n26 | ...ame optional parameter. They typically only care about whether an argument is present, its type, and its optionality. I need to f...\n   |                                                                   ^^\n   |\nERROR Could not find name `an` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:296\n   |\n26 | ...ame optional parameter. They typically only care about whether an argument is present, its type, and its optionality. I need to f...\n   |                                                                   ^^\n   |\n  Did you mean `any`?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:299\n   |\n26 | ...tional parameter. They typically only care about whether an argument is present, its type, and its optionality. I need to find a ...\n   |                                                                ^^^^^^^^\n   |\nERROR Could not find name `argument` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:299\n   |\n26 | ...tional parameter. They typically only care about whether an argument is present, its type, and its optionality. I need to find a ...\n   |                                                                ^^^^^^^^\n   |\nERROR Could not find name `present` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:311\n   |\n26 | ...meter. They typically only care about whether an argument is present, its type, and its optionality. I need to find a *real* dive...\n   |                                                                 ^^^^^^^\n   |\nERROR Could not find name `its` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:320\n   |\n26 | ...They typically only care about whether an argument is present, its type, and its optionality. I need to find a *real* divergence ...\n   |                                                                   ^^^\n   |\nERROR Parse error: Expected `,`, found `type` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:324\n   |\n26 | ...typically only care about whether an argument is present, its type, and its optionality. I need to find a *real* divergence for t...\n   |                                                                  ^^^^\n   |\nERROR Parse error: Expected `,`, found `and` [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:330\n   |\n26 | ...ally only care about whether an argument is present, its type, and its optionality. I need to find a *real* divergence for this c...\n   |                                                                   ^^^\n   |\nERROR Could not find name `its` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:334\n   |\n26 | ... only care about whether an argument is present, its type, and its optionality. I need to find a *real* divergence for this categ...\n   |                                                                   ^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:338\n   |\n26 | ...re about whether an argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                               ^^^^^^^^^^^\n   |\nERROR Could not find name `optionality` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:338\n   |\n26 | ...re about whether an argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                               ^^^^^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:353\n   |\n26 | ...ther an argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                  ^^^^\n   |\nERROR Could not find name `need` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:353\n   |\n26 | ...ther an argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                  ^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:358\n   |\n26 | ... an argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                   ^^\n   |\nERROR Could not find name `to` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:358\n   |\n26 | ... an argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                   ^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:361\n   |\n26 | ...argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                  ^^^^\n   |\nERROR Could not find name `find` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:361\n   |\n26 | ...argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                  ^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:366\n   |\n26 | ...ument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                    ^\n   |\nERROR Could not find name `a` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:366\n   |\n26 | ...ument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                    ^\n   |\nERROR Could not find name `real` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:369\n   |\n26 | ... is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                  ^^^^\n   |\nERROR Could not find name `divergence` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:375\n   |\n26 | ...nt, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                               ^^^^^^^^^^\n   |\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:386\n   |\n26 | ... type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                   ^^^\n   |\nERROR Parse error: Expected `in`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:395\n   |\n26 | ...ts optionality. I need to find a *real* divergence for this category.\n   |                                                                ^^^^^^^^\n   |\nERROR Could not find name `category` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:395\n   |\n26 | ...ts optionality. I need to find a *real* divergence for this category.\n   |                                                                ^^^^^^^^\n   |\nERROR Parse error: Expected an identifier [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:404\n   |\n26 | ...tionality. I need to find a *real* divergence for this category.\n   |                                                                    ^\n27 | ...\n   |\nERROR Parse error: Expected an indented block after `for` statement [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:1\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   | ^\n   |\nERROR Could not find name `A` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:1\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   | ^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:3\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |   ^^^^^\n   |\nERROR Could not find name `known` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:3\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |   ^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:9\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |         ^^^^^^^^^^\n   |\nERROR Could not find name `divergence` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:9\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |         ^^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:28\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                            ^^^^\n   |\nERROR Could not find name `area` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:28\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                            ^^^^\n   |\nERROR Could not find name `when` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:36\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                    ^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:41\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                         ^\n   |\nERROR Could not find name `a` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:41\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                         ^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:43\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                           ^^^^^^^^\n   |\nERROR Could not find name `protocol` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:43\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                           ^^^^^^^^\n   |\n  Did you mean `Protocol`?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:52\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                    ^^^^^^^^^\n   |\nERROR Could not find name `specifies` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:52\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                    ^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:62\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                              ^^\n   |\nERROR Could not find name `an` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:62\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                              ^^\n   |\n  Did you mean `any`?\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:65\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                                 ^^^^^^^^\n   |\nERROR Could not find name `optional` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:65\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                                 ^^^^^^^^\n   |\nERROR Could not find name `defaulted` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:75\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                                           ^^^^^^^^^\n   |\nERROR Parse error: Simple statements must be separated by newlines or semicolons [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:86\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                                                      ^^^^^^^^^\n   |\nERROR Could not find name `parameter` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:86\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                                                      ^^^^^^^^^\n   |\nERROR Could not find name `but` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:97\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                                                                 ^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:101\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                                                                     ^^^\n   |\nERROR Could not find name `the` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:101\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                                                                     ^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:105\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                                                                         ^^^^^^^^^^^^^^\n   |\nERROR Could not find name `implementation` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:105\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                                                                         ^^^^^^^^^^^^^^\n   |\nERROR Could not find name `omits` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:121\n   |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the d...\n   |                                                                                                                         ^^^^^\n   |\nERROR Could not find name `the` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:128\n   |\n28 | ...optional (defaulted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                   ^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:132\n   |\n28 | ...al (defaulted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                 ^^^^^^^\n   |\nERROR Could not find name `default` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:132\n   |\n28 | ...al (defaulted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                 ^^^^^^^\n   |\nERROR Could not find name `making` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:141\n   |\n28 | ...lted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                 ^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:148\n   |\n28 | ... parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                   ^^\n   |\nERROR Could not find name `it` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:148\n   |\n28 | ... parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                   ^^\n   |\n  Did you mean `int`?\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:151\n   |\n28 | ...arameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                    ^\n   |\nERROR Could not find name `a` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:151\n   |\n28 | ...arameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                    ^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:153\n   |\n28 | ...er, but the implementation *omits* the default, making it a required parameter.\n   |                                                                ^^^^^^^^\n   |\nERROR Could not find name `required` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:153\n   |\n28 | ...er, but the implementation *omits* the default, making it a required parameter.\n   |                                                                ^^^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:162\n   |\n28 | ...he implementation *omits* the default, making it a required parameter.\n   |                                                                ^^^^^^^^^\n   |\nERROR Could not find name `parameter` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:162\n   |\n28 | ...he implementation *omits* the default, making it a required parameter.\n   |                                                                ^^^^^^^^^\n   |\nERROR Parse error: Expected an identifier [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:172\n   |\n28 | ...lementation *omits* the default, making it a required parameter.\n   |                                                                    ^\n29 | ...\n   |\nERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:1\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   | ^^\n   |\nERROR Could not find name `Re` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:3\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |   ^^\n   |\nERROR Could not find name `evaluating` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:6\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |      ^^^^^^^^^^\n   |\nERROR Could not find name `generating` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:21\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                     ^^^^^^^^^^\n   |\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:32\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                ^^^\n   |\nERROR Parse error: Expected `in`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:41\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                         ^^^^^^^^^^\n   |\nERROR Could not find name `divergence` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:41\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                         ^^^^^^^^^^\n   |\nERROR Parse error: Expected `:`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:52\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                    ^^^^^\n   |\nERROR Could not find name `point` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:52\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                    ^^^^^\n   |\n  Did you mean `print`?\nERROR Parse error: Compound statements are not allowed on the same line as simple statements [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:58\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                          ^^^^\n   |\nERROR Could not find name `known` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:63\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                               ^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:69\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                                     ^^^^^^\n   |\nERROR Could not find name `actual` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:69\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                                     ^^^^^^\n   |\nERROR Parse error: Expected `,`, found name [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:76\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                                            ^^^^^^^^^^^\n   |\nERROR Could not find name `divergences` [unknown-name]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:76\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                                            ^^^^^^^^^^^\n   |\nERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:88\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                                                        ^^\n   |\nERROR Parse error: Expected an expression [parse-error]\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:90\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                                                          ^\n   |\n\n[STDERR]\n INFO 146 errors",
                "zuban": "generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28: error: Invalid syntax  [syntax]\ngenerated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31: error: Invalid syntax  [syntax]\nFound 3 errors in 1 file (checked 1 source file)",
                "ty": "error[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:1\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   | ^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\n\nerror[unresolved-reference]: Name `Self` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:3\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |   ^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `correction` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:8\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |        ^^^^^^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:19\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                   ^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\n\nerror[invalid-type-form]: Invalid binary operator `**` in type annotation\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:19\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                   ^^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\ninfo: See the following page for a reference on valid type expressions:\ninfo: https://typing.python.org/en/latest/spec/annotations.html#type-and-annotation-expressions\ninfo: rule `invalid-type-form` is enabled by default\n\nerror[unresolved-reference]: Name `The` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:22\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                      ^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:26\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                          ^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\n\nerror[unresolved-reference]: Name `above` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:26\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                          ^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:32\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                                ^^^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\n\nerror[unresolved-reference]: Name `example` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:32\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                                ^^^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:40\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                                        ^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\n\nerror[invalid-syntax]: Invalid assignment target\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:44\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\n\nerror[unresolved-reference]: Name `a` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:81\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                                                                                 ^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `in`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:83\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                                                                                   ^^^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\n\nerror[unresolved-reference]: Name `classic` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:83\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                                                                                   ^^^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `misconception` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:92\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                                                                                            ^^^^^^^^^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `about` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:107\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                                                                                                           ^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `:`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:113\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                                                                                                                 ^^^^^^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\n\nerror[unresolved-reference]: Name `divergence` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:113\n   |\n24 |     use_reader(file_reader)\n25 |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n   |                                                                                                                 ^^^^^^^^^^\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:128\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026lt arguments\" is a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on \u2026\n   |                                                                  ^^^^^\n27 | \u2026\n28 | \u2026 optional (defaulted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |\n\nerror[unresolved-reference]: Name `noted` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:128\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026lt arguments\" is a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on \u2026\n   |                                                                  ^^^^^\n27 | \u2026\n28 | \u2026 optional (defaulted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `the` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:137\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026ents\" is a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on differen\u2026\n   |                                                                   ^^^\n27 | \u2026\n28 | \u2026l (defaulted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:141\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026s\" is a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different d\u2026\n   |                                                                    ^\n27 | \u2026\n28 | \u2026defaulted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |\n\nerror[unresolved-reference]: Name `REASON` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:142\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026s a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different defau\u2026\n   |                                                                 ^^^^^^\n27 | \u2026\n28 | \u2026ulted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Got unexpected token `\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:148\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026 classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default \u2026\n   |                                                                    ^\n27 | \u2026\n28 | \u2026ed) parameter, but the implementation *omits* the default, making it a required parameter.\n   |\n\nerror[invalid-syntax]: Expected a statement\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:149\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *\u2026\n   |                                                                    ^\n27 | \u2026\n28 | \u2026d) parameter, but the implementation *omits* the default, making it a required parameter.\n   |\n\nerror[unresolved-reference]: Name `most` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:151\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026sic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *valu\u2026\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026arameter, but the implementation *omits* the default, making it a required parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:156\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026isconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* fo\u2026\n   |                                                                 ^^^^^^\n27 | \u2026\n28 | \u2026er, but the implementation *omits* the default, making it a required parameter.\n   |\n\nerror[unresolved-reference]: Name `modern` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:156\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026isconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* fo\u2026\n   |                                                                 ^^^^^^\n27 | \u2026\n28 | \u2026er, but the implementation *omits* the default, making it a required parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:163\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026eption* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the \u2026\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026t the implementation *omits* the default, making it a required parameter.\n   |\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:168\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026 about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same op\u2026\n   |                                                                ^^^^^^^^\n27 | \u2026\n28 | \u2026mplementation *omits* the default, making it a required parameter.\n   |\n\nerror[unresolved-reference]: Name `checkers` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:168\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026 about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same op\u2026\n   |                                                                ^^^^^^^^\n27 | \u2026\n28 | \u2026mplementation *omits* the default, making it a required parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:177\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026 divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional\u2026\n   |                                                                   ^^\n27 | \u2026\n28 | \u2026ntation *omits* the default, making it a required parameter.\n   |\n\nerror[unresolved-reference]: Name `do` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:177\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026 divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional\u2026\n   |                                                                   ^^\n27 | \u2026\n28 | \u2026ntation *omits* the default, making it a required parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Boolean 'not' expression cannot be used here\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:181\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026ce. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional paramete\u2026\n   |                                                              ^^^^^^^^^^^^\n27 | \u2026\n28 | \u2026omits* the default, making it a required parameter.\n   |\n\nerror[invalid-syntax]: Starred expression cannot be used here\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:184\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026e. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter\u2026\n   |                                                                ^^^^^^^^^\n27 | \u2026\n28 | \u2026mits* the default, making it a required parameter.\n   |\n\nerror[unresolved-reference]: Name `diverge` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:186\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter.\u2026\n   |                                                                 ^^^^^^^\n27 | \u2026\n28 | \u2026its* the default, making it a required parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:194\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026oted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter. They \u2026\n   |                                                                   ^^\n27 | \u2026\n28 | \u2026he default, making it a required parameter.\n   |\n\nerror[unresolved-reference]: Name `on` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:194\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026oted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter. They \u2026\n   |                                                                   ^^\n27 | \u2026\n28 | \u2026he default, making it a required parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:197\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026n the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter. They typica\u2026\n   |                                                                ^^^^^^^^^\n27 | \u2026\n28 | \u2026ault, making it a required parameter.\n   |\n\nerror[unresolved-reference]: Name `different` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:197\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026n the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter. They typica\u2026\n   |                                                                ^^^^^^^^^\n27 | \u2026\n28 | \u2026ault, making it a required parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:207\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026ASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter. They typically only \u2026\n   |                                                                 ^^^^^^^\n27 | \u2026\n28 | \u2026ing it a required parameter.\n   |\n\nerror[unresolved-reference]: Name `default` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:207\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026ASON`, most modern type checkers do *not* diverge on different default *values* for the same optional parameter. They typically only \u2026\n   |                                                                 ^^^^^^^\n27 | \u2026\n28 | \u2026ing it a required parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `values` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:216\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026st modern type checkers do *not* diverge on different default *values* for the same optional parameter. They typically only care abou\u2026\n   |                                                                 ^^^^^^\n27 | \u2026\n28 | \u2026required parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier, but found a keyword `for` that cannot be used here\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:224\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026ern type checkers do *not* diverge on different default *values* for the same optional parameter. They typically only care about whet\u2026\n   |                                                                   ^^^\n27 | \u2026\n28 | \u2026ed parameter.\n   |\n\nerror[unresolved-reference]: Name `for` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:224\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026ern type checkers do *not* diverge on different default *values* for the same optional parameter. They typically only care about whet\u2026\n   |                                                                   ^^^\n27 | \u2026\n28 | \u2026ed parameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:228\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026type checkers do *not* diverge on different default *values* for the same optional parameter. They typically only care about whether \u2026\n   |                                                                   ^^^\n27 | \u2026\n28 | \u2026arameter.\n   |\n\nerror[unresolved-reference]: Name `the` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:228\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026type checkers do *not* diverge on different default *values* for the same optional parameter. They typically only care about whether \u2026\n   |                                                                   ^^^\n27 | \u2026\n28 | \u2026arameter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:232\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026checkers do *not* diverge on different default *values* for the same optional parameter. They typically only care about whether an ar\u2026\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026ter.\n   |\n\nerror[unresolved-reference]: Name `same` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:232\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026checkers do *not* diverge on different default *values* for the same optional parameter. They typically only care about whether an ar\u2026\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026ter.\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:237\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026s do *not* diverge on different default *values* for the same optional parameter. They typically only care about whether an argument \u2026\n   |                                                                ^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `optional` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:237\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026s do *not* diverge on different default *values* for the same optional parameter. They typically only care about whether an argument \u2026\n   |                                                                ^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:246\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026* diverge on different default *values* for the same optional parameter. They typically only care about whether an argument is presen\u2026\n   |                                                                ^^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `parameter` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:246\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026* diverge on different default *values* for the same optional parameter. They typically only care about whether an argument is presen\u2026\n   |                                                                ^^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:262\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026ferent default *values* for the same optional parameter. They typically only care about whether an argument is present, its type, and\u2026\n   |                                                                ^^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `typically` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:262\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026ferent default *values* for the same optional parameter. They typically only care about whether an argument is present, its type, and\u2026\n   |                                                                ^^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:272\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026efault *values* for the same optional parameter. They typically only care about whether an argument is present, its type, and its opt\u2026\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `only` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:272\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026efault *values* for the same optional parameter. They typically only care about whether an argument is present, its type, and its opt\u2026\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:277\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026t *values* for the same optional parameter. They typically only care about whether an argument is present, its type, and its optional\u2026\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `care` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:277\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026t *values* for the same optional parameter. They typically only care about whether an argument is present, its type, and its optional\u2026\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:282\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026lues* for the same optional parameter. They typically only care about whether an argument is present, its type, and its optionality. \u2026\n   |                                                                  ^^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `about` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:282\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026lues* for the same optional parameter. They typically only care about whether an argument is present, its type, and its optionality. \u2026\n   |                                                                  ^^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:288\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026or the same optional parameter. They typically only care about whether an argument is present, its type, and its optionality. I need \u2026\n   |                                                                 ^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `whether` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:288\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026or the same optional parameter. They typically only care about whether an argument is present, its type, and its optionality. I need \u2026\n   |                                                                 ^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:296\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026 same optional parameter. They typically only care about whether an argument is present, its type, and its optionality. I need to fin\u2026\n   |                                                                   ^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `an` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:296\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026 same optional parameter. They typically only care about whether an argument is present, its type, and its optionality. I need to fin\u2026\n   |                                                                   ^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:299\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026optional parameter. They typically only care about whether an argument is present, its type, and its optionality. I need to find a *r\u2026\n   |                                                                ^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `argument` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:299\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026optional parameter. They typically only care about whether an argument is present, its type, and its optionality. I need to find a *r\u2026\n   |                                                                ^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `present` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:311\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026rameter. They typically only care about whether an argument is present, its type, and its optionality. I need to find a *real* diverg\u2026\n   |                                                                 ^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `its` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:320\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026. They typically only care about whether an argument is present, its type, and its optionality. I need to find a *real* divergence fo\u2026\n   |                                                                   ^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found `type`\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:324\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026y typically only care about whether an argument is present, its type, and its optionality. I need to find a *real* divergence for thi\u2026\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[invalid-syntax]: Expected `,`, found `and`\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:330\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026ically only care about whether an argument is present, its type, and its optionality. I need to find a *real* divergence for this cat\u2026\n   |                                                                   ^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `its` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:334\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026ly only care about whether an argument is present, its type, and its optionality. I need to find a *real* divergence for this categor\u2026\n   |                                                                   ^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:338\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026care about whether an argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                               ^^^^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `optionality` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:338\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026care about whether an argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                               ^^^^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:353\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026hether an argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `need` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:353\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026hether an argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:358\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026er an argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                   ^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `to` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:358\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026er an argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                   ^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:361\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026n argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `find` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:361\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026n argument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:366\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026rgument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                    ^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `a` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:366\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026rgument is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                    ^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `real` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:369\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026nt is present, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                  ^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `divergence` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:375\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026sent, its type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                               ^^^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:386\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026ts type, and its optionality. I need to find a *real* divergence for this category.\n   |                                                                   ^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[invalid-syntax]: Expected `in`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:395\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026 its optionality. I need to find a *real* divergence for this category.\n   |                                                                ^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[unresolved-reference]: Name `category` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:395\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026 its optionality. I need to find a *real* divergence for this category.\n   |                                                                ^^^^^^^^\n27 | \u2026\n28 | \u2026\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:26:404\n   |\n24 | \u2026\n25 | \u2026\n26 | \u2026optionality. I need to find a *real* divergence for this category.\n   |                                                                    ^\n27 | \u2026\n28 | \u2026\n   |\n\nerror[invalid-syntax]: Expected an indented block after `for` statement\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:1\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   | ^\n   |\n\nerror[unresolved-reference]: Name `A` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:1\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   | ^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:3\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |   ^^^^^\n   |\n\nerror[unresolved-reference]: Name `known` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:3\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |   ^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:9\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |         ^^^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `divergence` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:9\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |         ^^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:28\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                            ^^^^\n   |\n\nerror[unresolved-reference]: Name `area` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:28\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                            ^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `when` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:36\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                    ^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:41\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                         ^\n   |\n\nerror[unresolved-reference]: Name `a` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:41\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                         ^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:43\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                           ^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `protocol` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:43\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                           ^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:52\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                    ^^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `specifies` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:52\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                    ^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:62\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                              ^^\n   |\n\nerror[unresolved-reference]: Name `an` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:62\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                              ^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:65\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                                 ^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `optional` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:65\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                                 ^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `defaulted` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:75\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                                           ^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Simple statements must be separated by newlines or semicolons\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:86\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                                                      ^^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `parameter` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:86\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                                                      ^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `but` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:97\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                                                                 ^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:101\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                                                                     ^^^\n   |\n\nerror[unresolved-reference]: Name `the` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:101\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                                                                     ^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:105\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                                                                         ^^^^^^^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `implementation` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:105\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                                                                         ^^^^^^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `omits` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:121\n   |\n26 | **Self-correction:** The above example for \"Protocol with default arguments\" is a classic *misconception* about divergence. As noted i\u2026\n27 |\n28 | A known divergence in this area is when a protocol specifies an optional (defaulted) parameter, but the implementation *omits* the def\u2026\n   |                                                                                                                         ^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `the` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:128\n   |\n26 | \u2026ult arguments\" is a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on\u2026\n27 | \u2026\n28 | \u2026n optional (defaulted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                   ^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:132\n   |\n26 | \u2026guments\" is a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on diffe\u2026\n27 | \u2026\n28 | \u2026onal (defaulted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                 ^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `default` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:132\n   |\n26 | \u2026guments\" is a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on diffe\u2026\n27 | \u2026\n28 | \u2026onal (defaulted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                 ^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `making` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:141\n   |\n26 | \u2026is a classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different defa\u2026\n27 | \u2026\n28 | \u2026aulted) parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                 ^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:148\n   |\n26 | \u2026classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *\u2026\n27 | \u2026\n28 | \u2026d) parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                   ^^\n   |\n\nerror[unresolved-reference]: Name `it` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:148\n   |\n26 | \u2026classic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *\u2026\n27 | \u2026\n28 | \u2026d) parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                   ^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:151\n   |\n26 | \u2026assic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *va\u2026\n27 | \u2026\n28 | \u2026 parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                    ^\n   |\n\nerror[unresolved-reference]: Name `a` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:151\n   |\n26 | \u2026assic *misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *va\u2026\n27 | \u2026\n28 | \u2026 parameter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                    ^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:153\n   |\n26 | \u2026*misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* \u2026\n27 | \u2026\n28 | \u2026eter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                ^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `required` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:153\n   |\n26 | \u2026*misconception* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* \u2026\n27 | \u2026\n28 | \u2026eter, but the implementation *omits* the default, making it a required parameter.\n   |                                                                ^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:162\n   |\n26 | \u2026ption* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the s\u2026\n27 | \u2026\n28 | \u2026 the implementation *omits* the default, making it a required parameter.\n   |                                                                ^^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `parameter` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:162\n   |\n26 | \u2026ption* about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the s\u2026\n27 | \u2026\n28 | \u2026 the implementation *omits* the default, making it a required parameter.\n   |                                                                ^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an identifier\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:28:172\n   |\n26 | \u2026 about divergence. As noted in the `REASON`, most modern type checkers do *not* diverge on different default *values* for the same op\u2026\n27 | \u2026\n28 | \u2026mplementation *omits* the default, making it a required parameter.\n   |                                                                    ^\n   |\n\nerror[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:1\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   | ^^\n   |\n\nerror[unresolved-reference]: Name `Re` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:3\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |   ^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `evaluating` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:6\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |      ^^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[unresolved-reference]: Name `generating` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:21\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                     ^^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:32\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                ^^^\n   |\n\nerror[invalid-syntax]: Expected `in`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:41\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                         ^^^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `divergence` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:41\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                         ^^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `:`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:52\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                    ^^^^^\n   |\n\nerror[unresolved-reference]: Name `point` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:52\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                    ^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Compound statements are not allowed on the same line as simple statements\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:58\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                          ^^^^\n   |\n\nerror[unresolved-reference]: Name `known` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:63\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                               ^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:69\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                                     ^^^^^^\n   |\n\nerror[unresolved-reference]: Name `actual` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:69\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                                     ^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected `,`, found name\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:76\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                                            ^^^^^^^^^^^\n   |\n\nerror[unresolved-reference]: Name `divergences` used when not defined\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:76\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                                            ^^^^^^^^^^^\n   |\ninfo: rule `unresolved-reference` is enabled by default\n\nerror[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:88\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                                                        ^^\n   |\n\nerror[invalid-syntax]: Expected an expression\n  --> generated_examples/2026-01-13_20-13-14/source_files/protocol-default-arg-compatibility.py:31:90\n   |\n31 | **Re-evaluating and generating for each divergence point with known actual divergences:**\n   |                                                                                          ^\n   |\n\nFound 147 diagnostics"
            }
        }
    ]
}