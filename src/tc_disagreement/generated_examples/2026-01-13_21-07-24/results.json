{
    "timestamp": "2026-01-13_21-07-24",
    "checkers_used": [
        "mypy",
        "pyrefly",
        "zuban",
        "ty"
    ],
    "results": [
        {
            "filename": "param-spec-decorator-classmethod-order.py",
            "filepath": "generated_examples/2026-01-13_21-07-24/source_files/param-spec-decorator-classmethod-order.py",
            "outputs": {
                "mypy": "Success: no issues found in 1 source file",
                "pyrefly": "[STDERR]\n INFO 0 errors",
                "zuban": "Success: no issues found in 1 source file",
                "ty": "error[unresolved-attribute]: Object of type `(**P@logging_decorator) -> R@logging_decorator` has no attribute `__name__`\n  --> generated_examples/2026-01-13_21-07-24/source_files/param-spec-decorator-classmethod-order.py:15:31\n   |\n13 |     @wraps(func)\n14 |     def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n15 |         print(f\"Log: Calling {func.__name__} with args={args}, kwargs={kwargs}\")\n   |                               ^^^^^^^^^^^^^\n16 |         return func(*args, **kwargs)\n17 |     return wrapper\n   |\ninfo: rule `unresolved-attribute` is enabled by default\n\nerror[missing-argument]: No argument provided for required parameter `value`\n  --> generated_examples/2026-01-13_21-07-24/source_files/param-spec-decorator-classmethod-order.py:46:11\n   |\n44 |     # This signifies a fundamental disagreement in how this decorator order is handled.\n45 |     # If the error is ignored, this call would execute at runtime.\n46 |     print(MyProcessor.inner_method(123))\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n47 |\n48 |     # This order is correctly handled by all type checkers.\n   |\ninfo: Union variant `(cls, value: int) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, value: int) -> Unknown) | ((cls, value: Divergent) -> Unknown)`\ninfo: rule `missing-argument` is enabled by default\n\nerror[missing-argument]: No argument provided for required parameter `value`\n  --> generated_examples/2026-01-13_21-07-24/source_files/param-spec-decorator-classmethod-order.py:46:11\n   |\n44 |     # This signifies a fundamental disagreement in how this decorator order is handled.\n45 |     # If the error is ignored, this call would execute at runtime.\n46 |     print(MyProcessor.inner_method(123))\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n47 |\n48 |     # This order is correctly handled by all type checkers.\n   |\ninfo: Union variant `(cls, value: Divergent) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, value: int) -> Unknown) | ((cls, value: Divergent) -> Unknown)`\ninfo: rule `missing-argument` is enabled by default\n\nerror[invalid-argument-type]: Argument is incorrect\n  --> generated_examples/2026-01-13_21-07-24/source_files/param-spec-decorator-classmethod-order.py:46:36\n   |\n44 |     # This signifies a fundamental disagreement in how this decorator order is handled.\n45 |     # If the error is ignored, this call would execute at runtime.\n46 |     print(MyProcessor.inner_method(123))\n   |                                    ^^^ Expected `Self@inner_method`, found `Literal[123]`\n47 |\n48 |     # This order is correctly handled by all type checkers.\n   |\ninfo: Union variant `(cls, value: Divergent) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, value: int) -> Unknown) | ((cls, value: Divergent) -> Unknown)`\ninfo: rule `invalid-argument-type` is enabled by default\n\nerror[missing-argument]: No argument provided for required parameter `value`\n  --> generated_examples/2026-01-13_21-07-24/source_files/param-spec-decorator-classmethod-order.py:49:11\n   |\n48 |     # This order is correctly handled by all type checkers.\n49 |     print(MyProcessor.outer_method(456))\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\ninfo: Union variant `(cls, value: int) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, value: int) -> Unknown) | ((cls, value: Divergent) -> Unknown)`\ninfo: rule `missing-argument` is enabled by default\n\nerror[missing-argument]: No argument provided for required parameter `value`\n  --> generated_examples/2026-01-13_21-07-24/source_files/param-spec-decorator-classmethod-order.py:49:11\n   |\n48 |     # This order is correctly handled by all type checkers.\n49 |     print(MyProcessor.outer_method(456))\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\ninfo: Union variant `(cls, value: Divergent) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, value: int) -> Unknown) | ((cls, value: Divergent) -> Unknown)`\ninfo: rule `missing-argument` is enabled by default\n\nerror[invalid-argument-type]: Argument is incorrect\n  --> generated_examples/2026-01-13_21-07-24/source_files/param-spec-decorator-classmethod-order.py:49:36\n   |\n48 |     # This order is correctly handled by all type checkers.\n49 |     print(MyProcessor.outer_method(456))\n   |                                    ^^^ Expected `Self@outer_method`, found `Literal[456]`\n   |\ninfo: Union variant `(cls, value: Divergent) -> Unknown` is incompatible with this call site\ninfo: Attempted to call union type `((cls, value: int) -> Unknown) | ((cls, value: Divergent) -> Unknown)`\ninfo: rule `invalid-argument-type` is enabled by default\n\nFound 7 diagnostics"
            }
        },
        {
            "filename": "protocol-default-call-mismatch.py",
            "filepath": "generated_examples/2026-01-13_21-07-24/source_files/protocol-default-call-mismatch.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_21-07-24/source_files/protocol-default-call-mismatch.py:57: error: Argument 1 to \"call_with_default\" has incompatible type \"RemovesDefault\"; expected \"HasDefaultMethod\"  [arg-type]\nFound 1 error in 1 file (checked 1 source file)",
                "pyrefly": "ERROR Argument `RemovesDefault` is not assignable to parameter `obj` with type `HasDefaultMethod` in function `call_with_default` [bad-argument-type]\n  --> generated_examples/2026-01-13_21-07-24/source_files/protocol-default-call-mismatch.py:57:58\n   |\n57 |     print(f\"Call with RemovesDefault: {call_with_default(removes_default)}\")\n   |                                                          ^^^^^^^^^^^^^^^\n   |\n  `RemovesDefault.greet` has type `BoundMethod[RemovesDefault, (self: RemovesDefault, name: str) -> str]`, which is not assignable to `BoundMethod[RemovesDefault, (self: RemovesDefault, name: str = 'World') -> str]`, the type of `HasDefaultMethod.greet`\n\n[STDERR]\n INFO 1 error",
                "zuban": "generated_examples/2026-01-13_21-07-24/source_files/protocol-default-call-mismatch.py:57: error: Argument 1 to \"call_with_default\" has incompatible type \"RemovesDefault\"; expected \"HasDefaultMethod\"  [arg-type]\ngenerated_examples/2026-01-13_21-07-24/source_files/protocol-default-call-mismatch.py:57: note: Following member(s) of \"RemovesDefault\" have conflicts:\ngenerated_examples/2026-01-13_21-07-24/source_files/protocol-default-call-mismatch.py:57: note:     Expected:\ngenerated_examples/2026-01-13_21-07-24/source_files/protocol-default-call-mismatch.py:57: note:         def greet(self, name: str = ...) -> str\ngenerated_examples/2026-01-13_21-07-24/source_files/protocol-default-call-mismatch.py:57: note:     Got:\ngenerated_examples/2026-01-13_21-07-24/source_files/protocol-default-call-mismatch.py:57: note:         def greet(self, name: str) -> str\nFound 1 errors in 1 file (checked 1 source file)",
                "ty": "error[invalid-argument-type]: Argument to function `call_with_default` is incorrect\n  --> generated_examples/2026-01-13_21-07-24/source_files/protocol-default-call-mismatch.py:57:58\n   |\n55 |     # runtime error statically, flagging `removes_default` as incompatible with `HasDefaultMethod`\n56 |     # for the purpose of the no-argument call.\n57 |     print(f\"Call with RemovesDefault: {call_with_default(removes_default)}\")\n   |                                                          ^^^^^^^^^^^^^^^ Expected `HasDefaultMethod`, found `RemovesDefault`\n   |\ninfo: Function defined here\n  --> generated_examples/2026-01-13_21-07-24/source_files/protocol-default-call-mismatch.py:31:5\n   |\n29 |         return f\"Hi, {name}!\"\n30 |\n31 | def call_with_default(obj: HasDefaultMethod) -> str:\n   |     ^^^^^^^^^^^^^^^^^ --------------------- Parameter declared here\n32 |     \"\"\"\n33 |     Function that expects a HasDefaultMethod and calls its `greet` method\n   |\ninfo: rule `invalid-argument-type` is enabled by default\n\nFound 1 diagnostic"
            }
        },
        {
            "filename": "final-attribute-property-override.py",
            "filepath": "generated_examples/2026-01-13_21-07-24/source_files/final-attribute-property-override.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_21-07-24/source_files/final-attribute-property-override.py:23: error: Cannot override final attribute \"SETTING_A\" (previously declared in base class \"Configuration\")  [misc]\nFound 1 error in 1 file (checked 1 source file)",
                "pyrefly": "ERROR `SETTING_A` is declared as final in parent class `Configuration` [bad-override]\n  --> generated_examples/2026-01-13_21-07-24/source_files/final-attribute-property-override.py:24:9\n   |\n24 |     def SETTING_A(self) -> str:\n   |         ^^^^^^^^^\n   |\n\n[STDERR]\n INFO 1 error",
                "zuban": "generated_examples/2026-01-13_21-07-24/source_files/final-attribute-property-override.py:23: error: Cannot override final attribute \"SETTING_A\" (previously declared in base class \"Configuration\")  [misc]\nFound 1 error in 1 file (checked 1 source file)",
                "ty": "All checks passed!"
            }
        },
        {
            "filename": "keyword-vs-positional-protocol.py",
            "filepath": "generated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55: error: Argument 1 to \"operate\" has incompatible type \"StrictProcessor\"; expected \"HasProcessor\"  [arg-type]\ngenerated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55: note: Following member(s) of \"StrictProcessor\" have conflicts:\ngenerated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55: note:     Expected:\ngenerated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55: note:         def process(self, value: int, *, factor: float = ...) -> float\ngenerated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55: note:     Got:\ngenerated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55: note:         def process(self, *, value: int, factor: float = ...) -> float\nFound 1 error in 1 file (checked 1 source file)",
                "pyrefly": "ERROR Argument `StrictProcessor` is not assignable to parameter `obj` with type `HasProcessor` in function `operate` [bad-argument-type]\n  --> generated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55:13\n   |\n55 |     operate(sp) # mypy: error (at the `operate(sp)` call site), others: ok.\n   |             ^^\n   |\n  `StrictProcessor.process` has type `BoundMethod[StrictProcessor, (self: StrictProcessor, *, value: int, factor: float = ...) -> float]`, which is not assignable to `BoundMethod[StrictProcessor, (self: StrictProcessor, value: int, *, factor: float = ...) -> float]`, the type of `HasProcessor.process`\n\n[STDERR]\n INFO 1 error",
                "zuban": "generated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55: error: Argument 1 to \"operate\" has incompatible type \"StrictProcessor\"; expected \"HasProcessor\"  [arg-type]\ngenerated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55: note: Following member(s) of \"StrictProcessor\" have conflicts:\ngenerated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55: note:     Expected:\ngenerated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55: note:         def process(self, value: int, *, factor: float = ...) -> float\ngenerated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55: note:     Got:\ngenerated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55: note:         def process(self, *, value: int, factor: float = ...) -> float\nFound 1 errors in 1 file (checked 1 source file)",
                "ty": "error[invalid-argument-type]: Argument to function `operate` is incorrect\n  --> generated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:55:13\n   |\n53 |     # *less flexible* than the protocol, which PEP 544 disallows.\n54 |     # Other type checkers might allow this, or be more lenient on parameter kinds.\n55 |     operate(sp) # mypy: error (at the `operate(sp)` call site), others: ok.\n   |             ^^ Expected `HasProcessor`, found `StrictProcessor`\n   |\ninfo: Function defined here\n  --> generated_examples/2026-01-13_21-07-24/source_files/keyword-vs-positional-protocol.py:31:5\n   |\n29 |         return value * factor\n30 |\n31 | def operate(obj: HasProcessor) -> None:\n   |     ^^^^^^^ ----------------- Parameter declared here\n32 |     \"\"\"\n33 |     Function that calls the `process` method, adhering to the protocol's signature.\n   |\ninfo: rule `invalid-argument-type` is enabled by default\n\nFound 1 diagnostic"
            }
        },
        {
            "filename": "typed-dict-total-sticky-required.py",
            "filepath": "generated_examples/2026-01-13_21-07-24/source_files/typed-dict-total-sticky-required.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_21-07-24/source_files/typed-dict-total-sticky-required.py:38: error: Missing key \"y\" for TypedDict \"FlexibleConfig\"  [typeddict-item]\nFound 1 error in 1 file (checked 1 source file)",
                "pyrefly": "ERROR Missing required key `y` for TypedDict `FlexibleConfig` [bad-typed-dict-key]\n  --> generated_examples/2026-01-13_21-07-24/source_files/typed-dict-total-sticky-required.py:38:39\n   |\n38 |     config_instance: FlexibleConfig = {\"z\": False}\n   |                                       ^^^^^^^^^^^^\n   |\n\n[STDERR]\n INFO 1 error",
                "zuban": "generated_examples/2026-01-13_21-07-24/source_files/typed-dict-total-sticky-required.py:38: error: Missing key \"y\" for TypedDict \"FlexibleConfig\"  [typeddict-item]\nFound 1 error in 1 file (checked 1 source file)",
                "ty": "error[missing-typed-dict-key]: Missing required key 'y' in TypedDict `FlexibleConfig` constructor\n  --> generated_examples/2026-01-13_21-07-24/source_files/typed-dict-total-sticky-required.py:38:39\n   |\n36 |     # a field becomes implicitly Required by an intermediate `total=True`,\n37 |     # it cannot become NotRequired again through a subsequent `total=False`.\n38 |     config_instance: FlexibleConfig = {\"z\": False}\n   |                                       ^^^^^^^^^^^^\n39 |     print(f\"FlexibleConfig instance: {config_instance}\")\n   |\ninfo: rule `missing-typed-dict-key` is enabled by default\n\nFound 1 diagnostic"
            }
        },
        {
            "filename": "newtype-list-covariance.py",
            "filepath": "generated_examples/2026-01-13_21-07-24/source_files/newtype-list-covariance.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_21-07-24/source_files/newtype-list-covariance.py:31: error: Argument 1 to \"process_int_list\" has incompatible type \"list[UserID]\"; expected \"list[int]\"  [arg-type]\ngenerated_examples/2026-01-13_21-07-24/source_files/newtype-list-covariance.py:31: note: \"list\" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance\ngenerated_examples/2026-01-13_21-07-24/source_files/newtype-list-covariance.py:31: note: Consider using \"Sequence\" instead, which is covariant\nFound 1 error in 1 file (checked 1 source file)",
                "pyrefly": "ERROR Argument `list[UserID]` is not assignable to parameter `data` with type `list[int]` in function `process_int_list` [bad-argument-type]\n  --> generated_examples/2026-01-13_21-07-24/source_files/newtype-list-covariance.py:31:22\n   |\n31 |     process_int_list(user_id_list) # mypy: ok, others: error\n   |                      ^^^^^^^^^^^^\n   |\n\n[STDERR]\n INFO 1 error",
                "zuban": "generated_examples/2026-01-13_21-07-24/source_files/newtype-list-covariance.py:31: error: Argument 1 to \"process_int_list\" has incompatible type \"list[UserID]\"; expected \"list[int]\"  [arg-type]\ngenerated_examples/2026-01-13_21-07-24/source_files/newtype-list-covariance.py:31: note: \"List\" is invariant -- see https://mypy.readthedocs.io/en/stable/common_issues.html#variance\ngenerated_examples/2026-01-13_21-07-24/source_files/newtype-list-covariance.py:31: note: Consider using \"Sequence\" instead, which is covariant\nFound 1 errors in 1 file (checked 1 source file)",
                "ty": "error[invalid-argument-type]: Argument to function `process_int_list` is incorrect\n  --> generated_examples/2026-01-13_21-07-24/source_files/newtype-list-covariance.py:31:22\n   |\n29 |     # within generic contexts.\n30 |     print(\"--- Testing List Covariance ---\")\n31 |     process_int_list(user_id_list) # mypy: ok, others: error\n   |                      ^^^^^^^^^^^^ Expected `list[int]`, found `list[UserID]`\n32 |\n33 |     # DIVERGENCE POINT 2: Tuple Covariance\n   |\ninfo: Function defined here\n  --> generated_examples/2026-01-13_21-07-24/source_files/newtype-list-covariance.py:12:5\n   |\n11 | # A function expecting a list of the base type (int).\n12 | def process_int_list(data: List[int]) -> None:\n   |     ^^^^^^^^^^^^^^^^ --------------- Parameter declared here\n13 |     print(f\"Processing integers: {data}\")\n   |\ninfo: rule `invalid-argument-type` is enabled by default\n\nFound 1 diagnostic"
            }
        },
        {
            "filename": "self-generic-abstract-inference.py",
            "filepath": "generated_examples/2026-01-13_21-07-24/source_files/self-generic-abstract-inference.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_21-07-24/source_files/self-generic-abstract-inference.py:52: error: \"UserRepository\" expects no type arguments, but 1 given  [type-arg]\nFound 1 error in 1 file (checked 1 source file)",
                "pyrefly": "ERROR Expected 0 type arguments for `UserRepository`, got 1 [bad-specialization]\n  --> generated_examples/2026-01-13_21-07-24/source_files/self-generic-abstract-inference.py:52:21\n   |\n52 |     processed_repo: UserRepository[str] = process_repository(UserRepository, \"default_user_name\")\n   |                     ^^^^^^^^^^^^^^^^^^^\n   |\n\n[STDERR]\n INFO 1 error",
                "zuban": "generated_examples/2026-01-13_21-07-24/source_files/self-generic-abstract-inference.py:52: error: \"UserRepository\" expects no type arguments, but 1 given  [type-arg]\nFound 1 error in 1 file (checked 1 source file)",
                "ty": "All checks passed!"
            }
        },
        {
            "filename": "typeguard-generic-list-narrowing.py",
            "filepath": "generated_examples/2026-01-13_21-07-24/source_files/typeguard-generic-list-narrowing.py",
            "outputs": {
                "mypy": "Success: no issues found in 1 source file",
                "pyrefly": "[STDERR]\n INFO 0 errors",
                "zuban": "Success: no issues found in 1 source file",
                "ty": "All checks passed!"
            }
        },
        {
            "filename": "bounded-typevar-nested-protocol.py",
            "filepath": "generated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:18: error: Type variable \"bounded-typevar-nested-protocol.T_NamedIterable\" is unbound  [valid-type]\ngenerated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:18: note: (Hint: Use \"Generic[T_NamedIterable]\" or \"Protocol[T_NamedIterable]\" base class to bind \"T_NamedIterable\" inside a class)\ngenerated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:18: note: (Hint: Use \"T_NamedIterable\" in function signature to bind \"T_NamedIterable\" inside a function)\ngenerated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:19: error: \"I\" has no attribute \"__iter__\" (not iterable)  [attr-defined]\nFound 2 errors in 1 file (checked 1 source file)",
                "pyrefly": "ERROR Type variable bounds and constraints must be concrete [invalid-annotation]\n  --> generated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:18:20\n   |\n18 | def print_names[I: T_NamedIterable](data: I) -> None:\n   |                    ^^^^^^^^^^^^^^^\n   |\n\n[STDERR]\n INFO 1 error",
                "zuban": "generated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:38: error: Value of type variable \"I\" of \"print_names\" cannot be \"list[MyObject]\"  [type-var]\ngenerated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:52: error: Value of type variable \"I\" of \"print_names\" cannot be \"list[MyOtherObject]\"  [type-var]\ngenerated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:57: error: Value of type variable \"I\" of \"print_names\" cannot be \"list[NamedThing]\"  [type-var]\nFound 3 errors in 1 file (checked 1 source file)",
                "ty": "error[invalid-argument-type]: Argument to function `print_names` is incorrect\n  --> generated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:38:17\n   |\n36 |     named_objects: list[MyObject] = [MyObject(\"Alpha\"), MyObject(\"Beta\")]\n37 |     print(\"\\n--- Printing names of MyObject instances ---\")\n38 |     print_names(named_objects)\n   |                 ^^^^^^^^^^^^^ Argument type `list[MyObject]` does not satisfy upper bound `typing.TypeVar` of type variable `I`\n39 |\n40 |     # DIVERGENCE POINT:\n   |\ninfo: Type variable defined here\n  --> generated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:18:17\n   |\n17 | # A generic function that takes an iterable of `NamedThing`s and prints their names.\n18 | def print_names[I: T_NamedIterable](data: I) -> None:\n   |                 ^^^^^^^^^^^^^^^^^^\n19 |     for item in data:\n20 |         print(f\"Name: {item.get_name()}\")\n   |\ninfo: rule `invalid-argument-type` is enabled by default\n\nerror[invalid-argument-type]: Argument to function `print_names` is incorrect\n  --> generated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:52:17\n   |\n50 |     other_objects: list[MyOtherObject] = [MyOtherObject(1), MyOtherObject(2)]\n51 |     print(\"\\n--- Printing names of MyOtherObject instances (EXPECTED ERROR) ---\")\n52 |     print_names(other_objects) # mypy: error, others: ok.\n   |                 ^^^^^^^^^^^^^ Argument type `list[MyOtherObject]` does not satisfy upper bound `typing.TypeVar` of type variable `I`\n53 |\n54 |     # An empty list satisfies the bound for any `Iterable[T]`.\n   |\ninfo: Type variable defined here\n  --> generated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:18:17\n   |\n17 | # A generic function that takes an iterable of `NamedThing`s and prints their names.\n18 | def print_names[I: T_NamedIterable](data: I) -> None:\n   |                 ^^^^^^^^^^^^^^^^^^\n19 |     for item in data:\n20 |         print(f\"Name: {item.get_name()}\")\n   |\ninfo: rule `invalid-argument-type` is enabled by default\n\nerror[invalid-argument-type]: Argument to function `print_names` is incorrect\n  --> generated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:57:17\n   |\n55 |     empty_list: list[NamedThing] = []\n56 |     print(\"\\n--- Printing names of empty list ---\")\n57 |     print_names(empty_list)\n   |                 ^^^^^^^^^^ Argument type `list[NamedThing]` does not satisfy upper bound `typing.TypeVar` of type variable `I`\n   |\ninfo: Type variable defined here\n  --> generated_examples/2026-01-13_21-07-24/source_files/bounded-typevar-nested-protocol.py:18:17\n   |\n17 | # A generic function that takes an iterable of `NamedThing`s and prints their names.\n18 | def print_names[I: T_NamedIterable](data: I) -> None:\n   |                 ^^^^^^^^^^^^^^^^^^\n19 |     for item in data:\n20 |         print(f\"Name: {item.get_name()}\")\n   |\ninfo: rule `invalid-argument-type` is enabled by default\n\nFound 3 diagnostics"
            }
        },
        {
            "filename": "overload-literal-resolution.py",
            "filepath": "generated_examples/2026-01-13_21-07-24/source_files/overload-literal-resolution.py",
            "outputs": {
                "mypy": "generated_examples/2026-01-13_21-07-24/source_files/overload-literal-resolution.py:9: error: Overloaded function signatures 1 and 2 overlap with incompatible return types  [overload-overlap]\ngenerated_examples/2026-01-13_21-07-24/source_files/overload-literal-resolution.py:9: error: Overloaded function signatures 1 and 3 overlap with incompatible return types  [overload-overlap]\ngenerated_examples/2026-01-13_21-07-24/source_files/overload-literal-resolution.py:12: error: Overloaded function signatures 2 and 3 overlap with incompatible return types  [overload-overlap]\nFound 3 errors in 1 file (checked 1 source file)",
                "pyrefly": "[STDERR]\n INFO 0 errors",
                "zuban": "Success: no issues found in 1 source file",
                "ty": "All checks passed!"
            }
        }
    ]
}