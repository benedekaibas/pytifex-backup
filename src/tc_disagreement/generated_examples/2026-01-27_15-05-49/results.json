{
  "timestamp": "2026-01-27T15:05:49.022910",
  "model_used": "gemini-2.5-flash",
  "total_generated": 15,
  "disagreements_found": 10,
  "success_rate": "66.7%",
  "checkers_used": [
    "mypy",
    "pyrefly",
    "zuban",
    "ty"
  ],
  "results": [
    {
      "filename": "newtype-protocol-divergence-refined.py",
      "filepath": "generated_examples/2026-01-27_15-05-49/source_files/newtype-protocol-divergence-refined.py",
      "seed_issue": null,
      "outputs": {
        "mypy": "_pytifex_temp_3716177.py:29: note: Revealed type is \"_pytifex_temp_3716177.Money\"\n_pytifex_temp_3716177.py:30: note: Revealed type is \"_pytifex_temp_3716177.Money\"\n_pytifex_temp_3716177.py:42: note: Revealed type is \"builtins.bool\"\nSuccess: no issues found in 1 source file",
        "pyrefly": "INFO revealed type: Money [reveal-type]\n  --> _pytifex_temp_3716177.py:29:16\n   |\n29 |     reveal_type(m1) # Expected: Money\n   |                ----\n   |\n INFO revealed type: Money [reveal-type]\n  --> _pytifex_temp_3716177.py:30:16\n   |\n30 |     reveal_type(m2) # Expected: Money\n   |                ----\n   |\n INFO revealed type: bool [reveal-type]\n  --> _pytifex_temp_3716177.py:42:16\n   |\n42 |     reveal_type(m1 > m2) # Expected: bool. Mypy reveals bool but also reports an error.\n   |                ---------\n   |\n INFO 0 errors",
        "zuban": "_pytifex_temp_3716177.py:29: note: Revealed type is \"_pytifex_temp_3716177.Money\"\n_pytifex_temp_3716177.py:30: note: Revealed type is \"_pytifex_temp_3716177.Money\"\n_pytifex_temp_3716177.py:42: note: Revealed type is \"builtins.bool\"\nSuccess: no issues found in 1 source file",
        "ty": "info[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:29:17\n   |\n27 |     m2 = items[1]\n28 |     \n29 |     reveal_type(m1) # Expected: Money\n   |                 ^^ `Money`\n30 |     reveal_type(m2) # Expected: Money\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:30:17\n   |\n29 |     reveal_type(m1) # Expected: Money\n30 |     reveal_type(m2) # Expected: Money\n   |                 ^^ `Money`\n31 |\n32 |     # 3. This is the point of divergence:\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:42:17\n   |\n41 |     # This line has been changed from the original code (v1 > v2)\n42 |     reveal_type(m1 > m2) # Expected: bool. Mypy reveals bool but also reports an error.\n   |                 ^^^^^^^ `bool`\n43 |     return m1 > m2\n   |\n\nFound 3 diagnostics"
      },
      "statuses": {
        "mypy": "ok",
        "pyrefly": "ok",
        "zuban": "ok",
        "ty": "error"
      }
    },
    {
      "filename": "kwargs-splat-protocol.py",
      "filepath": "generated_examples/2026-01-27_15-05-49/source_files/kwargs-splat-protocol.py",
      "seed_issue": "ty #1332",
      "outputs": {
        "mypy": "_pytifex_temp_3716177.py:32: note: Revealed type is \"builtins.dict[builtins.str, builtins.int]\"\n_pytifex_temp_3716177.py:33: note: Revealed type is \"builtins.dict[builtins.str, Any]\"\n_pytifex_temp_3716177.py:34: note: Revealed type is \"builtins.dict[builtins.str, builtins.int]\"\nSuccess: no issues found in 1 source file",
        "pyrefly": "INFO revealed type: dict[Unknown, Unknown] [reveal-type]\n  --> _pytifex_temp_3716177.py:32:16\n   |\n32 |     reveal_type({**source_impl})  # Expected: dict[str, int] if `items()` assumed, else `dict[Unknown, Unknown]` or error.\n   |                -----------------\n   |\nERROR Expected a mapping, got CustomKwargSource [invalid-argument]\n  --> _pytifex_temp_3716177.py:32:20\n   |\n32 |     reveal_type({**source_impl})  # Expected: dict[str, int] if `items()` assumed, else `dict[Unknown, Unknown]` or error.\n   |                    ^^^^^^^^^^^\n   |\n INFO revealed type: dict[Unknown, Unknown] [reveal-type]\n  --> _pytifex_temp_3716177.py:33:16\n   |\n33 |     reveal_type({**source_protocol}) # Expected: same as above\n   |                ---------------------\n   |\nERROR Expected a mapping, got MinimalKwargProtocol [invalid-argument]\n  --> _pytifex_temp_3716177.py:33:20\n   |\n33 |     reveal_type({**source_protocol}) # Expected: same as above\n   |                    ^^^^^^^^^^^^^^^\n   |\n INFO revealed type: dict[str, int] [reveal-type]\n  --> _pytifex_temp_3716177.py:34:16\n   |\n34 |     reveal_type({**source_mapping}) # Expected: dict[str, int] (should be fine)\n   |                --------------------\n   |\nERROR Expected argument after ** to be a mapping, got: CustomKwargSource in function `func_accepting_kwargs` [bad-unpacking]\n  --> _pytifex_temp_3716177.py:36:29\n   |\n36 |     func_accepting_kwargs(**source_impl)    # Should be a runtime TypeError. Type checker might miss.\n   |                             ^^^^^^^^^^^\n   |\nERROR Expected argument after ** to be a mapping, got: MinimalKwargProtocol in function `func_accepting_kwargs` [bad-unpacking]\n  --> _pytifex_temp_3716177.py:37:29\n   |\n37 |     func_accepting_kwargs(**source_protocol) # Same as above\n   |                             ^^^^^^^^^^^^^^^\n   |\n INFO 4 errors",
        "zuban": "_pytifex_temp_3716177.py:32: note: Revealed type is \"builtins.dict[builtins.str, builtins.int]\"\n_pytifex_temp_3716177.py:33: note: Revealed type is \"builtins.dict[builtins.str, Any]\"\n_pytifex_temp_3716177.py:34: note: Revealed type is \"builtins.dict[builtins.str, builtins.int]\"\nSuccess: no issues found in 1 source file",
        "ty": "info[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:32:17\n   |\n30 | ):\n31 |     # Does type checker identify that CustomKwargSource lacks `items()` for `**`?\n32 |     reveal_type({**source_impl})  # Expected: dict[str, int] if `items()` assumed, else `dict[Unknown, Unknown]` or error.\n   |                 ^^^^^^^^^^^^^^^ `dict[Unknown, Unknown]`\n33 |     reveal_type({**source_protocol}) # Expected: same as above\n34 |     reveal_type({**source_mapping}) # Expected: dict[str, int] (should be fine)\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:33:17\n   |\n31 |     # Does type checker identify that CustomKwargSource lacks `items()` for `**`?\n32 |     reveal_type({**source_impl})  # Expected: dict[str, int] if `items()` assumed, else `dict[Unknown, Unknown]` or error.\n33 |     reveal_type({**source_protocol}) # Expected: same as above\n   |                 ^^^^^^^^^^^^^^^^^^^ `dict[Unknown, Unknown]`\n34 |     reveal_type({**source_mapping}) # Expected: dict[str, int] (should be fine)\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:34:17\n   |\n32 |     reveal_type({**source_impl})  # Expected: dict[str, int] if `items()` assumed, else `dict[Unknown, Unknown]` or error.\n33 |     reveal_type({**source_protocol}) # Expected: same as above\n34 |     reveal_type({**source_mapping}) # Expected: dict[str, int] (should be fine)\n   |                 ^^^^^^^^^^^^^^^^^^ `dict[Unknown, Unknown]`\n35 |\n36 |     func_accepting_kwargs(**source_impl)    # Should be a runtime TypeError. Type checker might miss.\n   |\n\nFound 3 diagnostics"
      },
      "statuses": {
        "mypy": "ok",
        "pyrefly": "error",
        "zuban": "ok",
        "ty": "error"
      }
    },
    {
      "filename": "paramspec-union-return-type.py",
      "filepath": "generated_examples/2026-01-27_15-05-49/source_files/paramspec-union-return-type.py",
      "seed_issue": "mypy #20452",
      "outputs": {
        "mypy": "_pytifex_temp_3716177.py:37: note: Revealed type is \"def (x: builtins.int, y: builtins.str) -> builtins.float | def (x: builtins.int, y: builtins.str) -> type[None]\"\n_pytifex_temp_3716177.py:41: note: Revealed type is \"builtins.float | type[None]\"\nSuccess: no issues found in 1 source file",
        "pyrefly": "INFO revealed type: ((x: int, y: str) -> float) | ((x: int, y: str) -> type[None]) [reveal-type]\n  --> _pytifex_temp_3716177.py:37:12\n   |\n37 | reveal_type(decorated_func)\n   |            ----------------\n   |\n INFO revealed type: float | type[None] [reveal-type]\n  --> _pytifex_temp_3716177.py:41:12\n   |\n41 | reveal_type(result) # Expected: Union[float, Type[None]]\n   |            --------\n   |\n INFO 0 errors",
        "zuban": "_pytifex_temp_3716177.py:27: error: Statement is unreachable  [unreachable]\n_pytifex_temp_3716177.py:37: note: Revealed type is \"def (x: builtins.int, y: builtins.str) -> builtins.float | def (x: builtins.int, y: builtins.str) -> type[None]\"\n_pytifex_temp_3716177.py:41: note: Revealed type is \"builtins.float | type[None]\"\nFound 1 errors in 1 file (checked 1 source file)",
        "ty": "error[unresolved-attribute]: Object of type `(**P@conditional_decorator) -> R@conditional_decorator` has no attribute `__name__`\n  --> _pytifex_temp_3716177.py:16:30\n   |\n14 |     class OriginalWrapper:\n15 |         def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R:\n16 |             print(f\"Calling {func.__name__} with original return type\")\n   |                              ^^^^^^^^^^^^^\n17 |             return func(*args, **kwargs)\n   |\ninfo: rule `unresolved-attribute` is enabled by default\n\nerror[unresolved-attribute]: Object of type `(**P@conditional_decorator) -> R@conditional_decorator` has no attribute `__name__`\n  --> _pytifex_temp_3716177.py:21:30\n   |\n19 |     class AltWrapper:\n20 |         def __call__(self, *args: P.args, **kwargs: P.kwargs) -> Type[None]:\n21 |             print(f\"Calling {func.__name__} with Type[None] return type (should not happen at runtime)\")\n   |                              ^^^^^^^^^^^^^\n22 |             func(*args, **kwargs)\n23 |             return type(None) # Always returns the type object None\n   |\ninfo: rule `unresolved-attribute` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:37:13\n   |\n36 | # Type checker should infer decorated_func as Union[Callable[[int, str], float], Callable[[int, str], Type[None]]]\n37 | reveal_type(decorated_func)\n   |             ^^^^^^^^^^^^^^ `(x: int, y: str) -> Unknown`\n38 |\n39 | # The result of calling decorated_func should reflect the Union of return types.\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:41:13\n   |\n39 | # The result of calling decorated_func should reflect the Union of return types.\n40 | result = decorated_func(10, \"hello\")\n41 | reveal_type(result) # Expected: Union[float, Type[None]]\n   |             ^^^^^^ `Unknown`\n42 |\n43 | if __name__ == \"__main__\":\n   |\n\nFound 4 diagnostics"
      },
      "statuses": {
        "mypy": "ok",
        "pyrefly": "ok",
        "zuban": "error",
        "ty": "error"
      }
    },
    {
      "filename": "ternary-typeguard-generic-lambda.py",
      "filepath": "generated_examples/2026-01-27_15-05-49/source_files/ternary-typeguard-generic-lambda.py",
      "seed_issue": "mypy #19561",
      "outputs": {
        "mypy": "_pytifex_temp_3716177.py:29: error: Incompatible return value type (got \"None\", expected \"str\")  [return-value]\n_pytifex_temp_3716177.py:32: note: Revealed type is \"def () -> builtins.str | None\"\n_pytifex_temp_3716177.py:36: note: Revealed type is \"builtins.str | None\"\nFound 1 error in 1 file (checked 1 source file)",
        "pyrefly": "ERROR Argument `BaseThing | T | None` is not assignable to parameter `val` with type `BaseThing | T` in function `is_special` [bad-argument-type]\n  --> _pytifex_temp_3716177.py:29:52\n   |\n29 |         (lambda: process_special(x)) if is_special(x) else (lambda: None)\n   |                                                    ^\n   |\n INFO revealed type: () -> str | None [reveal-type]\n  --> _pytifex_temp_3716177.py:32:16\n   |\n32 |     reveal_type(action_lambda) # Expected: Callable[[], Union[str, None]]\n   |                ---------------\n   |\n INFO revealed type: str | None [reveal-type]\n  --> _pytifex_temp_3716177.py:36:16\n   |\n36 |     reveal_type(lambda_result) # Expected: Union[str, None]\n   |                ---------------\n   |\n INFO 1 error",
        "zuban": "_pytifex_temp_3716177.py:32: note: Revealed type is \"def () -> builtins.str | None\"\n_pytifex_temp_3716177.py:36: note: Revealed type is \"builtins.str | None\"\nSuccess: no issues found in 1 source file",
        "ty": "error[invalid-argument-type]: Argument to function `process_special` is incorrect\n  --> _pytifex_temp_3716177.py:29:34\n   |\n27 |     # that capture `x`. The narrowing of `x` must correctly apply *inside* the lambda.\n28 |     action_lambda: Callable[[], Union[str, None]] = (\n29 |         (lambda: process_special(x)) if is_special(x) else (lambda: None)\n   |                                  ^ Expected `SpecialThing`, found `T@get_action_lambda | BaseThing | None`\n30 |     )\n   |\ninfo: Function defined here\n  --> _pytifex_temp_3716177.py:22:5\n   |\n20 |     return isinstance(val, SpecialThing)\n21 |\n22 | def process_special(s: SpecialThing) -> str:\n   |     ^^^^^^^^^^^^^^^ --------------- Parameter declared here\n23 |     return s.get_special_info()\n   |\ninfo: rule `invalid-argument-type` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:32:17\n   |\n30 |     )\n31 |     \n32 |     reveal_type(action_lambda) # Expected: Callable[[], Union[str, None]]\n   |                 ^^^^^^^^^^^^^ `() -> Unknown`\n33 |     \n34 |     # Test the return type of the lambda call\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:36:17\n   |\n34 |     # Test the return type of the lambda call\n35 |     lambda_result = action_lambda()\n36 |     reveal_type(lambda_result) # Expected: Union[str, None]\n   |                 ^^^^^^^^^^^^^ `Unknown`\n37 |\n38 |     return action_lambda\n   |\n\nFound 3 diagnostics"
      },
      "statuses": {
        "mypy": "error",
        "pyrefly": "error",
        "zuban": "ok",
        "ty": "error"
      }
    },
    {
      "filename": "typeddict-inheritance-total-divergence.py",
      "filepath": "generated_examples/2026-01-27_15-05-49/source_files/typeddict-inheritance-total-divergence.py",
      "seed_issue": null,
      "outputs": {
        "mypy": "_pytifex_temp_3716177.py:21: note: Revealed type is \"TypedDict('_pytifex_temp_3716177.FinalSettings', {'log_level': builtins.str, 'timeout': builtins.int, 'api_key'?: builtins.str, 'feature_flag'?: builtins.bool, 'database_url': builtins.str, 'retries'?: builtins.int})\"\n_pytifex_temp_3716177.py:25: note: Revealed type is \"builtins.str\"\n_pytifex_temp_3716177.py:31: note: Revealed type is \"builtins.str\"\n_pytifex_temp_3716177.py:34: note: Revealed type is \"builtins.bool | None\"\n_pytifex_temp_3716177.py:37: note: Revealed type is \"builtins.str\"\n_pytifex_temp_3716177.py:40: note: Revealed type is \"builtins.int | None\"\nSuccess: no issues found in 1 source file",
        "pyrefly": "INFO revealed type: FinalSettings [reveal-type]\n  --> _pytifex_temp_3716177.py:21:16\n   |\n21 |     reveal_type(cfg)\n   |                -----\n   |\n INFO revealed type: str [reveal-type]\n  --> _pytifex_temp_3716177.py:25:16\n   |\n25 |     reveal_type(log_level) # Expected: str (Required due to FinalSettings total=True)\n   |                -----------\n   |\n INFO revealed type: str [reveal-type]\n  --> _pytifex_temp_3716177.py:31:16\n   |\n31 |     reveal_type(api_key) \n   |                ---------\n   |\n INFO revealed type: bool | None [reveal-type]\n  --> _pytifex_temp_3716177.py:34:16\n   |\n34 |     reveal_type(feature_flag) # Expected: Union[bool, None] (NotRequired)\n   |                --------------\n   |\n INFO revealed type: str [reveal-type]\n  --> _pytifex_temp_3716177.py:37:16\n   |\n37 |     reveal_type(database_url) # Expected: str (Required)\n   |                --------------\n   |\n INFO revealed type: int | None [reveal-type]\n  --> _pytifex_temp_3716177.py:40:16\n   |\n40 |     reveal_type(retries) # Expected: Union[int, None] (NotRequired)\n   |                ---------\n   |\nERROR Argument `dict[str, bool | int | str]` is not assignable to parameter `cfg` with type `FinalSettings` in function `validate_config` [bad-argument-type]\n  --> _pytifex_temp_3716177.py:77:21\n   |\n77 |     validate_config(invalid_cfg) \n   |                     ^^^^^^^^^^^\n   |\n  Field `log_level` is required in `FinalSettings` but is `NotRequired` in `<anonymous>`\n INFO 1 error",
        "zuban": "_pytifex_temp_3716177.py:21: note: Revealed type is \"TypedDict('_pytifex_temp_3716177.FinalSettings', {'log_level': builtins.str, 'timeout': builtins.int, 'api_key'?: builtins.str, 'feature_flag'?: builtins.bool, 'database_url': builtins.str, 'retries'?: builtins.int})\"\n_pytifex_temp_3716177.py:25: note: Revealed type is \"builtins.str\"\n_pytifex_temp_3716177.py:31: note: Revealed type is \"builtins.str\"\n_pytifex_temp_3716177.py:34: note: Revealed type is \"builtins.bool | None\"\n_pytifex_temp_3716177.py:37: note: Revealed type is \"builtins.str\"\n_pytifex_temp_3716177.py:40: note: Revealed type is \"builtins.int | None\"\n_pytifex_temp_3716177.py:77: error: Argument 1 to \"validate_config\" has incompatible type \"dict[str, str | int]\"; expected \"FinalSettings\"  [arg-type]\nFound 1 errors in 1 file (checked 1 source file)",
        "ty": "info[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:21:17\n   |\n20 | def validate_config(cfg: FinalSettings):\n21 |     reveal_type(cfg)\n   |                 ^^^ `FinalSettings`\n22 |     \n23 |     # Accessing fields to see if Required/NotRequired is inferred correctly\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:25:17\n   |\n23 |     # Accessing fields to see if Required/NotRequired is inferred correctly\n24 |     log_level = cfg['log_level']\n25 |     reveal_type(log_level) # Expected: str (Required due to FinalSettings total=True)\n   |                 ^^^^^^^^^ `str`\n26 |     \n27 |     api_key = cfg['api_key']\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:31:17\n   |\n29 |     # Divergence point: MyPy's reveal_type for 'cfg' itself shows 'api_key?'.\n30 |     # This implies MyPy considers it NotRequired, which contradicts strict TypedDict total=True semantics for inherited fields.\n31 |     reveal_type(api_key) \n   |                 ^^^^^^^ `str`\n32 |     \n33 |     feature_flag = cfg.get('feature_flag')\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:34:17\n   |\n33 |     feature_flag = cfg.get('feature_flag')\n34 |     reveal_type(feature_flag) # Expected: Union[bool, None] (NotRequired)\n   |                 ^^^^^^^^^^^^ `bool | None`\n35 |     \n36 |     database_url = cfg['database_url']\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:37:17\n   |\n36 |     database_url = cfg['database_url']\n37 |     reveal_type(database_url) # Expected: str (Required)\n   |                 ^^^^^^^^^^^^ `str`\n38 |     \n39 |     retries = cfg.get('retries')\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:40:17\n   |\n39 |     retries = cfg.get('retries')\n40 |     reveal_type(retries) # Expected: Union[int, None] (NotRequired)\n   |                 ^^^^^^^ `int | None`\n41 |\n42 | def create_valid_final_config() -> FinalSettings:\n   |\n\nFound 6 diagnostics"
      },
      "statuses": {
        "mypy": "ok",
        "pyrefly": "error",
        "zuban": "error",
        "ty": "ok"
      }
    },
    {
      "filename": "paramspec-classmethod-decorator.py",
      "filepath": "generated_examples/2026-01-27_15-05-49/source_files/paramspec-classmethod-decorator.py",
      "seed_issue": "mypy #20452",
      "outputs": {
        "mypy": "_pytifex_temp_3716177.py:52: note: Revealed type is \"_pytifex_temp_3716177.BaseProcessor\"\n_pytifex_temp_3716177.py:56: note: Revealed type is \"_pytifex_temp_3716177.MySpecialProcessor\"\nSuccess: no issues found in 1 source file",
        "pyrefly": "INFO revealed type: BaseProcessor [reveal-type]\n  --> _pytifex_temp_3716177.py:52:16\n   |\n52 |     reveal_type(proc1) # Expected: BaseProcessor\n   |                -------\n   |\n INFO revealed type: MySpecialProcessor [reveal-type]\n  --> _pytifex_temp_3716177.py:56:16\n   |\n56 |     reveal_type(proc2) # Expected: MySpecialProcessor\n   |                -------\n   |\n INFO 0 errors",
        "zuban": "_pytifex_temp_3716177.py:52: note: Revealed type is \"_pytifex_temp_3716177.BaseProcessor\"\n_pytifex_temp_3716177.py:56: note: Revealed type is \"_pytifex_temp_3716177.MySpecialProcessor\"\nSuccess: no issues found in 1 source file",
        "ty": "error[unresolved-attribute]: Object of type `(...) -> R@class_method_logger` has no attribute `__name__`\n  --> _pytifex_temp_3716177.py:15:57\n   |\n13 |     @wraps(f)\n14 |     def wrapper(cls: Type[T_Cls], *args: P.args, **kwargs: P.kwargs) -> R:\n15 |         print(f\"[{cls.__name__}] Calling class method '{f.__name__}' with args: {args}, kwargs: {kwargs}\")\n   |                                                         ^^^^^^^^^^\n16 |         return f(cls, *args, **kwargs)\n17 |     return wrapper\n   |\ninfo: rule `unresolved-attribute` is enabled by default\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:52:17\n   |\n50 |     # Call the decorated class method on the base class\n51 |     proc1 = BaseProcessor.create_named_instance(\"Base\", 1)\n52 |     reveal_type(proc1) # Expected: BaseProcessor\n   |                 ^^^^^ `Unknown`\n53 |\n54 |     # Call the decorated class method on the derived class\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:56:17\n   |\n54 |     # Call the decorated class method on the derived class\n55 |     proc2 = MySpecialProcessor.create_named_instance(\"Special\", 2)\n56 |     reveal_type(proc2) # Expected: MySpecialProcessor\n   |                 ^^^^^ `Unknown`\n57 |\n58 |     print(f\"Processor 1 name: {proc1.name}\")\n   |\n\nFound 3 diagnostics"
      },
      "statuses": {
        "mypy": "ok",
        "pyrefly": "ok",
        "zuban": "ok",
        "ty": "error"
      }
    },
    {
      "filename": "typeguard-typevar-bound-divergence.py",
      "filepath": "generated_examples/2026-01-27_15-05-49/source_files/typeguard-typevar-bound-divergence.py",
      "seed_issue": null,
      "outputs": {
        "mypy": "_pytifex_temp_3716177.py:57: note: Revealed type is \"builtins.list[V`4]\"\n_pytifex_temp_3716177.py:58: error: Need type annotation for \"item_in_list\"  [var-annotated]\nFound 1 error in 1 file (checked 1 source file)",
        "pyrefly": "INFO revealed type: list[Unknown] [reveal-type]\n  --> _pytifex_temp_3716177.py:57:20\n   |\n57 |         reveal_type(vehicles) # Expected: List[Car] by some, List[Vehicle] by others.\n   |                    ----------\n   |\n INFO 0 errors",
        "zuban": "_pytifex_temp_3716177.py:57: note: Revealed type is \"builtins.list[Never]\"\n_pytifex_temp_3716177.py:58: error: Need type annotation for \"item_in_list\"  [var-annotated]\nFound 1 errors in 1 file (checked 1 source file)",
        "ty": "info[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:57:21\n   |\n55 |         # This is the key divergence point.\n56 |         # How is `V` resolved by the type checker for `vehicles`?\n57 |         reveal_type(vehicles) # Expected: List[Car] by some, List[Vehicle] by others.\n   |                     ^^^^^^^^ `list[str | Vehicle]`\n58 |         for item_in_list in vehicles:\n59 |             # If `vehicles` is narrowed to `List[Car]`, this call is valid.\n   |\n\nerror[unresolved-attribute]: Object of type `str | Vehicle` has no attribute `honk`\n  --> _pytifex_temp_3716177.py:62:28\n   |\n60 |             # If `vehicles` is narrowed to `List[Vehicle]` (or `List[V]` where `V` is generic),\n61 |             # then `honk()` is not a method on `Vehicle`, so this should be an error.\n62 |             results.append(item_in_list.honk())\n   |                            ^^^^^^^^^^^^^^^^^\n63 |     else:\n64 |         # Here, `vehicles` could still contain `str` or `Bike`\n   |\ninfo: rule `unresolved-attribute` is enabled by default\n\nFound 2 diagnostics"
      },
      "statuses": {
        "mypy": "error",
        "pyrefly": "ok",
        "zuban": "error",
        "ty": "error"
      }
    },
    {
      "filename": "kwargs-splat-union-custom-mapping.py",
      "filepath": "generated_examples/2026-01-27_15-05-49/source_files/kwargs-splat-union-custom-mapping.py",
      "seed_issue": "ty #1332",
      "outputs": {
        "mypy": "_pytifex_temp_3716177.py:20: note: Revealed type is \"builtins.dict[builtins.str, builtins.str]\"\n_pytifex_temp_3716177.py:30: note: Revealed type is \"builtins.dict[builtins.str, Any]\"\n_pytifex_temp_3716177.py:31: note: Revealed type is \"builtins.dict[builtins.str, builtins.str]\"\n_pytifex_temp_3716177.py:32: note: Revealed type is \"builtins.dict[builtins.str, Any]\"\n_pytifex_temp_3716177.py:51: note: Revealed type is \"builtins.dict[builtins.str, builtins.str]\"\n_pytifex_temp_3716177.py:52: note: Revealed type is \"builtins.dict[builtins.str, Any]\"\nSuccess: no issues found in 1 source file",
        "pyrefly": "INFO revealed type: dict[str, str] [reveal-type]\n  --> _pytifex_temp_3716177.py:20:16\n   |\n20 |     reveal_type(settings) # Expected: dict[str, str]\n   |                ----------\n   |\n INFO revealed type: dict[Unknown, Unknown] [reveal-type]\n  --> _pytifex_temp_3716177.py:30:16\n   |\n30 |     reveal_type({**source_union}) # Does it correctly infer dict[str, str] or dict[Unknown, Unknown]?\n   |                ------------------\n   |\nERROR Expected a mapping, got FlexibleConfigSource | dict[str, str] [invalid-argument]\n  --> _pytifex_temp_3716177.py:30:20\n   |\n30 |     reveal_type({**source_union}) # Does it correctly infer dict[str, str] or dict[Unknown, Unknown]?\n   |                    ^^^^^^^^^^^^\n   |\n INFO revealed type: dict[str, str] [reveal-type]\n  --> _pytifex_temp_3716177.py:31:16\n   |\n31 |     reveal_type({**direct_dict})  # Expected: dict[str, str]\n   |                -----------------\n   |\n INFO revealed type: dict[Unknown, Unknown] [reveal-type]\n  --> _pytifex_temp_3716177.py:32:16\n   |\n32 |     reveal_type({**direct_flex})  # Expected: dict[Unknown, Unknown] or error due to missing items()\n   |                -----------------\n   |\nERROR Expected a mapping, got FlexibleConfigSource [invalid-argument]\n  --> _pytifex_temp_3716177.py:32:20\n   |\n32 |     reveal_type({**direct_flex})  # Expected: dict[Unknown, Unknown] or error due to missing items()\n   |                    ^^^^^^^^^^^\n   |\nERROR Expected argument after ** to be a mapping, got: FlexibleConfigSource | dict[str, str] in function `apply_settings` [bad-unpacking]\n  --> _pytifex_temp_3716177.py:35:22\n   |\n35 |     apply_settings(**source_union) # Will checker allow this if `source_union` could be `FlexibleConfigSource`?\n   |                      ^^^^^^^^^^^^\n   |\nERROR Expected argument after ** to be a mapping, got: FlexibleConfigSource in function `apply_settings` [bad-unpacking]\n  --> _pytifex_temp_3716177.py:37:22\n   |\n37 |     apply_settings(**direct_flex) # Should cause runtime TypeError, checker might miss.\n   |                      ^^^^^^^^^^^\n   |\n INFO revealed type: dict[str, str] [reveal-type]\n  --> _pytifex_temp_3716177.py:51:16\n   |\n51 |     reveal_type({**my_dict})\n   |                -------------\n   |\n INFO revealed type: dict[Unknown, Unknown] [reveal-type]\n  --> _pytifex_temp_3716177.py:52:16\n   |\n52 |     reveal_type({**my_flex_source})\n   |                --------------------\n   |\nERROR Expected a mapping, got FlexibleConfigSource [invalid-argument]\n  --> _pytifex_temp_3716177.py:52:20\n   |\n52 |     reveal_type({**my_flex_source})\n   |                    ^^^^^^^^^^^^^^\n   |\n INFO 5 errors",
        "zuban": "_pytifex_temp_3716177.py:20: note: Revealed type is \"builtins.dict[builtins.str, builtins.str]\"\n_pytifex_temp_3716177.py:30: note: Revealed type is \"builtins.dict[builtins.str, builtins.str | Any]\"\n_pytifex_temp_3716177.py:31: note: Revealed type is \"builtins.dict[builtins.str, builtins.str]\"\n_pytifex_temp_3716177.py:32: note: Revealed type is \"builtins.dict[builtins.str, Any]\"\n_pytifex_temp_3716177.py:51: note: Revealed type is \"builtins.dict[builtins.str, builtins.str]\"\n_pytifex_temp_3716177.py:52: note: Revealed type is \"builtins.dict[builtins.str, Any]\"\nSuccess: no issues found in 1 source file",
        "ty": "info[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:20:17\n   |\n19 | def apply_settings(**settings: str) -> dict[str, str]: # Expects all values to be str\n20 |     reveal_type(settings) # Expected: dict[str, str]\n   |                 ^^^^^^^^ `dict[str, str]`\n21 |     print(f\"Applied settings: {settings}\")\n22 |     return settings\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:30:17\n   |\n28 | ):\n29 |     # Testing direct splat into a dict literal\n30 |     reveal_type({**source_union}) # Does it correctly infer dict[str, str] or dict[Unknown, Unknown]?\n   |                 ^^^^^^^^^^^^^^^^ `dict[Unknown, Unknown]`\n31 |     reveal_type({**direct_dict})  # Expected: dict[str, str]\n32 |     reveal_type({**direct_flex})  # Expected: dict[Unknown, Unknown] or error due to missing items()\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:31:17\n   |\n29 |     # Testing direct splat into a dict literal\n30 |     reveal_type({**source_union}) # Does it correctly infer dict[str, str] or dict[Unknown, Unknown]?\n31 |     reveal_type({**direct_dict})  # Expected: dict[str, str]\n   |                 ^^^^^^^^^^^^^^^ `dict[Unknown | str, Unknown | str]`\n32 |     reveal_type({**direct_flex})  # Expected: dict[Unknown, Unknown] or error due to missing items()\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:32:17\n   |\n30 |     reveal_type({**source_union}) # Does it correctly infer dict[str, str] or dict[Unknown, Unknown]?\n31 |     reveal_type({**direct_dict})  # Expected: dict[str, str]\n32 |     reveal_type({**direct_flex})  # Expected: dict[Unknown, Unknown] or error due to missing items()\n   |                 ^^^^^^^^^^^^^^^ `dict[Unknown, Unknown]`\n33 |\n34 |     # Testing splat into a function call with type-hinted kwargs\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:51:17\n   |\n50 |     # For type checking only, without runtime crash:\n51 |     reveal_type({**my_dict})\n   |                 ^^^^^^^^^^^ `dict[Unknown | str, Unknown | str]`\n52 |     reveal_type({**my_flex_source})\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:52:17\n   |\n50 |     # For type checking only, without runtime crash:\n51 |     reveal_type({**my_dict})\n52 |     reveal_type({**my_flex_source})\n   |                 ^^^^^^^^^^^^^^^^^^ `dict[Unknown, Unknown]`\n53 |     \n54 |     # The `apply_settings` calls are the key:\n   |\n\nFound 6 diagnostics"
      },
      "statuses": {
        "mypy": "ok",
        "pyrefly": "error",
        "zuban": "ok",
        "ty": "error"
      }
    },
    {
      "filename": "nested-paramspec-callable-return.py",
      "filepath": "generated_examples/2026-01-27_15-05-49/source_files/nested-paramspec-callable-return.py",
      "seed_issue": "mypy #20452",
      "outputs": {
        "mypy": "_pytifex_temp_3716177.py:28: error: Argument 1 to \"sum\" has incompatible type \"P_INNER.args\"; expected \"Iterable[bool]\"  [arg-type]\n_pytifex_temp_3716177.py:28: note: Error code \"arg-type\" not covered by \"type: ignore\" comment\n_pytifex_temp_3716177.py:35: error: Need type annotation for \"inner_factory_true\"  [var-annotated]\n_pytifex_temp_3716177.py:37: note: Revealed type is \"def (builtins.str, *Any, **Any) -> Any\"\n_pytifex_temp_3716177.py:43: note: Revealed type is \"Any\"\n_pytifex_temp_3716177.py:45: error: Need type annotation for \"inner_factory_false\"  [var-annotated]\n_pytifex_temp_3716177.py:48: note: Revealed type is \"Any\"\nFound 3 errors in 1 file (checked 1 source file)",
        "pyrefly": "INFO revealed type: [P_INNER, R_INNER](str, ParamSpec(P_INNER)) -> R_INNER [reveal-type]\n  --> _pytifex_temp_3716177.py:37:12\n   |\n37 | reveal_type(inner_factory_true) # Expected: Callable[Concatenate[str, P_INNER], R_INNER]\n   |            --------------------\n   |\n INFO revealed type: Unknown [reveal-type]\n  --> _pytifex_temp_3716177.py:43:12\n   |\n43 | reveal_type(result_len) # Expected: int\n   |            ------------\n   |\n INFO revealed type: Unknown [reveal-type]\n  --> _pytifex_temp_3716177.py:48:12\n   |\n48 | reveal_type(result_sum) # Expected: int\n   |            ------------\n   |\n INFO 0 errors (2 suppressed)",
        "zuban": "_pytifex_temp_3716177.py:18: error: ParamSpec \"P_OUTER\" is unbound  [misc]\n_pytifex_temp_3716177.py:21: error: ParamSpec \"P_INNER\" is unbound  [misc]\n_pytifex_temp_3716177.py:21: error: A function returning TypeVar should receive at least one argument containing the same Typevar  [type-var]\n_pytifex_temp_3716177.py:28: error: No overload variant of \"sum\" matches argument type \"P_INNER.args\"  [call-overload]\n_pytifex_temp_3716177.py:28: note: Possible overload variants:\n_pytifex_temp_3716177.py:28: note:     def sum(Iterable[Literal[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20, 0] | bool], /, start: int = ...) -> int\n_pytifex_temp_3716177.py:28: note:     def [_SupportsSumNoDefaultT: _SupportsSumWithNoDefaultGiven] sum(Iterable[_SupportsSumNoDefaultT], /) -> _SupportsSumNoDefaultT | Literal[0]\n_pytifex_temp_3716177.py:28: note:     def [_AddableT1: SupportsAdd[Any, Any], _AddableT2: SupportsAdd[Any, Any]] sum(Iterable[_AddableT1], /, start: _AddableT2) -> _AddableT1 | _AddableT2\n_pytifex_temp_3716177.py:28: note: Error code \"call-overload\" not covered by \"type: ignore\" comment\n_pytifex_temp_3716177.py:37: note: Revealed type is \"def [P_INNER, R_INNER] (builtins.str, *P_INNER.args, **P_INNER.kwargs) -> R_INNER\"\n_pytifex_temp_3716177.py:41: error: Need type annotation for \"result_len\"  [var-annotated]\n_pytifex_temp_3716177.py:43: note: Revealed type is \"Any\"\n_pytifex_temp_3716177.py:46: error: Need type annotation for \"result_sum\"  [var-annotated]\n_pytifex_temp_3716177.py:48: note: Revealed type is \"Any\"\nFound 6 errors in 1 file (checked 1 source file)",
        "ty": "info[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:37:13\n   |\n35 | inner_factory_true = create_conditional_executor_factory(True)() # Calls outer_factory with empty P_OUTER\n36 |\n37 | reveal_type(inner_factory_true) # Expected: Callable[Concatenate[str, P_INNER], R_INNER]\n   |             ^^^^^^^^^^^^^^^^^^ `(...) -> Unknown`\n38 |\n39 | # Call the executor, providing the `str` for Concatenate and then P_INNER args.\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:43:13\n   |\n41 | result_len = inner_factory_true(\"Count elements\", 1, 2, 3)\n42 | print(f\"Result (condition=True): {result_len}\") # Expected: 3\n43 | reveal_type(result_len) # Expected: int\n   |             ^^^^^^^^^^ `Unknown`\n44 |\n45 | inner_factory_false = create_conditional_executor_factory(False)()\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:48:13\n   |\n46 | result_sum = inner_factory_false(\"Sum elements\", 10, 20, x=30)\n47 | print(f\"Result (condition=False): {result_sum}\") # Expected: 30 (sum of 10, 20 assuming x ignored for sum)\n48 | reveal_type(result_sum) # Expected: int\n   |             ^^^^^^^^^^ `Unknown`\n49 |\n50 | print(\"\\nExample demonstrating nested ParamSpec and Concatenate in return types of higher-order functions.\")\n   |\n\nFound 3 diagnostics"
      },
      "statuses": {
        "mypy": "error",
        "pyrefly": "ok",
        "zuban": "error",
        "ty": "ok"
      }
    },
    {
      "filename": "ternary-literal-type-inference.py",
      "filepath": "generated_examples/2026-01-27_15-05-49/source_files/ternary-literal-type-inference.py",
      "seed_issue": "mypy #19561",
      "outputs": {
        "mypy": "_pytifex_temp_3716177.py:6: note: Revealed type is \"builtins.int\"\n_pytifex_temp_3716177.py:7: error: Incompatible return value type (got \"int\", expected \"Literal[5432, 1234]\")  [return-value]\n_pytifex_temp_3716177.py:10: note: Revealed type is \"Literal[5432] | Literal[1234]\"\n_pytifex_temp_3716177.py:24: note: Revealed type is \"Literal[5432] | Literal[1234]\"\n_pytifex_temp_3716177.py:38: note: Revealed type is \"Literal[True] | Literal[False]\"\n_pytifex_temp_3716177.py:41: note: Revealed type is \"Literal[True] | Literal[False]\"\nFound 1 error in 1 file (checked 1 source file)",
        "pyrefly": "INFO revealed type: Literal[1234, 5432] [reveal-type]\n --> _pytifex_temp_3716177.py:6:16\n  |\n6 |     reveal_type(port) # Expected: Literal[5432] if \"dev\"|\"test\", else Literal[1234], overall Union[Literal[5432], Literal[1234]]\n  |                ------\n  |\n INFO revealed type: Literal[1234, 5432] [reveal-type]\n  --> _pytifex_temp_3716177.py:10:16\n   |\n10 |     reveal_type(port) # Expected: Union[Literal[5432], Literal[1234]]\n   |                ------\n   |\n INFO revealed type: Literal[1234, 5432] [reveal-type]\n  --> _pytifex_temp_3716177.py:24:16\n   |\n24 |     reveal_type(db_connection_port) # Expected: Union[Literal[1234], Literal[5432]] (the full union)\n   |                --------------------\n   |\n INFO revealed type: bool [reveal-type]\n  --> _pytifex_temp_3716177.py:38:16\n   |\n38 |     reveal_type(app_debug_setting) # Expected: Union[Literal[True], Literal[False]]\n   |                -------------------\n   |\n INFO revealed type: bool [reveal-type]\n  --> _pytifex_temp_3716177.py:41:16\n   |\n41 |     reveal_type(app.debug_mode) # Expected: Union[Literal[True], Literal[False]]\n   |                ----------------\n   |\n INFO 0 errors",
        "zuban": "_pytifex_temp_3716177.py:6: note: Revealed type is \"builtins.int\"\n_pytifex_temp_3716177.py:7: error: Incompatible return value type (got \"int\", expected \"Literal[5432, 1234]\")  [return-value]\n_pytifex_temp_3716177.py:10: note: Revealed type is \"Literal[5432] | Literal[1234]\"\n_pytifex_temp_3716177.py:24: note: Revealed type is \"Literal[5432] | Literal[1234]\"\n_pytifex_temp_3716177.py:38: note: Revealed type is \"Literal[True] | Literal[False]\"\n_pytifex_temp_3716177.py:41: note: Revealed type is \"Literal[True] | Literal[False]\"\nFound 1 errors in 1 file (checked 1 source file)",
        "ty": "info[revealed-type]: Revealed type\n --> _pytifex_temp_3716177.py:6:17\n  |\n4 |     \"\"\"Returns a database port based on environment mode.\"\"\"\n5 |     port = 5432 if env_mode == \"dev\" or env_mode == \"test\" else 1234\n6 |     reveal_type(port) # Expected: Literal[5432] if \"dev\"|\"test\", else Literal[1234], overall Union[Literal[5432], Literal[1234]]\n  |                 ^^^^ `Literal[5432, 1234]`\n7 |     return port\n  |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:10:17\n   |\n 9 | def connect_to_db(address: str, port: Union[Literal[5432], Literal[1234]]):\n10 |     reveal_type(port) # Expected: Union[Literal[5432], Literal[1234]]\n   |                 ^^^^ `Literal[5432, 1234]`\n11 |     if port == 5432:\n12 |         print(f\"Connecting to production/dev DB at {address}:{port}\")\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:24:17\n   |\n22 |         get_db_port(\"prod\") if runtime_env_str == \"production\" else get_db_port(\"test\")\n23 |     )\n24 |     reveal_type(db_connection_port) # Expected: Union[Literal[1234], Literal[5432]] (the full union)\n   |                 ^^^^^^^^^^^^^^^^^^ `Literal[5432, 1234]`\n25 |\n26 |     # The type checker must correctly maintain the Union type for `db_connection_port`\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:38:17\n   |\n36 |         True if runtime_env_str.startswith(\"dev\") else False\n37 |     )\n38 |     reveal_type(app_debug_setting) # Expected: Union[Literal[True], Literal[False]]\n   |                 ^^^^^^^^^^^^^^^^^ `bool`\n39 |     \n40 |     app = AppConfig(app_debug_setting) # This should be fine\n   |\n\ninfo[revealed-type]: Revealed type\n  --> _pytifex_temp_3716177.py:41:17\n   |\n40 |     app = AppConfig(app_debug_setting) # This should be fine\n41 |     reveal_type(app.debug_mode) # Expected: Union[Literal[True], Literal[False]]\n   |                 ^^^^^^^^^^^^^^ `Unknown | bool`\n42 |\n43 | if __name__ == \"__main__\":\n   |\n\nFound 5 diagnostics"
      },
      "statuses": {
        "mypy": "error",
        "pyrefly": "ok",
        "zuban": "error",
        "ty": "ok"
      }
    }
  ]
}