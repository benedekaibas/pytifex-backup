{
    "timestamp": "2026-01-13T21:24:04.035931",
    "model_used": "gemini-2.5-flash",
    "raw_response": "# id: protocol-default-value-divergence\n# category: protocol-defaults\n# expected: mypy: ok, pyrefly: ok, zuban: error, ty: error\n```python\nfrom typing import Protocol\n\nclass GreeterProtocol(Protocol):\n    \"\"\"\n    A protocol defining a method with a specific default argument value.\n    \"\"\"\n    def greet(self, name: str = \"World\") -> str:\n        \"\"\"\n        Protocol method with a default argument 'name' set to \"World\".\n        \"\"\"\n        ...\n\nclass StandardGreeter:\n    \"\"\"\n    Implements GreeterProtocol with an identical default argument value.\n    This implementation should be compatible with the protocol for all type checkers.\n    \"\"\"\n    def greet(self, name: str = \"World\") -> str:\n        return f\"Hello, {name}!\"\n\nclass CustomDefaultGreeter:\n    \"\"\"\n    Implements GreeterProtocol but with a different default 'name' value (\"Friend\").\n    Some type checkers consider changing the default *value* incompatible with the protocol\n    even if the method signature (parameter name, type, and optionality) remains compatible.\n    Others are more lenient, focusing only on the callable signature and ignoring default values.\n    \"\"\"\n    def greet(self, name: str = \"Friend\") -> str: # Divergence point: default value is \"Friend\" instead of \"World\"\n        return f\"Greetings, {name}!\"\n\ndef introduce_person(greeter: GreeterProtocol, custom_name: str | None = None) -> None:\n    \"\"\"\n    A function that expects an object adhering to GreeterProtocol.\n    It calls the greet method, sometimes relying on the default.\n    \"\"\"\n    if custom_name:\n        print(f\"Introducing (with custom name): {greeter.greet(custom_name)}\")\n    else:\n        # This call relies on the default value defined in the *implementation*.\n        # The type checker evaluates if `CustomDefaultGreeter` is assignable to `GreeterProtocol`.\n        print(f\"Introducing (with default): {greeter.greet()}\")\n\nif __name__ == \"__main__\":\n    # This assignment should pass for all checkers as the default matches.\n    standard_impl: GreeterProtocol = StandardGreeter()\n    introduce_person(standard_impl) # Expected runtime output: \"Introducing (with default): Hello, World!\"\n\n    # This is the primary point of divergence:\n    # Will `CustomDefaultGreeter` be accepted as a `GreeterProtocol`?\n    # Mypy often allows this, as it considers the *signature* (optional string parameter)\n    # compatible, disregarding the exact default *value*.\n    # Other type checkers might be stricter and flag an error here.\n    custom_impl: GreeterProtocol = CustomDefaultGreeter()\n    introduce_person(custom_impl) # Expected runtime output: \"Introducing (with default): Greetings, Friend!\" (if accepted)\n\n    # Example with explicit name for verification\n    introduce_person(standard_impl, \"Alice\") # Expected runtime output: \"Introducing (with custom name): Hello, Alice!\"\n    introduce_person(custom_impl, \"Bob\")     # Expected runtime output: \"Introducing (with custom name): Greetings, Bob!\"\n```\n\n# id: typed-dict-mixed-total-inheritance\n# category: typed-dict-total\n# expected: mypy: error, pyrefly: ok, zuban: ok, ty: ok\n```python\nfrom typing import TypedDict, Required, NotRequired\n\n# A base TypedDict where all fields are implicitly Required (default total=True)\nclass StrictConfigBase(TypedDict, total=True):\n    \"\"\"\n    Defines configuration fields that are implicitly required.\n    \"\"\"\n    config_id: int\n    config_name: str\n\n# Another base TypedDict where all fields are implicitly NotRequired (total=False)\nclass OptionalFeaturesBase(TypedDict, total=False):\n    \"\"\"\n    Defines optional features that are implicitly not required.\n    \"\"\"\n    feature_a_enabled: bool\n    feature_b_value: float\n\n# ComplexConfig inherits from both. According to PEP 589:\n# \"If any of the base classes has total=False, then the new TypedDict type has total=False.\"\n# Thus, ComplexConfig itself is `total=False`.\n# The divergence point is how fields inherited from `StrictConfigBase` (which were implicitly Required)\n# are treated in `ComplexConfig` (which is `total=False`).\n# PEP 655 states: \"Required/NotRequired take precedence over the 'total' parameter,\n# regardless of whether the field is introduced in the current TypedDict or inherited from a base class.\"\n# This implies that `config_id` and `config_name` *should* become `NotRequired`\n# because `ComplexConfig` is `total=False` and they are not explicitly marked `Required`.\n# However, some type checkers (e.g., mypy) might retain the \"implicitly Required\" status\n# for fields inherited from `total=True` bases, even when the child is `total=False`.\nclass ComplexConfig(StrictConfigBase, OptionalFeaturesBase):\n    \"\"\"\n    Combines strict and optional configurations, with its own specific requirements.\n    This TypedDict itself is total=False due to inheriting OptionalFeaturesBase.\n    \"\"\"\n    # This field is explicitly Required, overriding ComplexConfig's total=False default for new fields.\n    required_setting: Required[str]\n    # This field is explicitly NotRequired, consistent with ComplexConfig's total=False default.\n    optional_comment: NotRequired[str]\n\ndef process_complex_config(data: ComplexConfig) -> None:\n    \"\"\"\n    Processes the complex configuration data.\n    \"\"\"\n    print(f\"Config ID: {data.get('config_id', 'N/A')}\")\n    print(f\"Config Name: {data.get('config_name', 'N/A')}\")\n    print(f\"Feature A Enabled: {data.get('feature_a_enabled', False)}\")\n    print(f\"Feature B Value: {data.get('feature_b_value', 0.0)}\")\n    print(f\"Required Setting: {data['required_setting']}\")\n    print(f\"Optional Comment: {data.get('optional_comment', 'No comment')}\\n\")\n\nif __name__ == \"__main__\":\n    # This dictionary is missing 'config_id' and 'config_name' (originally from StrictConfigBase, total=True).\n    # It is also missing 'feature_a_enabled' and 'feature_b_value' (from OptionalFeaturesBase, total=False).\n    # It *must* include 'required_setting' (explicitly Required in ComplexConfig).\n    #\n    # The divergence occurs on the fields from `StrictConfigBase`:\n    # Will `config_id` and `config_name` remain `Required` (leading to an error here),\n    # or will they become `NotRequired` due to `ComplexConfig` being `total=False` (allowing this to pass)?\n    test_config_data_missing_inherited_required: ComplexConfig = {\n        \"required_setting\": \"enabled\",\n        \"optional_comment\": \"This is fine, it's optional\",\n        # 'config_id' and 'config_name' are MISSING.\n        # Mypy and some others would flag this as an error.\n        # Other checkers might pass, interpreting `total=False` as overriding\n        # implicit requirements from parent `total=True` TypedDicts.\n    }\n    print(\"Testing config missing inherited (implicitly) required fields:\")\n    process_complex_config(test_config_data_missing_inherited_required)\n\n    # This example should always pass, as all fields (including optional ones) are present.\n    full_config_data: ComplexConfig = {\n        \"config_id\": 123,\n        \"config_name\": \"MainConfig\",\n        \"feature_a_enabled\": True,\n        \"feature_b_value\": 0.5,\n        \"required_setting\": \"global_access\",\n        \"optional_comment\": \"Full configuration example\"\n    }\n    print(\"Testing config with all fields present:\")\n    process_complex_config(full_config_data)\n\n    # This example should always fail across all strict type checkers,\n    # as it's missing an explicitly `Required` field (`required_setting`).\n    # invalid_config_data_missing_explicit_required: ComplexConfig = {\n    #     \"config_id\": 123,\n    #     \"config_name\": \"MainConfig\",\n    #     \"feature_a_enabled\": True,\n    #     # missing \"required_setting\"\n    # }\n    # print(\"Testing config missing explicitly required field (should error):\")\n    # process_complex_config(invalid_config_data_missing_explicit_required)\n```",
    "examples": [
        {
            "id": "protocol-default-value-divergence",
            "metadata": "# category: protocol-defaults\n# expected: mypy: ok, pyrefly: ok, zuban: error, ty: error",
            "code": "from typing import Protocol\n\nclass GreeterProtocol(Protocol):\n    \"\"\"\n    A protocol defining a method with a specific default argument value.\n    \"\"\"\n    def greet(self, name: str = \"World\") -> str:\n        \"\"\"\n        Protocol method with a default argument 'name' set to \"World\".\n        \"\"\"\n        ...\n\nclass StandardGreeter:\n    \"\"\"\n    Implements GreeterProtocol with an identical default argument value.\n    This implementation should be compatible with the protocol for all type checkers.\n    \"\"\"\n    def greet(self, name: str = \"World\") -> str:\n        return f\"Hello, {name}!\"\n\nclass CustomDefaultGreeter:\n    \"\"\"\n    Implements GreeterProtocol but with a different default 'name' value (\"Friend\").\n    Some type checkers consider changing the default *value* incompatible with the protocol\n    even if the method signature (parameter name, type, and optionality) remains compatible.\n    Others are more lenient, focusing only on the callable signature and ignoring default values.\n    \"\"\"\n    def greet(self, name: str = \"Friend\") -> str: # Divergence point: default value is \"Friend\" instead of \"World\"\n        return f\"Greetings, {name}!\"\n\ndef introduce_person(greeter: GreeterProtocol, custom_name: str | None = None) -> None:\n    \"\"\"\n    A function that expects an object adhering to GreeterProtocol.\n    It calls the greet method, sometimes relying on the default.\n    \"\"\"\n    if custom_name:\n        print(f\"Introducing (with custom name): {greeter.greet(custom_name)}\")\n    else:\n        # This call relies on the default value defined in the *implementation*.\n        # The type checker evaluates if `CustomDefaultGreeter` is assignable to `GreeterProtocol`.\n        print(f\"Introducing (with default): {greeter.greet()}\")\n\nif __name__ == \"__main__\":\n    # This assignment should pass for all checkers as the default matches.\n    standard_impl: GreeterProtocol = StandardGreeter()\n    introduce_person(standard_impl) # Expected runtime output: \"Introducing (with default): Hello, World!\"\n\n    # This is the primary point of divergence:\n    # Will `CustomDefaultGreeter` be accepted as a `GreeterProtocol`?\n    # Mypy often allows this, as it considers the *signature* (optional string parameter)\n    # compatible, disregarding the exact default *value*.\n    # Other type checkers might be stricter and flag an error here.\n    custom_impl: GreeterProtocol = CustomDefaultGreeter()\n    introduce_person(custom_impl) # Expected runtime output: \"Introducing (with default): Greetings, Friend!\" (if accepted)\n\n    # Example with explicit name for verification\n    introduce_person(standard_impl, \"Alice\") # Expected runtime output: \"Introducing (with custom name): Hello, Alice!\"\n    introduce_person(custom_impl, \"Bob\")     # Expected runtime output: \"Introducing (with custom name): Greetings, Bob!\"",
            "full_content": "# id: protocol-default-value-divergence\n# category: protocol-defaults\n# expected: mypy: ok, pyrefly: ok, zuban: error, ty: error\n\nfrom typing import Protocol\n\nclass GreeterProtocol(Protocol):\n    \"\"\"\n    A protocol defining a method with a specific default argument value.\n    \"\"\"\n    def greet(self, name: str = \"World\") -> str:\n        \"\"\"\n        Protocol method with a default argument 'name' set to \"World\".\n        \"\"\"\n        ...\n\nclass StandardGreeter:\n    \"\"\"\n    Implements GreeterProtocol with an identical default argument value.\n    This implementation should be compatible with the protocol for all type checkers.\n    \"\"\"\n    def greet(self, name: str = \"World\") -> str:\n        return f\"Hello, {name}!\"\n\nclass CustomDefaultGreeter:\n    \"\"\"\n    Implements GreeterProtocol but with a different default 'name' value (\"Friend\").\n    Some type checkers consider changing the default *value* incompatible with the protocol\n    even if the method signature (parameter name, type, and optionality) remains compatible.\n    Others are more lenient, focusing only on the callable signature and ignoring default values.\n    \"\"\"\n    def greet(self, name: str = \"Friend\") -> str: # Divergence point: default value is \"Friend\" instead of \"World\"\n        return f\"Greetings, {name}!\"\n\ndef introduce_person(greeter: GreeterProtocol, custom_name: str | None = None) -> None:\n    \"\"\"\n    A function that expects an object adhering to GreeterProtocol.\n    It calls the greet method, sometimes relying on the default.\n    \"\"\"\n    if custom_name:\n        print(f\"Introducing (with custom name): {greeter.greet(custom_name)}\")\n    else:\n        # This call relies on the default value defined in the *implementation*.\n        # The type checker evaluates if `CustomDefaultGreeter` is assignable to `GreeterProtocol`.\n        print(f\"Introducing (with default): {greeter.greet()}\")\n\nif __name__ == \"__main__\":\n    # This assignment should pass for all checkers as the default matches.\n    standard_impl: GreeterProtocol = StandardGreeter()\n    introduce_person(standard_impl) # Expected runtime output: \"Introducing (with default): Hello, World!\"\n\n    # This is the primary point of divergence:\n    # Will `CustomDefaultGreeter` be accepted as a `GreeterProtocol`?\n    # Mypy often allows this, as it considers the *signature* (optional string parameter)\n    # compatible, disregarding the exact default *value*.\n    # Other type checkers might be stricter and flag an error here.\n    custom_impl: GreeterProtocol = CustomDefaultGreeter()\n    introduce_person(custom_impl) # Expected runtime output: \"Introducing (with default): Greetings, Friend!\" (if accepted)\n\n    # Example with explicit name for verification\n    introduce_person(standard_impl, \"Alice\") # Expected runtime output: \"Introducing (with custom name): Hello, Alice!\"\n    introduce_person(custom_impl, \"Bob\")     # Expected runtime output: \"Introducing (with custom name): Greetings, Bob!\""
        },
        {
            "id": "typed-dict-mixed-total-inheritance",
            "metadata": "# category: typed-dict-total\n# expected: mypy: error, pyrefly: ok, zuban: ok, ty: ok",
            "code": "from typing import TypedDict, Required, NotRequired\n\n# A base TypedDict where all fields are implicitly Required (default total=True)\nclass StrictConfigBase(TypedDict, total=True):\n    \"\"\"\n    Defines configuration fields that are implicitly required.\n    \"\"\"\n    config_id: int\n    config_name: str\n\n# Another base TypedDict where all fields are implicitly NotRequired (total=False)\nclass OptionalFeaturesBase(TypedDict, total=False):\n    \"\"\"\n    Defines optional features that are implicitly not required.\n    \"\"\"\n    feature_a_enabled: bool\n    feature_b_value: float\n\n# ComplexConfig inherits from both. According to PEP 589:\n# \"If any of the base classes has total=False, then the new TypedDict type has total=False.\"\n# Thus, ComplexConfig itself is `total=False`.\n# The divergence point is how fields inherited from `StrictConfigBase` (which were implicitly Required)\n# are treated in `ComplexConfig` (which is `total=False`).\n# PEP 655 states: \"Required/NotRequired take precedence over the 'total' parameter,\n# regardless of whether the field is introduced in the current TypedDict or inherited from a base class.\"\n# This implies that `config_id` and `config_name` *should* become `NotRequired`\n# because `ComplexConfig` is `total=False` and they are not explicitly marked `Required`.\n# However, some type checkers (e.g., mypy) might retain the \"implicitly Required\" status\n# for fields inherited from `total=True` bases, even when the child is `total=False`.\nclass ComplexConfig(StrictConfigBase, OptionalFeaturesBase):\n    \"\"\"\n    Combines strict and optional configurations, with its own specific requirements.\n    This TypedDict itself is total=False due to inheriting OptionalFeaturesBase.\n    \"\"\"\n    # This field is explicitly Required, overriding ComplexConfig's total=False default for new fields.\n    required_setting: Required[str]\n    # This field is explicitly NotRequired, consistent with ComplexConfig's total=False default.\n    optional_comment: NotRequired[str]\n\ndef process_complex_config(data: ComplexConfig) -> None:\n    \"\"\"\n    Processes the complex configuration data.\n    \"\"\"\n    print(f\"Config ID: {data.get('config_id', 'N/A')}\")\n    print(f\"Config Name: {data.get('config_name', 'N/A')}\")\n    print(f\"Feature A Enabled: {data.get('feature_a_enabled', False)}\")\n    print(f\"Feature B Value: {data.get('feature_b_value', 0.0)}\")\n    print(f\"Required Setting: {data['required_setting']}\")\n    print(f\"Optional Comment: {data.get('optional_comment', 'No comment')}\\n\")\n\nif __name__ == \"__main__\":\n    # This dictionary is missing 'config_id' and 'config_name' (originally from StrictConfigBase, total=True).\n    # It is also missing 'feature_a_enabled' and 'feature_b_value' (from OptionalFeaturesBase, total=False).\n    # It *must* include 'required_setting' (explicitly Required in ComplexConfig).\n    #\n    # The divergence occurs on the fields from `StrictConfigBase`:\n    # Will `config_id` and `config_name` remain `Required` (leading to an error here),\n    # or will they become `NotRequired` due to `ComplexConfig` being `total=False` (allowing this to pass)?\n    test_config_data_missing_inherited_required: ComplexConfig = {\n        \"required_setting\": \"enabled\",\n        \"optional_comment\": \"This is fine, it's optional\",\n        # 'config_id' and 'config_name' are MISSING.\n        # Mypy and some others would flag this as an error.\n        # Other checkers might pass, interpreting `total=False` as overriding\n        # implicit requirements from parent `total=True` TypedDicts.\n    }\n    print(\"Testing config missing inherited (implicitly) required fields:\")\n    process_complex_config(test_config_data_missing_inherited_required)\n\n    # This example should always pass, as all fields (including optional ones) are present.\n    full_config_data: ComplexConfig = {\n        \"config_id\": 123,\n        \"config_name\": \"MainConfig\",\n        \"feature_a_enabled\": True,\n        \"feature_b_value\": 0.5,\n        \"required_setting\": \"global_access\",\n        \"optional_comment\": \"Full configuration example\"\n    }\n    print(\"Testing config with all fields present:\")\n    process_complex_config(full_config_data)\n\n    # This example should always fail across all strict type checkers,\n    # as it's missing an explicitly `Required` field (`required_setting`).\n    # invalid_config_data_missing_explicit_required: ComplexConfig = {\n    #     \"config_id\": 123,\n    #     \"config_name\": \"MainConfig\",\n    #     \"feature_a_enabled\": True,\n    #     # missing \"required_setting\"\n    # }\n    # print(\"Testing config missing explicitly required field (should error):\")\n    # process_complex_config(invalid_config_data_missing_explicit_required)",
            "full_content": "# id: typed-dict-mixed-total-inheritance\n# category: typed-dict-total\n# expected: mypy: error, pyrefly: ok, zuban: ok, ty: ok\n\nfrom typing import TypedDict, Required, NotRequired\n\n# A base TypedDict where all fields are implicitly Required (default total=True)\nclass StrictConfigBase(TypedDict, total=True):\n    \"\"\"\n    Defines configuration fields that are implicitly required.\n    \"\"\"\n    config_id: int\n    config_name: str\n\n# Another base TypedDict where all fields are implicitly NotRequired (total=False)\nclass OptionalFeaturesBase(TypedDict, total=False):\n    \"\"\"\n    Defines optional features that are implicitly not required.\n    \"\"\"\n    feature_a_enabled: bool\n    feature_b_value: float\n\n# ComplexConfig inherits from both. According to PEP 589:\n# \"If any of the base classes has total=False, then the new TypedDict type has total=False.\"\n# Thus, ComplexConfig itself is `total=False`.\n# The divergence point is how fields inherited from `StrictConfigBase` (which were implicitly Required)\n# are treated in `ComplexConfig` (which is `total=False`).\n# PEP 655 states: \"Required/NotRequired take precedence over the 'total' parameter,\n# regardless of whether the field is introduced in the current TypedDict or inherited from a base class.\"\n# This implies that `config_id` and `config_name` *should* become `NotRequired`\n# because `ComplexConfig` is `total=False` and they are not explicitly marked `Required`.\n# However, some type checkers (e.g., mypy) might retain the \"implicitly Required\" status\n# for fields inherited from `total=True` bases, even when the child is `total=False`.\nclass ComplexConfig(StrictConfigBase, OptionalFeaturesBase):\n    \"\"\"\n    Combines strict and optional configurations, with its own specific requirements.\n    This TypedDict itself is total=False due to inheriting OptionalFeaturesBase.\n    \"\"\"\n    # This field is explicitly Required, overriding ComplexConfig's total=False default for new fields.\n    required_setting: Required[str]\n    # This field is explicitly NotRequired, consistent with ComplexConfig's total=False default.\n    optional_comment: NotRequired[str]\n\ndef process_complex_config(data: ComplexConfig) -> None:\n    \"\"\"\n    Processes the complex configuration data.\n    \"\"\"\n    print(f\"Config ID: {data.get('config_id', 'N/A')}\")\n    print(f\"Config Name: {data.get('config_name', 'N/A')}\")\n    print(f\"Feature A Enabled: {data.get('feature_a_enabled', False)}\")\n    print(f\"Feature B Value: {data.get('feature_b_value', 0.0)}\")\n    print(f\"Required Setting: {data['required_setting']}\")\n    print(f\"Optional Comment: {data.get('optional_comment', 'No comment')}\\n\")\n\nif __name__ == \"__main__\":\n    # This dictionary is missing 'config_id' and 'config_name' (originally from StrictConfigBase, total=True).\n    # It is also missing 'feature_a_enabled' and 'feature_b_value' (from OptionalFeaturesBase, total=False).\n    # It *must* include 'required_setting' (explicitly Required in ComplexConfig).\n    #\n    # The divergence occurs on the fields from `StrictConfigBase`:\n    # Will `config_id` and `config_name` remain `Required` (leading to an error here),\n    # or will they become `NotRequired` due to `ComplexConfig` being `total=False` (allowing this to pass)?\n    test_config_data_missing_inherited_required: ComplexConfig = {\n        \"required_setting\": \"enabled\",\n        \"optional_comment\": \"This is fine, it's optional\",\n        # 'config_id' and 'config_name' are MISSING.\n        # Mypy and some others would flag this as an error.\n        # Other checkers might pass, interpreting `total=False` as overriding\n        # implicit requirements from parent `total=True` TypedDicts.\n    }\n    print(\"Testing config missing inherited (implicitly) required fields:\")\n    process_complex_config(test_config_data_missing_inherited_required)\n\n    # This example should always pass, as all fields (including optional ones) are present.\n    full_config_data: ComplexConfig = {\n        \"config_id\": 123,\n        \"config_name\": \"MainConfig\",\n        \"feature_a_enabled\": True,\n        \"feature_b_value\": 0.5,\n        \"required_setting\": \"global_access\",\n        \"optional_comment\": \"Full configuration example\"\n    }\n    print(\"Testing config with all fields present:\")\n    process_complex_config(full_config_data)\n\n    # This example should always fail across all strict type checkers,\n    # as it's missing an explicitly `Required` field (`required_setting`).\n    # invalid_config_data_missing_explicit_required: ComplexConfig = {\n    #     \"config_id\": 123,\n    #     \"config_name\": \"MainConfig\",\n    #     \"feature_a_enabled\": True,\n    #     # missing \"required_setting\"\n    # }\n    # print(\"Testing config missing explicitly required field (should error):\")\n    # process_complex_config(invalid_config_data_missing_explicit_required)"
        }
    ]
}